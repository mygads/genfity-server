
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model Subcategory
 * 
 */
export type Subcategory = $Result.DefaultSelection<Prisma.$SubcategoryPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Addon
 * 
 */
export type Addon = $Result.DefaultSelection<Prisma.$AddonPayload>
/**
 * Model Package
 * 
 */
export type Package = $Result.DefaultSelection<Prisma.$PackagePayload>
/**
 * Model WhatsAppSession
 * 
 */
export type WhatsAppSession = $Result.DefaultSelection<Prisma.$WhatsAppSessionPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model TransactionProduct
 * 
 */
export type TransactionProduct = $Result.DefaultSelection<Prisma.$TransactionProductPayload>
/**
 * Model TransactionAddons
 * 
 */
export type TransactionAddons = $Result.DefaultSelection<Prisma.$TransactionAddonsPayload>
/**
 * Model TransactionWhatsappService
 * 
 */
export type TransactionWhatsappService = $Result.DefaultSelection<Prisma.$TransactionWhatsappServicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model WhatsappApiPackage
 * 
 */
export type WhatsappApiPackage = $Result.DefaultSelection<Prisma.$WhatsappApiPackagePayload>
/**
 * Model ServicesWhatsappCustomers
 * 
 */
export type ServicesWhatsappCustomers = $Result.DefaultSelection<Prisma.$ServicesWhatsappCustomersPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Voucher
 * 
 */
export type Voucher = $Result.DefaultSelection<Prisma.$VoucherPayload>
/**
 * Model VoucherUsage
 * 
 */
export type VoucherUsage = $Result.DefaultSelection<Prisma.$VoucherUsagePayload>
/**
 * Model ServicesProductCustomers
 * 
 */
export type ServicesProductCustomers = $Result.DefaultSelection<Prisma.$ServicesProductCustomersPayload>
/**
 * Model ServicesAddonsCustomers
 * 
 */
export type ServicesAddonsCustomers = $Result.DefaultSelection<Prisma.$ServicesAddonsCustomersPayload>
/**
 * Model ServiceFee
 * 
 */
export type ServiceFee = $Result.DefaultSelection<Prisma.$ServiceFeePayload>
/**
 * Model BankDetail
 * 
 */
export type BankDetail = $Result.DefaultSelection<Prisma.$BankDetailPayload>
/**
 * Model Server
 * 
 */
export type Server = $Result.DefaultSelection<Prisma.$ServerPayload>
/**
 * Model WhatsAppMessageStats
 * 
 */
export type WhatsAppMessageStats = $Result.DefaultSelection<Prisma.$WhatsAppMessageStatsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subcategory`: Exposes CRUD operations for the **Subcategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subcategories
    * const subcategories = await prisma.subcategory.findMany()
    * ```
    */
  get subcategory(): Prisma.SubcategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addon`: Exposes CRUD operations for the **Addon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addons
    * const addons = await prisma.addon.findMany()
    * ```
    */
  get addon(): Prisma.AddonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.package`: Exposes CRUD operations for the **Package** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packages
    * const packages = await prisma.package.findMany()
    * ```
    */
  get package(): Prisma.PackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppSession`: Exposes CRUD operations for the **WhatsAppSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppSessions
    * const whatsAppSessions = await prisma.whatsAppSession.findMany()
    * ```
    */
  get whatsAppSession(): Prisma.WhatsAppSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionProduct`: Exposes CRUD operations for the **TransactionProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionProducts
    * const transactionProducts = await prisma.transactionProduct.findMany()
    * ```
    */
  get transactionProduct(): Prisma.TransactionProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionAddons`: Exposes CRUD operations for the **TransactionAddons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionAddons
    * const transactionAddons = await prisma.transactionAddons.findMany()
    * ```
    */
  get transactionAddons(): Prisma.TransactionAddonsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionWhatsappService`: Exposes CRUD operations for the **TransactionWhatsappService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionWhatsappServices
    * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany()
    * ```
    */
  get transactionWhatsappService(): Prisma.TransactionWhatsappServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsappApiPackage`: Exposes CRUD operations for the **WhatsappApiPackage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsappApiPackages
    * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany()
    * ```
    */
  get whatsappApiPackage(): Prisma.WhatsappApiPackageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicesWhatsappCustomers`: Exposes CRUD operations for the **ServicesWhatsappCustomers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicesWhatsappCustomers
    * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany()
    * ```
    */
  get servicesWhatsappCustomers(): Prisma.ServicesWhatsappCustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucher`: Exposes CRUD operations for the **Voucher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vouchers
    * const vouchers = await prisma.voucher.findMany()
    * ```
    */
  get voucher(): Prisma.VoucherDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voucherUsage`: Exposes CRUD operations for the **VoucherUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VoucherUsages
    * const voucherUsages = await prisma.voucherUsage.findMany()
    * ```
    */
  get voucherUsage(): Prisma.VoucherUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicesProductCustomers`: Exposes CRUD operations for the **ServicesProductCustomers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicesProductCustomers
    * const servicesProductCustomers = await prisma.servicesProductCustomers.findMany()
    * ```
    */
  get servicesProductCustomers(): Prisma.ServicesProductCustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicesAddonsCustomers`: Exposes CRUD operations for the **ServicesAddonsCustomers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicesAddonsCustomers
    * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findMany()
    * ```
    */
  get servicesAddonsCustomers(): Prisma.ServicesAddonsCustomersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceFee`: Exposes CRUD operations for the **ServiceFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceFees
    * const serviceFees = await prisma.serviceFee.findMany()
    * ```
    */
  get serviceFee(): Prisma.ServiceFeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankDetail`: Exposes CRUD operations for the **BankDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankDetails
    * const bankDetails = await prisma.bankDetail.findMany()
    * ```
    */
  get bankDetail(): Prisma.BankDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.server`: Exposes CRUD operations for the **Server** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servers
    * const servers = await prisma.server.findMany()
    * ```
    */
  get server(): Prisma.ServerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppMessageStats`: Exposes CRUD operations for the **WhatsAppMessageStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppMessageStats
    * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany()
    * ```
    */
  get whatsAppMessageStats(): Prisma.WhatsAppMessageStatsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Feature: 'Feature',
    Subcategory: 'Subcategory',
    Category: 'Category',
    Addon: 'Addon',
    Package: 'Package',
    WhatsAppSession: 'WhatsAppSession',
    Transaction: 'Transaction',
    TransactionProduct: 'TransactionProduct',
    TransactionAddons: 'TransactionAddons',
    TransactionWhatsappService: 'TransactionWhatsappService',
    Payment: 'Payment',
    WhatsappApiPackage: 'WhatsappApiPackage',
    ServicesWhatsappCustomers: 'ServicesWhatsappCustomers',
    UserSession: 'UserSession',
    Voucher: 'Voucher',
    VoucherUsage: 'VoucherUsage',
    ServicesProductCustomers: 'ServicesProductCustomers',
    ServicesAddonsCustomers: 'ServicesAddonsCustomers',
    ServiceFee: 'ServiceFee',
    BankDetail: 'BankDetail',
    Server: 'Server',
    WhatsAppMessageStats: 'WhatsAppMessageStats'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "feature" | "subcategory" | "category" | "addon" | "package" | "whatsAppSession" | "transaction" | "transactionProduct" | "transactionAddons" | "transactionWhatsappService" | "payment" | "whatsappApiPackage" | "servicesWhatsappCustomers" | "userSession" | "voucher" | "voucherUsage" | "servicesProductCustomers" | "servicesAddonsCustomers" | "serviceFee" | "bankDetail" | "server" | "whatsAppMessageStats"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      Subcategory: {
        payload: Prisma.$SubcategoryPayload<ExtArgs>
        fields: Prisma.SubcategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubcategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubcategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findFirst: {
            args: Prisma.SubcategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubcategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          findMany: {
            args: Prisma.SubcategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          create: {
            args: Prisma.SubcategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          createMany: {
            args: Prisma.SubcategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubcategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          delete: {
            args: Prisma.SubcategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          update: {
            args: Prisma.SubcategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          deleteMany: {
            args: Prisma.SubcategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubcategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubcategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>[]
          }
          upsert: {
            args: Prisma.SubcategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubcategoryPayload>
          }
          aggregate: {
            args: Prisma.SubcategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubcategory>
          }
          groupBy: {
            args: Prisma.SubcategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubcategoryCountArgs<ExtArgs>
            result: $Utils.Optional<SubcategoryCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Addon: {
        payload: Prisma.$AddonPayload<ExtArgs>
        fields: Prisma.AddonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          findFirst: {
            args: Prisma.AddonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          findMany: {
            args: Prisma.AddonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          create: {
            args: Prisma.AddonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          createMany: {
            args: Prisma.AddonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          delete: {
            args: Prisma.AddonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          update: {
            args: Prisma.AddonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          deleteMany: {
            args: Prisma.AddonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>[]
          }
          upsert: {
            args: Prisma.AddonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddonPayload>
          }
          aggregate: {
            args: Prisma.AddonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddon>
          }
          groupBy: {
            args: Prisma.AddonGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddonGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddonCountArgs<ExtArgs>
            result: $Utils.Optional<AddonCountAggregateOutputType> | number
          }
        }
      }
      Package: {
        payload: Prisma.$PackagePayload<ExtArgs>
        fields: Prisma.PackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findFirst: {
            args: Prisma.PackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          findMany: {
            args: Prisma.PackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          create: {
            args: Prisma.PackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          createMany: {
            args: Prisma.PackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          delete: {
            args: Prisma.PackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          update: {
            args: Prisma.PackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          deleteMany: {
            args: Prisma.PackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>[]
          }
          upsert: {
            args: Prisma.PackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackagePayload>
          }
          aggregate: {
            args: Prisma.PackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackage>
          }
          groupBy: {
            args: Prisma.PackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackageCountArgs<ExtArgs>
            result: $Utils.Optional<PackageCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppSession: {
        payload: Prisma.$WhatsAppSessionPayload<ExtArgs>
        fields: Prisma.WhatsAppSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          findMany: {
            args: Prisma.WhatsAppSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          create: {
            args: Prisma.WhatsAppSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          createMany: {
            args: Prisma.WhatsAppSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          update: {
            args: Prisma.WhatsAppSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppSessionPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppSession>
          }
          groupBy: {
            args: Prisma.WhatsAppSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppSessionCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      TransactionProduct: {
        payload: Prisma.$TransactionProductPayload<ExtArgs>
        fields: Prisma.TransactionProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          findFirst: {
            args: Prisma.TransactionProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          findMany: {
            args: Prisma.TransactionProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>[]
          }
          create: {
            args: Prisma.TransactionProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          createMany: {
            args: Prisma.TransactionProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>[]
          }
          delete: {
            args: Prisma.TransactionProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          update: {
            args: Prisma.TransactionProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          deleteMany: {
            args: Prisma.TransactionProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>[]
          }
          upsert: {
            args: Prisma.TransactionProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionProductPayload>
          }
          aggregate: {
            args: Prisma.TransactionProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionProduct>
          }
          groupBy: {
            args: Prisma.TransactionProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionProductCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionProductCountAggregateOutputType> | number
          }
        }
      }
      TransactionAddons: {
        payload: Prisma.$TransactionAddonsPayload<ExtArgs>
        fields: Prisma.TransactionAddonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionAddonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionAddonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          findFirst: {
            args: Prisma.TransactionAddonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionAddonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          findMany: {
            args: Prisma.TransactionAddonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>[]
          }
          create: {
            args: Prisma.TransactionAddonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          createMany: {
            args: Prisma.TransactionAddonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionAddonsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>[]
          }
          delete: {
            args: Prisma.TransactionAddonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          update: {
            args: Prisma.TransactionAddonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionAddonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionAddonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionAddonsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>[]
          }
          upsert: {
            args: Prisma.TransactionAddonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionAddonsPayload>
          }
          aggregate: {
            args: Prisma.TransactionAddonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionAddons>
          }
          groupBy: {
            args: Prisma.TransactionAddonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionAddonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionAddonsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionAddonsCountAggregateOutputType> | number
          }
        }
      }
      TransactionWhatsappService: {
        payload: Prisma.$TransactionWhatsappServicePayload<ExtArgs>
        fields: Prisma.TransactionWhatsappServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionWhatsappServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          findFirst: {
            args: Prisma.TransactionWhatsappServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          findMany: {
            args: Prisma.TransactionWhatsappServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          create: {
            args: Prisma.TransactionWhatsappServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          createMany: {
            args: Prisma.TransactionWhatsappServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          delete: {
            args: Prisma.TransactionWhatsappServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          update: {
            args: Prisma.TransactionWhatsappServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          deleteMany: {
            args: Prisma.TransactionWhatsappServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionWhatsappServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>[]
          }
          upsert: {
            args: Prisma.TransactionWhatsappServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionWhatsappServicePayload>
          }
          aggregate: {
            args: Prisma.TransactionWhatsappServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionWhatsappService>
          }
          groupBy: {
            args: Prisma.TransactionWhatsappServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionWhatsappServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionWhatsappServiceCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionWhatsappServiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      WhatsappApiPackage: {
        payload: Prisma.$WhatsappApiPackagePayload<ExtArgs>
        fields: Prisma.WhatsappApiPackageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsappApiPackageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          findFirst: {
            args: Prisma.WhatsappApiPackageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          findMany: {
            args: Prisma.WhatsappApiPackageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          create: {
            args: Prisma.WhatsappApiPackageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          createMany: {
            args: Prisma.WhatsappApiPackageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          delete: {
            args: Prisma.WhatsappApiPackageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          update: {
            args: Prisma.WhatsappApiPackageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          deleteMany: {
            args: Prisma.WhatsappApiPackageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsappApiPackageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>[]
          }
          upsert: {
            args: Prisma.WhatsappApiPackageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsappApiPackagePayload>
          }
          aggregate: {
            args: Prisma.WhatsappApiPackageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsappApiPackage>
          }
          groupBy: {
            args: Prisma.WhatsappApiPackageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsappApiPackageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsappApiPackageCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsappApiPackageCountAggregateOutputType> | number
          }
        }
      }
      ServicesWhatsappCustomers: {
        payload: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>
        fields: Prisma.ServicesWhatsappCustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesWhatsappCustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          findFirst: {
            args: Prisma.ServicesWhatsappCustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          findMany: {
            args: Prisma.ServicesWhatsappCustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          create: {
            args: Prisma.ServicesWhatsappCustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          createMany: {
            args: Prisma.ServicesWhatsappCustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          delete: {
            args: Prisma.ServicesWhatsappCustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          update: {
            args: Prisma.ServicesWhatsappCustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          deleteMany: {
            args: Prisma.ServicesWhatsappCustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesWhatsappCustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>[]
          }
          upsert: {
            args: Prisma.ServicesWhatsappCustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesWhatsappCustomersPayload>
          }
          aggregate: {
            args: Prisma.ServicesWhatsappCustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicesWhatsappCustomers>
          }
          groupBy: {
            args: Prisma.ServicesWhatsappCustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesWhatsappCustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesWhatsappCustomersCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesWhatsappCustomersCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Voucher: {
        payload: Prisma.$VoucherPayload<ExtArgs>
        fields: Prisma.VoucherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findFirst: {
            args: Prisma.VoucherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          findMany: {
            args: Prisma.VoucherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          create: {
            args: Prisma.VoucherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          createMany: {
            args: Prisma.VoucherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          delete: {
            args: Prisma.VoucherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          update: {
            args: Prisma.VoucherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          deleteMany: {
            args: Prisma.VoucherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>[]
          }
          upsert: {
            args: Prisma.VoucherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherPayload>
          }
          aggregate: {
            args: Prisma.VoucherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucher>
          }
          groupBy: {
            args: Prisma.VoucherGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherCountAggregateOutputType> | number
          }
        }
      }
      VoucherUsage: {
        payload: Prisma.$VoucherUsagePayload<ExtArgs>
        fields: Prisma.VoucherUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoucherUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoucherUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findFirst: {
            args: Prisma.VoucherUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoucherUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          findMany: {
            args: Prisma.VoucherUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          create: {
            args: Prisma.VoucherUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          createMany: {
            args: Prisma.VoucherUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoucherUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          delete: {
            args: Prisma.VoucherUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          update: {
            args: Prisma.VoucherUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          deleteMany: {
            args: Prisma.VoucherUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoucherUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoucherUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>[]
          }
          upsert: {
            args: Prisma.VoucherUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoucherUsagePayload>
          }
          aggregate: {
            args: Prisma.VoucherUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoucherUsage>
          }
          groupBy: {
            args: Prisma.VoucherUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoucherUsageCountArgs<ExtArgs>
            result: $Utils.Optional<VoucherUsageCountAggregateOutputType> | number
          }
        }
      }
      ServicesProductCustomers: {
        payload: Prisma.$ServicesProductCustomersPayload<ExtArgs>
        fields: Prisma.ServicesProductCustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesProductCustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesProductCustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          findFirst: {
            args: Prisma.ServicesProductCustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesProductCustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          findMany: {
            args: Prisma.ServicesProductCustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>[]
          }
          create: {
            args: Prisma.ServicesProductCustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          createMany: {
            args: Prisma.ServicesProductCustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesProductCustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>[]
          }
          delete: {
            args: Prisma.ServicesProductCustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          update: {
            args: Prisma.ServicesProductCustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          deleteMany: {
            args: Prisma.ServicesProductCustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesProductCustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesProductCustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>[]
          }
          upsert: {
            args: Prisma.ServicesProductCustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesProductCustomersPayload>
          }
          aggregate: {
            args: Prisma.ServicesProductCustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicesProductCustomers>
          }
          groupBy: {
            args: Prisma.ServicesProductCustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesProductCustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesProductCustomersCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesProductCustomersCountAggregateOutputType> | number
          }
        }
      }
      ServicesAddonsCustomers: {
        payload: Prisma.$ServicesAddonsCustomersPayload<ExtArgs>
        fields: Prisma.ServicesAddonsCustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicesAddonsCustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicesAddonsCustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          findFirst: {
            args: Prisma.ServicesAddonsCustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicesAddonsCustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          findMany: {
            args: Prisma.ServicesAddonsCustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>[]
          }
          create: {
            args: Prisma.ServicesAddonsCustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          createMany: {
            args: Prisma.ServicesAddonsCustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicesAddonsCustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>[]
          }
          delete: {
            args: Prisma.ServicesAddonsCustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          update: {
            args: Prisma.ServicesAddonsCustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          deleteMany: {
            args: Prisma.ServicesAddonsCustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicesAddonsCustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicesAddonsCustomersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>[]
          }
          upsert: {
            args: Prisma.ServicesAddonsCustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicesAddonsCustomersPayload>
          }
          aggregate: {
            args: Prisma.ServicesAddonsCustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicesAddonsCustomers>
          }
          groupBy: {
            args: Prisma.ServicesAddonsCustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicesAddonsCustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicesAddonsCustomersCountArgs<ExtArgs>
            result: $Utils.Optional<ServicesAddonsCustomersCountAggregateOutputType> | number
          }
        }
      }
      ServiceFee: {
        payload: Prisma.$ServiceFeePayload<ExtArgs>
        fields: Prisma.ServiceFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          findFirst: {
            args: Prisma.ServiceFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          findMany: {
            args: Prisma.ServiceFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>[]
          }
          create: {
            args: Prisma.ServiceFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          createMany: {
            args: Prisma.ServiceFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>[]
          }
          delete: {
            args: Prisma.ServiceFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          update: {
            args: Prisma.ServiceFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          deleteMany: {
            args: Prisma.ServiceFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceFeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>[]
          }
          upsert: {
            args: Prisma.ServiceFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceFeePayload>
          }
          aggregate: {
            args: Prisma.ServiceFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceFee>
          }
          groupBy: {
            args: Prisma.ServiceFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceFeeCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceFeeCountAggregateOutputType> | number
          }
        }
      }
      BankDetail: {
        payload: Prisma.$BankDetailPayload<ExtArgs>
        fields: Prisma.BankDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findFirst: {
            args: Prisma.BankDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          findMany: {
            args: Prisma.BankDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          create: {
            args: Prisma.BankDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          createMany: {
            args: Prisma.BankDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          delete: {
            args: Prisma.BankDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          update: {
            args: Prisma.BankDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          deleteMany: {
            args: Prisma.BankDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>[]
          }
          upsert: {
            args: Prisma.BankDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankDetailPayload>
          }
          aggregate: {
            args: Prisma.BankDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankDetail>
          }
          groupBy: {
            args: Prisma.BankDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankDetailCountArgs<ExtArgs>
            result: $Utils.Optional<BankDetailCountAggregateOutputType> | number
          }
        }
      }
      Server: {
        payload: Prisma.$ServerPayload<ExtArgs>
        fields: Prisma.ServerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findFirst: {
            args: Prisma.ServerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          findMany: {
            args: Prisma.ServerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          create: {
            args: Prisma.ServerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          createMany: {
            args: Prisma.ServerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          delete: {
            args: Prisma.ServerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          update: {
            args: Prisma.ServerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          deleteMany: {
            args: Prisma.ServerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>[]
          }
          upsert: {
            args: Prisma.ServerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServerPayload>
          }
          aggregate: {
            args: Prisma.ServerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServer>
          }
          groupBy: {
            args: Prisma.ServerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServerCountArgs<ExtArgs>
            result: $Utils.Optional<ServerCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppMessageStats: {
        payload: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>
        fields: Prisma.WhatsAppMessageStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppMessageStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppMessageStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          findMany: {
            args: Prisma.WhatsAppMessageStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          create: {
            args: Prisma.WhatsAppMessageStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          createMany: {
            args: Prisma.WhatsAppMessageStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppMessageStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          update: {
            args: Prisma.WhatsAppMessageStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppMessageStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppMessageStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppMessageStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppMessageStatsPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppMessageStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppMessageStats>
          }
          groupBy: {
            args: Prisma.WhatsAppMessageStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppMessageStatsCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppMessageStatsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    feature?: FeatureOmit
    subcategory?: SubcategoryOmit
    category?: CategoryOmit
    addon?: AddonOmit
    package?: PackageOmit
    whatsAppSession?: WhatsAppSessionOmit
    transaction?: TransactionOmit
    transactionProduct?: TransactionProductOmit
    transactionAddons?: TransactionAddonsOmit
    transactionWhatsappService?: TransactionWhatsappServiceOmit
    payment?: PaymentOmit
    whatsappApiPackage?: WhatsappApiPackageOmit
    servicesWhatsappCustomers?: ServicesWhatsappCustomersOmit
    userSession?: UserSessionOmit
    voucher?: VoucherOmit
    voucherUsage?: VoucherUsageOmit
    servicesProductCustomers?: ServicesProductCustomersOmit
    servicesAddonsCustomers?: ServicesAddonsCustomersOmit
    serviceFee?: ServiceFeeOmit
    bankDetail?: BankDetailOmit
    server?: ServerOmit
    whatsAppMessageStats?: WhatsAppMessageStatsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    transactions: number
    userSessions: number
    voucherUsage: number
    whatsAppSessions: number
    productCustomers: number
    addonCustomers: number
    whatsappCustomers: number
    whatsappMessageStats: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    userSessions?: boolean | UserCountOutputTypeCountUserSessionsArgs
    voucherUsage?: boolean | UserCountOutputTypeCountVoucherUsageArgs
    whatsAppSessions?: boolean | UserCountOutputTypeCountWhatsAppSessionsArgs
    productCustomers?: boolean | UserCountOutputTypeCountProductCustomersArgs
    addonCustomers?: boolean | UserCountOutputTypeCountAddonCustomersArgs
    whatsappCustomers?: boolean | UserCountOutputTypeCountWhatsappCustomersArgs
    whatsappMessageStats?: boolean | UserCountOutputTypeCountWhatsappMessageStatsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsAppSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesProductCustomersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddonCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesAddonsCustomersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhatsappMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
  }


  /**
   * Count Type SubcategoryCountOutputType
   */

  export type SubcategoryCountOutputType = {
    packages: number
  }

  export type SubcategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packages?: boolean | SubcategoryCountOutputTypeCountPackagesArgs
  }

  // Custom InputTypes
  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubcategoryCountOutputType
     */
    select?: SubcategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubcategoryCountOutputType without action
   */
  export type SubcategoryCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    addons: number
    packages: number
    subcategories: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addons?: boolean | CategoryCountOutputTypeCountAddonsArgs
    packages?: boolean | CategoryCountOutputTypeCountPackagesArgs
    subcategories?: boolean | CategoryCountOutputTypeCountSubcategoriesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountAddonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPackagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountSubcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
  }


  /**
   * Count Type AddonCountOutputType
   */

  export type AddonCountOutputType = {
    addonTransactions: number
  }

  export type AddonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addonTransactions?: boolean | AddonCountOutputTypeCountAddonTransactionsArgs
  }

  // Custom InputTypes
  /**
   * AddonCountOutputType without action
   */
  export type AddonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddonCountOutputType
     */
    select?: AddonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddonCountOutputType without action
   */
  export type AddonCountOutputTypeCountAddonTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionAddonsWhereInput
  }


  /**
   * Count Type PackageCountOutputType
   */

  export type PackageCountOutputType = {
    features: number
    productTransactions: number
    productCustomers: number
  }

  export type PackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | PackageCountOutputTypeCountFeaturesArgs
    productTransactions?: boolean | PackageCountOutputTypeCountProductTransactionsArgs
    productCustomers?: boolean | PackageCountOutputTypeCountProductCustomersArgs
  }

  // Custom InputTypes
  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackageCountOutputType
     */
    select?: PackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountProductTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionProductWhereInput
  }

  /**
   * PackageCountOutputType without action
   */
  export type PackageCountOutputTypeCountProductCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesProductCustomersWhereInput
  }


  /**
   * Count Type WhatsAppSessionCountOutputType
   */

  export type WhatsAppSessionCountOutputType = {
    whatsappMessageStats: number
  }

  export type WhatsAppSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappMessageStats?: boolean | WhatsAppSessionCountOutputTypeCountWhatsappMessageStatsArgs
  }

  // Custom InputTypes
  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSessionCountOutputType
     */
    select?: WhatsAppSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsAppSessionCountOutputType without action
   */
  export type WhatsAppSessionCountOutputTypeCountWhatsappMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
  }


  /**
   * Count Type TransactionCountOutputType
   */

  export type TransactionCountOutputType = {
    productTransactions: number
    addonTransactions: number
    productCustomers: number
    addonCustomers: number
    whatsappCustomers: number
    voucherUsage: number
  }

  export type TransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productTransactions?: boolean | TransactionCountOutputTypeCountProductTransactionsArgs
    addonTransactions?: boolean | TransactionCountOutputTypeCountAddonTransactionsArgs
    productCustomers?: boolean | TransactionCountOutputTypeCountProductCustomersArgs
    addonCustomers?: boolean | TransactionCountOutputTypeCountAddonCustomersArgs
    whatsappCustomers?: boolean | TransactionCountOutputTypeCountWhatsappCustomersArgs
    voucherUsage?: boolean | TransactionCountOutputTypeCountVoucherUsageArgs
  }

  // Custom InputTypes
  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCountOutputType
     */
    select?: TransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountProductTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionProductWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountAddonTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionAddonsWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountProductCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesProductCustomersWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountAddonCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesAddonsCustomersWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountWhatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
  }

  /**
   * TransactionCountOutputType without action
   */
  export type TransactionCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }


  /**
   * Count Type WhatsappApiPackageCountOutputType
   */

  export type WhatsappApiPackageCountOutputType = {
    whatsappTransactions: number
    whatsappCustomers: number
  }

  export type WhatsappApiPackageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappTransactions?: boolean | WhatsappApiPackageCountOutputTypeCountWhatsappTransactionsArgs
    whatsappCustomers?: boolean | WhatsappApiPackageCountOutputTypeCountWhatsappCustomersArgs
  }

  // Custom InputTypes
  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackageCountOutputType
     */
    select?: WhatsappApiPackageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeCountWhatsappTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhatsappServiceWhereInput
  }

  /**
   * WhatsappApiPackageCountOutputType without action
   */
  export type WhatsappApiPackageCountOutputTypeCountWhatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
  }


  /**
   * Count Type VoucherCountOutputType
   */

  export type VoucherCountOutputType = {
    transactions: number
    voucherUsage: number
  }

  export type VoucherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | VoucherCountOutputTypeCountTransactionsArgs
    voucherUsage?: boolean | VoucherCountOutputTypeCountVoucherUsageArgs
  }

  // Custom InputTypes
  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherCountOutputType
     */
    select?: VoucherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * VoucherCountOutputType without action
   */
  export type VoucherCountOutputTypeCountVoucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string | null
    apiKey: string | null
    updatedAt: Date | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string | null
    apiKey: string | null
    updatedAt: Date | null
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    otp: number
    otpExpires: number
    otpVerificationDeadline: number
    emailVerified: number
    phoneVerified: number
    image: number
    emailVerificationToken: number
    emailVerificationTokenExpires: number
    role: number
    apiKey: number
    updatedAt: number
    emailOtp: number
    emailOtpExpires: number
    resetPasswordOtp: number
    resetPasswordOtpExpires: number
    resetPasswordLastRequestAt: number
    ssoOtp: number
    ssoOtpExpires: number
    ssoLastRequestAt: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    otp?: true
    otpExpires?: true
    otpVerificationDeadline?: true
    emailVerified?: true
    phoneVerified?: true
    image?: true
    emailVerificationToken?: true
    emailVerificationTokenExpires?: true
    role?: true
    apiKey?: true
    updatedAt?: true
    emailOtp?: true
    emailOtpExpires?: true
    resetPasswordOtp?: true
    resetPasswordOtpExpires?: true
    resetPasswordLastRequestAt?: true
    ssoOtp?: true
    ssoOtpExpires?: true
    ssoLastRequestAt?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    otp: string | null
    otpExpires: Date | null
    otpVerificationDeadline: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    image: string | null
    emailVerificationToken: string | null
    emailVerificationTokenExpires: Date | null
    role: string
    apiKey: string | null
    updatedAt: Date
    emailOtp: string | null
    emailOtpExpires: Date | null
    resetPasswordOtp: string | null
    resetPasswordOtpExpires: Date | null
    resetPasswordLastRequestAt: Date | null
    ssoOtp: string | null
    ssoOtpExpires: Date | null
    ssoLastRequestAt: Date | null
    isActive: boolean
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    voucherUsage?: boolean | User$voucherUsageArgs<ExtArgs>
    whatsAppSessions?: boolean | User$whatsAppSessionsArgs<ExtArgs>
    productCustomers?: boolean | User$productCustomersArgs<ExtArgs>
    addonCustomers?: boolean | User$addonCustomersArgs<ExtArgs>
    whatsappCustomers?: boolean | User$whatsappCustomersArgs<ExtArgs>
    whatsappMessageStats?: boolean | User$whatsappMessageStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    otp?: boolean
    otpExpires?: boolean
    otpVerificationDeadline?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    image?: boolean
    emailVerificationToken?: boolean
    emailVerificationTokenExpires?: boolean
    role?: boolean
    apiKey?: boolean
    updatedAt?: boolean
    emailOtp?: boolean
    emailOtpExpires?: boolean
    resetPasswordOtp?: boolean
    resetPasswordOtpExpires?: boolean
    resetPasswordLastRequestAt?: boolean
    ssoOtp?: boolean
    ssoOtpExpires?: boolean
    ssoLastRequestAt?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "otp" | "otpExpires" | "otpVerificationDeadline" | "emailVerified" | "phoneVerified" | "image" | "emailVerificationToken" | "emailVerificationTokenExpires" | "role" | "apiKey" | "updatedAt" | "emailOtp" | "emailOtpExpires" | "resetPasswordOtp" | "resetPasswordOtpExpires" | "resetPasswordLastRequestAt" | "ssoOtp" | "ssoOtpExpires" | "ssoLastRequestAt" | "isActive" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    voucherUsage?: boolean | User$voucherUsageArgs<ExtArgs>
    whatsAppSessions?: boolean | User$whatsAppSessionsArgs<ExtArgs>
    productCustomers?: boolean | User$productCustomersArgs<ExtArgs>
    addonCustomers?: boolean | User$addonCustomersArgs<ExtArgs>
    whatsappCustomers?: boolean | User$whatsappCustomersArgs<ExtArgs>
    whatsappMessageStats?: boolean | User$whatsappMessageStatsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
      whatsAppSessions: Prisma.$WhatsAppSessionPayload<ExtArgs>[]
      productCustomers: Prisma.$ServicesProductCustomersPayload<ExtArgs>[]
      addonCustomers: Prisma.$ServicesAddonsCustomersPayload<ExtArgs>[]
      whatsappCustomers: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>[]
      whatsappMessageStats: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      phone: string | null
      password: string | null
      otp: string | null
      otpExpires: Date | null
      otpVerificationDeadline: Date | null
      emailVerified: Date | null
      phoneVerified: Date | null
      image: string | null
      emailVerificationToken: string | null
      emailVerificationTokenExpires: Date | null
      role: string
      apiKey: string | null
      updatedAt: Date
      emailOtp: string | null
      emailOtpExpires: Date | null
      resetPasswordOtp: string | null
      resetPasswordOtpExpires: Date | null
      resetPasswordLastRequestAt: Date | null
      ssoOtp: string | null
      ssoOtpExpires: Date | null
      ssoLastRequestAt: Date | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSessions<T extends User$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsage<T extends User$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, User$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsAppSessions<T extends User$whatsAppSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsAppSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCustomers<T extends User$productCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$productCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addonCustomers<T extends User$addonCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$addonCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappCustomers<T extends User$whatsappCustomersArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappMessageStats<T extends User$whatsappMessageStatsArgs<ExtArgs> = {}>(args?: Subset<T, User$whatsappMessageStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly otp: FieldRef<"User", 'String'>
    readonly otpExpires: FieldRef<"User", 'DateTime'>
    readonly otpVerificationDeadline: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phoneVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly emailVerificationTokenExpires: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly apiKey: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly emailOtp: FieldRef<"User", 'String'>
    readonly emailOtpExpires: FieldRef<"User", 'DateTime'>
    readonly resetPasswordOtp: FieldRef<"User", 'String'>
    readonly resetPasswordOtpExpires: FieldRef<"User", 'DateTime'>
    readonly resetPasswordLastRequestAt: FieldRef<"User", 'DateTime'>
    readonly ssoOtp: FieldRef<"User", 'String'>
    readonly ssoOtpExpires: FieldRef<"User", 'DateTime'>
    readonly ssoLastRequestAt: FieldRef<"User", 'DateTime'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.userSessions
   */
  export type User$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.voucherUsage
   */
  export type User$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * User.whatsAppSessions
   */
  export type User$whatsAppSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    cursor?: WhatsAppSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * User.productCustomers
   */
  export type User$productCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    where?: ServicesProductCustomersWhereInput
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    cursor?: ServicesProductCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * User.addonCustomers
   */
  export type User$addonCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    where?: ServicesAddonsCustomersWhereInput
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesAddonsCustomersScalarFieldEnum | ServicesAddonsCustomersScalarFieldEnum[]
  }

  /**
   * User.whatsappCustomers
   */
  export type User$whatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * User.whatsappMessageStats
   */
  export type User$whatsappMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureMinAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    included: boolean | null
    packageId: string | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    included: boolean | null
    packageId: string | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    name_en: number
    name_id: number
    included: number
    packageId: number
    _all: number
  }


  export type FeatureMinAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    included?: true
    packageId?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    included?: true
    packageId?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    included?: true
    packageId?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: string
    name_en: string
    name_id: string
    included: boolean
    packageId: string
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    included?: boolean
    packageId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    included?: boolean
    packageId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    included?: boolean
    packageId?: boolean
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    included?: boolean
    packageId?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_id" | "included" | "packageId", ExtArgs["result"]["feature"]>
  export type FeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | PackageDefaultArgs<ExtArgs>
  }

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {
      package: Prisma.$PackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name_en: string
      name_id: string
      included: boolean
      packageId: string
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends PackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackageDefaultArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'String'>
    readonly name_en: FieldRef<"Feature", 'String'>
    readonly name_id: FieldRef<"Feature", 'String'>
    readonly included: FieldRef<"Feature", 'Boolean'>
    readonly packageId: FieldRef<"Feature", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
  }


  /**
   * Model Subcategory
   */

  export type AggregateSubcategory = {
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  export type SubcategoryMinAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    categoryId: string | null
  }

  export type SubcategoryMaxAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    categoryId: string | null
  }

  export type SubcategoryCountAggregateOutputType = {
    id: number
    name_en: number
    name_id: number
    categoryId: number
    _all: number
  }


  export type SubcategoryMinAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    categoryId?: true
  }

  export type SubcategoryMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    categoryId?: true
  }

  export type SubcategoryCountAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    categoryId?: true
    _all?: true
  }

  export type SubcategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategory to aggregate.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subcategories
    **/
    _count?: true | SubcategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubcategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubcategoryMaxAggregateInputType
  }

  export type GetSubcategoryAggregateType<T extends SubcategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSubcategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubcategory[P]>
      : GetScalarType<T[P], AggregateSubcategory[P]>
  }




  export type SubcategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithAggregationInput | SubcategoryOrderByWithAggregationInput[]
    by: SubcategoryScalarFieldEnum[] | SubcategoryScalarFieldEnum
    having?: SubcategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubcategoryCountAggregateInputType | true
    _min?: SubcategoryMinAggregateInputType
    _max?: SubcategoryMaxAggregateInputType
  }

  export type SubcategoryGroupByOutputType = {
    id: string
    name_en: string
    name_id: string
    categoryId: string
    _count: SubcategoryCountAggregateOutputType | null
    _min: SubcategoryMinAggregateOutputType | null
    _max: SubcategoryMaxAggregateOutputType | null
  }

  type GetSubcategoryGroupByPayload<T extends SubcategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubcategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubcategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
            : GetScalarType<T[P], SubcategoryGroupByOutputType[P]>
        }
      >
    >


  export type SubcategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    categoryId?: boolean
    packages?: boolean | Subcategory$packagesArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subcategory"]>

  export type SubcategorySelectScalar = {
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    categoryId?: boolean
  }

  export type SubcategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_id" | "categoryId", ExtArgs["result"]["subcategory"]>
  export type SubcategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    packages?: boolean | Subcategory$packagesArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    _count?: boolean | SubcategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type SubcategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $SubcategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subcategory"
    objects: {
      packages: Prisma.$PackagePayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name_en: string
      name_id: string
      categoryId: string
    }, ExtArgs["result"]["subcategory"]>
    composites: {}
  }

  type SubcategoryGetPayload<S extends boolean | null | undefined | SubcategoryDefaultArgs> = $Result.GetResult<Prisma.$SubcategoryPayload, S>

  type SubcategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubcategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubcategoryCountAggregateInputType | true
    }

  export interface SubcategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subcategory'], meta: { name: 'Subcategory' } }
    /**
     * Find zero or one Subcategory that matches the filter.
     * @param {SubcategoryFindUniqueArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubcategoryFindUniqueArgs>(args: SelectSubset<T, SubcategoryFindUniqueArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subcategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubcategoryFindUniqueOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubcategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SubcategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubcategoryFindFirstArgs>(args?: SelectSubset<T, SubcategoryFindFirstArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subcategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindFirstOrThrowArgs} args - Arguments to find a Subcategory
     * @example
     * // Get one Subcategory
     * const subcategory = await prisma.subcategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubcategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SubcategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subcategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subcategories
     * const subcategories = await prisma.subcategory.findMany()
     * 
     * // Get first 10 Subcategories
     * const subcategories = await prisma.subcategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubcategoryFindManyArgs>(args?: SelectSubset<T, SubcategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subcategory.
     * @param {SubcategoryCreateArgs} args - Arguments to create a Subcategory.
     * @example
     * // Create one Subcategory
     * const Subcategory = await prisma.subcategory.create({
     *   data: {
     *     // ... data to create a Subcategory
     *   }
     * })
     * 
     */
    create<T extends SubcategoryCreateArgs>(args: SelectSubset<T, SubcategoryCreateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subcategories.
     * @param {SubcategoryCreateManyArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubcategoryCreateManyArgs>(args?: SelectSubset<T, SubcategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subcategories and returns the data saved in the database.
     * @param {SubcategoryCreateManyAndReturnArgs} args - Arguments to create many Subcategories.
     * @example
     * // Create many Subcategories
     * const subcategory = await prisma.subcategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubcategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SubcategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subcategory.
     * @param {SubcategoryDeleteArgs} args - Arguments to delete one Subcategory.
     * @example
     * // Delete one Subcategory
     * const Subcategory = await prisma.subcategory.delete({
     *   where: {
     *     // ... filter to delete one Subcategory
     *   }
     * })
     * 
     */
    delete<T extends SubcategoryDeleteArgs>(args: SelectSubset<T, SubcategoryDeleteArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subcategory.
     * @param {SubcategoryUpdateArgs} args - Arguments to update one Subcategory.
     * @example
     * // Update one Subcategory
     * const subcategory = await prisma.subcategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubcategoryUpdateArgs>(args: SelectSubset<T, SubcategoryUpdateArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subcategories.
     * @param {SubcategoryDeleteManyArgs} args - Arguments to filter Subcategories to delete.
     * @example
     * // Delete a few Subcategories
     * const { count } = await prisma.subcategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubcategoryDeleteManyArgs>(args?: SelectSubset<T, SubcategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubcategoryUpdateManyArgs>(args: SelectSubset<T, SubcategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subcategories and returns the data updated in the database.
     * @param {SubcategoryUpdateManyAndReturnArgs} args - Arguments to update many Subcategories.
     * @example
     * // Update many Subcategories
     * const subcategory = await prisma.subcategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subcategories and only return the `id`
     * const subcategoryWithIdOnly = await prisma.subcategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubcategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SubcategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subcategory.
     * @param {SubcategoryUpsertArgs} args - Arguments to update or create a Subcategory.
     * @example
     * // Update or create a Subcategory
     * const subcategory = await prisma.subcategory.upsert({
     *   create: {
     *     // ... data to create a Subcategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subcategory we want to update
     *   }
     * })
     */
    upsert<T extends SubcategoryUpsertArgs>(args: SelectSubset<T, SubcategoryUpsertArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subcategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryCountArgs} args - Arguments to filter Subcategories to count.
     * @example
     * // Count the number of Subcategories
     * const count = await prisma.subcategory.count({
     *   where: {
     *     // ... the filter for the Subcategories we want to count
     *   }
     * })
    **/
    count<T extends SubcategoryCountArgs>(
      args?: Subset<T, SubcategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubcategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubcategoryAggregateArgs>(args: Subset<T, SubcategoryAggregateArgs>): Prisma.PrismaPromise<GetSubcategoryAggregateType<T>>

    /**
     * Group by Subcategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubcategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubcategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubcategoryGroupByArgs['orderBy'] }
        : { orderBy?: SubcategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubcategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubcategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subcategory model
   */
  readonly fields: SubcategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subcategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubcategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    packages<T extends Subcategory$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Subcategory$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subcategory model
   */
  interface SubcategoryFieldRefs {
    readonly id: FieldRef<"Subcategory", 'String'>
    readonly name_en: FieldRef<"Subcategory", 'String'>
    readonly name_id: FieldRef<"Subcategory", 'String'>
    readonly categoryId: FieldRef<"Subcategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subcategory findUnique
   */
  export type SubcategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findUniqueOrThrow
   */
  export type SubcategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory findFirst
   */
  export type SubcategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findFirstOrThrow
   */
  export type SubcategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategory to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subcategories.
     */
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory findMany
   */
  export type SubcategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter, which Subcategories to fetch.
     */
    where?: SubcategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subcategories to fetch.
     */
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subcategories.
     */
    cursor?: SubcategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subcategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subcategories.
     */
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Subcategory create
   */
  export type SubcategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Subcategory.
     */
    data: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
  }

  /**
   * Subcategory createMany
   */
  export type SubcategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subcategory createManyAndReturn
   */
  export type SubcategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Subcategories.
     */
    data: SubcategoryCreateManyInput | SubcategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory update
   */
  export type SubcategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Subcategory.
     */
    data: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
    /**
     * Choose, which Subcategory to update.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory updateMany
   */
  export type SubcategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
  }

  /**
   * Subcategory updateManyAndReturn
   */
  export type SubcategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * The data used to update Subcategories.
     */
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyInput>
    /**
     * Filter which Subcategories to update
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subcategory upsert
   */
  export type SubcategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Subcategory to update in case it exists.
     */
    where: SubcategoryWhereUniqueInput
    /**
     * In case the Subcategory found by the `where` argument doesn't exist, create a new Subcategory with this data.
     */
    create: XOR<SubcategoryCreateInput, SubcategoryUncheckedCreateInput>
    /**
     * In case the Subcategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubcategoryUpdateInput, SubcategoryUncheckedUpdateInput>
  }

  /**
   * Subcategory delete
   */
  export type SubcategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    /**
     * Filter which Subcategory to delete.
     */
    where: SubcategoryWhereUniqueInput
  }

  /**
   * Subcategory deleteMany
   */
  export type SubcategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subcategories to delete
     */
    where?: SubcategoryWhereInput
    /**
     * Limit how many Subcategories to delete.
     */
    limit?: number
  }

  /**
   * Subcategory.packages
   */
  export type Subcategory$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    cursor?: PackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Subcategory without action
   */
  export type SubcategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    icon: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    icon: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name_en: number
    name_id: number
    icon: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    icon?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    icon?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    icon?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name_en: string
    name_id: string
    icon: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    icon?: boolean
    addons?: boolean | Category$addonsArgs<ExtArgs>
    packages?: boolean | Category$packagesArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    icon?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    icon?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    icon?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_id" | "icon", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addons?: boolean | Category$addonsArgs<ExtArgs>
    packages?: boolean | Category$packagesArgs<ExtArgs>
    subcategories?: boolean | Category$subcategoriesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      addons: Prisma.$AddonPayload<ExtArgs>[]
      packages: Prisma.$PackagePayload<ExtArgs>[]
      subcategories: Prisma.$SubcategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name_en: string
      name_id: string
      icon: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addons<T extends Category$addonsArgs<ExtArgs> = {}>(args?: Subset<T, Category$addonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    packages<T extends Category$packagesArgs<ExtArgs> = {}>(args?: Subset<T, Category$packagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subcategories<T extends Category$subcategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Category$subcategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name_en: FieldRef<"Category", 'String'>
    readonly name_id: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.addons
   */
  export type Category$addonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    where?: AddonWhereInput
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    cursor?: AddonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Category.packages
   */
  export type Category$packagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    cursor?: PackageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Category.subcategories
   */
  export type Category$subcategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subcategory
     */
    select?: SubcategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subcategory
     */
    omit?: SubcategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubcategoryInclude<ExtArgs> | null
    where?: SubcategoryWhereInput
    orderBy?: SubcategoryOrderByWithRelationInput | SubcategoryOrderByWithRelationInput[]
    cursor?: SubcategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubcategoryScalarFieldEnum | SubcategoryScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Addon
   */

  export type AggregateAddon = {
    _count: AddonCountAggregateOutputType | null
    _avg: AddonAvgAggregateOutputType | null
    _sum: AddonSumAggregateOutputType | null
    _min: AddonMinAggregateOutputType | null
    _max: AddonMaxAggregateOutputType | null
  }

  export type AddonAvgAggregateOutputType = {
    price_idr: Decimal | null
    price_usd: Decimal | null
  }

  export type AddonSumAggregateOutputType = {
    price_idr: Decimal | null
    price_usd: Decimal | null
  }

  export type AddonMinAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    description_en: string | null
    description_id: string | null
    price_idr: Decimal | null
    price_usd: Decimal | null
    image: string | null
    categoryId: string | null
  }

  export type AddonMaxAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    description_en: string | null
    description_id: string | null
    price_idr: Decimal | null
    price_usd: Decimal | null
    image: string | null
    categoryId: string | null
  }

  export type AddonCountAggregateOutputType = {
    id: number
    name_en: number
    name_id: number
    description_en: number
    description_id: number
    price_idr: number
    price_usd: number
    image: number
    categoryId: number
    _all: number
  }


  export type AddonAvgAggregateInputType = {
    price_idr?: true
    price_usd?: true
  }

  export type AddonSumAggregateInputType = {
    price_idr?: true
    price_usd?: true
  }

  export type AddonMinAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
  }

  export type AddonMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
  }

  export type AddonCountAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
    _all?: true
  }

  export type AddonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addon to aggregate.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addons
    **/
    _count?: true | AddonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddonMaxAggregateInputType
  }

  export type GetAddonAggregateType<T extends AddonAggregateArgs> = {
        [P in keyof T & keyof AggregateAddon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddon[P]>
      : GetScalarType<T[P], AggregateAddon[P]>
  }




  export type AddonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddonWhereInput
    orderBy?: AddonOrderByWithAggregationInput | AddonOrderByWithAggregationInput[]
    by: AddonScalarFieldEnum[] | AddonScalarFieldEnum
    having?: AddonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddonCountAggregateInputType | true
    _avg?: AddonAvgAggregateInputType
    _sum?: AddonSumAggregateInputType
    _min?: AddonMinAggregateInputType
    _max?: AddonMaxAggregateInputType
  }

  export type AddonGroupByOutputType = {
    id: string
    name_en: string
    name_id: string
    description_en: string | null
    description_id: string | null
    price_idr: Decimal
    price_usd: Decimal
    image: string | null
    categoryId: string
    _count: AddonCountAggregateOutputType | null
    _avg: AddonAvgAggregateOutputType | null
    _sum: AddonSumAggregateOutputType | null
    _min: AddonMinAggregateOutputType | null
    _max: AddonMaxAggregateOutputType | null
  }

  type GetAddonGroupByPayload<T extends AddonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddonGroupByOutputType[P]>
            : GetScalarType<T[P], AddonGroupByOutputType[P]>
        }
      >
    >


  export type AddonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    addonTransactions?: boolean | Addon$addonTransactionsArgs<ExtArgs>
    _count?: boolean | AddonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["addon"]>

  export type AddonSelectScalar = {
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
  }

  export type AddonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_id" | "description_en" | "description_id" | "price_idr" | "price_usd" | "image" | "categoryId", ExtArgs["result"]["addon"]>
  export type AddonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    addonTransactions?: boolean | Addon$addonTransactionsArgs<ExtArgs>
    _count?: boolean | AddonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }
  export type AddonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $AddonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Addon"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      addonTransactions: Prisma.$TransactionAddonsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name_en: string
      name_id: string
      description_en: string | null
      description_id: string | null
      price_idr: Prisma.Decimal
      price_usd: Prisma.Decimal
      image: string | null
      categoryId: string
    }, ExtArgs["result"]["addon"]>
    composites: {}
  }

  type AddonGetPayload<S extends boolean | null | undefined | AddonDefaultArgs> = $Result.GetResult<Prisma.$AddonPayload, S>

  type AddonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddonCountAggregateInputType | true
    }

  export interface AddonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Addon'], meta: { name: 'Addon' } }
    /**
     * Find zero or one Addon that matches the filter.
     * @param {AddonFindUniqueArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddonFindUniqueArgs>(args: SelectSubset<T, AddonFindUniqueArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Addon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddonFindUniqueOrThrowArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddonFindUniqueOrThrowArgs>(args: SelectSubset<T, AddonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindFirstArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddonFindFirstArgs>(args?: SelectSubset<T, AddonFindFirstArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Addon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindFirstOrThrowArgs} args - Arguments to find a Addon
     * @example
     * // Get one Addon
     * const addon = await prisma.addon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddonFindFirstOrThrowArgs>(args?: SelectSubset<T, AddonFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addons
     * const addons = await prisma.addon.findMany()
     * 
     * // Get first 10 Addons
     * const addons = await prisma.addon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addonWithIdOnly = await prisma.addon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddonFindManyArgs>(args?: SelectSubset<T, AddonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Addon.
     * @param {AddonCreateArgs} args - Arguments to create a Addon.
     * @example
     * // Create one Addon
     * const Addon = await prisma.addon.create({
     *   data: {
     *     // ... data to create a Addon
     *   }
     * })
     * 
     */
    create<T extends AddonCreateArgs>(args: SelectSubset<T, AddonCreateArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addons.
     * @param {AddonCreateManyArgs} args - Arguments to create many Addons.
     * @example
     * // Create many Addons
     * const addon = await prisma.addon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddonCreateManyArgs>(args?: SelectSubset<T, AddonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addons and returns the data saved in the database.
     * @param {AddonCreateManyAndReturnArgs} args - Arguments to create many Addons.
     * @example
     * // Create many Addons
     * const addon = await prisma.addon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addons and only return the `id`
     * const addonWithIdOnly = await prisma.addon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddonCreateManyAndReturnArgs>(args?: SelectSubset<T, AddonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Addon.
     * @param {AddonDeleteArgs} args - Arguments to delete one Addon.
     * @example
     * // Delete one Addon
     * const Addon = await prisma.addon.delete({
     *   where: {
     *     // ... filter to delete one Addon
     *   }
     * })
     * 
     */
    delete<T extends AddonDeleteArgs>(args: SelectSubset<T, AddonDeleteArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Addon.
     * @param {AddonUpdateArgs} args - Arguments to update one Addon.
     * @example
     * // Update one Addon
     * const addon = await prisma.addon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddonUpdateArgs>(args: SelectSubset<T, AddonUpdateArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addons.
     * @param {AddonDeleteManyArgs} args - Arguments to filter Addons to delete.
     * @example
     * // Delete a few Addons
     * const { count } = await prisma.addon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddonDeleteManyArgs>(args?: SelectSubset<T, AddonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addons
     * const addon = await prisma.addon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddonUpdateManyArgs>(args: SelectSubset<T, AddonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addons and returns the data updated in the database.
     * @param {AddonUpdateManyAndReturnArgs} args - Arguments to update many Addons.
     * @example
     * // Update many Addons
     * const addon = await prisma.addon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addons and only return the `id`
     * const addonWithIdOnly = await prisma.addon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddonUpdateManyAndReturnArgs>(args: SelectSubset<T, AddonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Addon.
     * @param {AddonUpsertArgs} args - Arguments to update or create a Addon.
     * @example
     * // Update or create a Addon
     * const addon = await prisma.addon.upsert({
     *   create: {
     *     // ... data to create a Addon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Addon we want to update
     *   }
     * })
     */
    upsert<T extends AddonUpsertArgs>(args: SelectSubset<T, AddonUpsertArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonCountArgs} args - Arguments to filter Addons to count.
     * @example
     * // Count the number of Addons
     * const count = await prisma.addon.count({
     *   where: {
     *     // ... the filter for the Addons we want to count
     *   }
     * })
    **/
    count<T extends AddonCountArgs>(
      args?: Subset<T, AddonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Addon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddonAggregateArgs>(args: Subset<T, AddonAggregateArgs>): Prisma.PrismaPromise<GetAddonAggregateType<T>>

    /**
     * Group by Addon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddonGroupByArgs['orderBy'] }
        : { orderBy?: AddonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Addon model
   */
  readonly fields: AddonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Addon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addonTransactions<T extends Addon$addonTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Addon$addonTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Addon model
   */
  interface AddonFieldRefs {
    readonly id: FieldRef<"Addon", 'String'>
    readonly name_en: FieldRef<"Addon", 'String'>
    readonly name_id: FieldRef<"Addon", 'String'>
    readonly description_en: FieldRef<"Addon", 'String'>
    readonly description_id: FieldRef<"Addon", 'String'>
    readonly price_idr: FieldRef<"Addon", 'Decimal'>
    readonly price_usd: FieldRef<"Addon", 'Decimal'>
    readonly image: FieldRef<"Addon", 'String'>
    readonly categoryId: FieldRef<"Addon", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Addon findUnique
   */
  export type AddonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon findUniqueOrThrow
   */
  export type AddonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon findFirst
   */
  export type AddonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addons.
     */
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon findFirstOrThrow
   */
  export type AddonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addon to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addons.
     */
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon findMany
   */
  export type AddonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter, which Addons to fetch.
     */
    where?: AddonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addons to fetch.
     */
    orderBy?: AddonOrderByWithRelationInput | AddonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addons.
     */
    cursor?: AddonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addons.
     */
    skip?: number
    distinct?: AddonScalarFieldEnum | AddonScalarFieldEnum[]
  }

  /**
   * Addon create
   */
  export type AddonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The data needed to create a Addon.
     */
    data: XOR<AddonCreateInput, AddonUncheckedCreateInput>
  }

  /**
   * Addon createMany
   */
  export type AddonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addons.
     */
    data: AddonCreateManyInput | AddonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Addon createManyAndReturn
   */
  export type AddonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * The data used to create many Addons.
     */
    data: AddonCreateManyInput | AddonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Addon update
   */
  export type AddonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The data needed to update a Addon.
     */
    data: XOR<AddonUpdateInput, AddonUncheckedUpdateInput>
    /**
     * Choose, which Addon to update.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon updateMany
   */
  export type AddonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addons.
     */
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyInput>
    /**
     * Filter which Addons to update
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to update.
     */
    limit?: number
  }

  /**
   * Addon updateManyAndReturn
   */
  export type AddonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * The data used to update Addons.
     */
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyInput>
    /**
     * Filter which Addons to update
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Addon upsert
   */
  export type AddonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * The filter to search for the Addon to update in case it exists.
     */
    where: AddonWhereUniqueInput
    /**
     * In case the Addon found by the `where` argument doesn't exist, create a new Addon with this data.
     */
    create: XOR<AddonCreateInput, AddonUncheckedCreateInput>
    /**
     * In case the Addon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddonUpdateInput, AddonUncheckedUpdateInput>
  }

  /**
   * Addon delete
   */
  export type AddonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
    /**
     * Filter which Addon to delete.
     */
    where: AddonWhereUniqueInput
  }

  /**
   * Addon deleteMany
   */
  export type AddonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addons to delete
     */
    where?: AddonWhereInput
    /**
     * Limit how many Addons to delete.
     */
    limit?: number
  }

  /**
   * Addon.addonTransactions
   */
  export type Addon$addonTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    where?: TransactionAddonsWhereInput
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    cursor?: TransactionAddonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionAddonsScalarFieldEnum | TransactionAddonsScalarFieldEnum[]
  }

  /**
   * Addon without action
   */
  export type AddonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Addon
     */
    select?: AddonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Addon
     */
    omit?: AddonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddonInclude<ExtArgs> | null
  }


  /**
   * Model Package
   */

  export type AggregatePackage = {
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  export type PackageAvgAggregateOutputType = {
    price_idr: Decimal | null
    price_usd: Decimal | null
  }

  export type PackageSumAggregateOutputType = {
    price_idr: Decimal | null
    price_usd: Decimal | null
  }

  export type PackageMinAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    description_en: string | null
    description_id: string | null
    price_idr: Decimal | null
    price_usd: Decimal | null
    image: string | null
    categoryId: string | null
    subcategoryId: string | null
    popular: boolean | null
  }

  export type PackageMaxAggregateOutputType = {
    id: string | null
    name_en: string | null
    name_id: string | null
    description_en: string | null
    description_id: string | null
    price_idr: Decimal | null
    price_usd: Decimal | null
    image: string | null
    categoryId: string | null
    subcategoryId: string | null
    popular: boolean | null
  }

  export type PackageCountAggregateOutputType = {
    id: number
    name_en: number
    name_id: number
    description_en: number
    description_id: number
    price_idr: number
    price_usd: number
    image: number
    categoryId: number
    subcategoryId: number
    popular: number
    _all: number
  }


  export type PackageAvgAggregateInputType = {
    price_idr?: true
    price_usd?: true
  }

  export type PackageSumAggregateInputType = {
    price_idr?: true
    price_usd?: true
  }

  export type PackageMinAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
    subcategoryId?: true
    popular?: true
  }

  export type PackageMaxAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
    subcategoryId?: true
    popular?: true
  }

  export type PackageCountAggregateInputType = {
    id?: true
    name_en?: true
    name_id?: true
    description_en?: true
    description_id?: true
    price_idr?: true
    price_usd?: true
    image?: true
    categoryId?: true
    subcategoryId?: true
    popular?: true
    _all?: true
  }

  export type PackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Package to aggregate.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packages
    **/
    _count?: true | PackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackageMaxAggregateInputType
  }

  export type GetPackageAggregateType<T extends PackageAggregateArgs> = {
        [P in keyof T & keyof AggregatePackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackage[P]>
      : GetScalarType<T[P], AggregatePackage[P]>
  }




  export type PackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackageWhereInput
    orderBy?: PackageOrderByWithAggregationInput | PackageOrderByWithAggregationInput[]
    by: PackageScalarFieldEnum[] | PackageScalarFieldEnum
    having?: PackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackageCountAggregateInputType | true
    _avg?: PackageAvgAggregateInputType
    _sum?: PackageSumAggregateInputType
    _min?: PackageMinAggregateInputType
    _max?: PackageMaxAggregateInputType
  }

  export type PackageGroupByOutputType = {
    id: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal
    price_usd: Decimal
    image: string
    categoryId: string
    subcategoryId: string
    popular: boolean | null
    _count: PackageCountAggregateOutputType | null
    _avg: PackageAvgAggregateOutputType | null
    _sum: PackageSumAggregateOutputType | null
    _min: PackageMinAggregateOutputType | null
    _max: PackageMaxAggregateOutputType | null
  }

  type GetPackageGroupByPayload<T extends PackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackageGroupByOutputType[P]>
            : GetScalarType<T[P], PackageGroupByOutputType[P]>
        }
      >
    >


  export type PackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    popular?: boolean
    features?: boolean | Package$featuresArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
    productTransactions?: boolean | Package$productTransactionsArgs<ExtArgs>
    productCustomers?: boolean | Package$productCustomersArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    popular?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    popular?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["package"]>

  export type PackageSelectScalar = {
    id?: boolean
    name_en?: boolean
    name_id?: boolean
    description_en?: boolean
    description_id?: boolean
    price_idr?: boolean
    price_usd?: boolean
    image?: boolean
    categoryId?: boolean
    subcategoryId?: boolean
    popular?: boolean
  }

  export type PackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name_en" | "name_id" | "description_en" | "description_id" | "price_idr" | "price_usd" | "image" | "categoryId" | "subcategoryId" | "popular", ExtArgs["result"]["package"]>
  export type PackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | Package$featuresArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
    productTransactions?: boolean | Package$productTransactionsArgs<ExtArgs>
    productCustomers?: boolean | Package$productCustomersArgs<ExtArgs>
    _count?: boolean | PackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }
  export type PackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    subcategory?: boolean | SubcategoryDefaultArgs<ExtArgs>
  }

  export type $PackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Package"
    objects: {
      features: Prisma.$FeaturePayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
      subcategory: Prisma.$SubcategoryPayload<ExtArgs>
      productTransactions: Prisma.$TransactionProductPayload<ExtArgs>[]
      productCustomers: Prisma.$ServicesProductCustomersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name_en: string
      name_id: string
      description_en: string
      description_id: string
      price_idr: Prisma.Decimal
      price_usd: Prisma.Decimal
      image: string
      categoryId: string
      subcategoryId: string
      popular: boolean | null
    }, ExtArgs["result"]["package"]>
    composites: {}
  }

  type PackageGetPayload<S extends boolean | null | undefined | PackageDefaultArgs> = $Result.GetResult<Prisma.$PackagePayload, S>

  type PackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PackageCountAggregateInputType | true
    }

  export interface PackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Package'], meta: { name: 'Package' } }
    /**
     * Find zero or one Package that matches the filter.
     * @param {PackageFindUniqueArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackageFindUniqueArgs>(args: SelectSubset<T, PackageFindUniqueArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Package that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PackageFindUniqueOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackageFindUniqueOrThrowArgs>(args: SelectSubset<T, PackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackageFindFirstArgs>(args?: SelectSubset<T, PackageFindFirstArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Package that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindFirstOrThrowArgs} args - Arguments to find a Package
     * @example
     * // Get one Package
     * const package = await prisma.package.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackageFindFirstOrThrowArgs>(args?: SelectSubset<T, PackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Packages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packages
     * const packages = await prisma.package.findMany()
     * 
     * // Get first 10 Packages
     * const packages = await prisma.package.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packageWithIdOnly = await prisma.package.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackageFindManyArgs>(args?: SelectSubset<T, PackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Package.
     * @param {PackageCreateArgs} args - Arguments to create a Package.
     * @example
     * // Create one Package
     * const Package = await prisma.package.create({
     *   data: {
     *     // ... data to create a Package
     *   }
     * })
     * 
     */
    create<T extends PackageCreateArgs>(args: SelectSubset<T, PackageCreateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Packages.
     * @param {PackageCreateManyArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackageCreateManyArgs>(args?: SelectSubset<T, PackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Packages and returns the data saved in the database.
     * @param {PackageCreateManyAndReturnArgs} args - Arguments to create many Packages.
     * @example
     * // Create many Packages
     * const package = await prisma.package.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PackageCreateManyAndReturnArgs>(args?: SelectSubset<T, PackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Package.
     * @param {PackageDeleteArgs} args - Arguments to delete one Package.
     * @example
     * // Delete one Package
     * const Package = await prisma.package.delete({
     *   where: {
     *     // ... filter to delete one Package
     *   }
     * })
     * 
     */
    delete<T extends PackageDeleteArgs>(args: SelectSubset<T, PackageDeleteArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Package.
     * @param {PackageUpdateArgs} args - Arguments to update one Package.
     * @example
     * // Update one Package
     * const package = await prisma.package.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackageUpdateArgs>(args: SelectSubset<T, PackageUpdateArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Packages.
     * @param {PackageDeleteManyArgs} args - Arguments to filter Packages to delete.
     * @example
     * // Delete a few Packages
     * const { count } = await prisma.package.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackageDeleteManyArgs>(args?: SelectSubset<T, PackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackageUpdateManyArgs>(args: SelectSubset<T, PackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packages and returns the data updated in the database.
     * @param {PackageUpdateManyAndReturnArgs} args - Arguments to update many Packages.
     * @example
     * // Update many Packages
     * const package = await prisma.package.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Packages and only return the `id`
     * const packageWithIdOnly = await prisma.package.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PackageUpdateManyAndReturnArgs>(args: SelectSubset<T, PackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Package.
     * @param {PackageUpsertArgs} args - Arguments to update or create a Package.
     * @example
     * // Update or create a Package
     * const package = await prisma.package.upsert({
     *   create: {
     *     // ... data to create a Package
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Package we want to update
     *   }
     * })
     */
    upsert<T extends PackageUpsertArgs>(args: SelectSubset<T, PackageUpsertArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Packages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageCountArgs} args - Arguments to filter Packages to count.
     * @example
     * // Count the number of Packages
     * const count = await prisma.package.count({
     *   where: {
     *     // ... the filter for the Packages we want to count
     *   }
     * })
    **/
    count<T extends PackageCountArgs>(
      args?: Subset<T, PackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackageAggregateArgs>(args: Subset<T, PackageAggregateArgs>): Prisma.PrismaPromise<GetPackageAggregateType<T>>

    /**
     * Group by Package.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackageGroupByArgs['orderBy'] }
        : { orderBy?: PackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Package model
   */
  readonly fields: PackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Package.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends Package$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Package$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subcategory<T extends SubcategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubcategoryDefaultArgs<ExtArgs>>): Prisma__SubcategoryClient<$Result.GetResult<Prisma.$SubcategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    productTransactions<T extends Package$productTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Package$productTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productCustomers<T extends Package$productCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Package$productCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Package model
   */
  interface PackageFieldRefs {
    readonly id: FieldRef<"Package", 'String'>
    readonly name_en: FieldRef<"Package", 'String'>
    readonly name_id: FieldRef<"Package", 'String'>
    readonly description_en: FieldRef<"Package", 'String'>
    readonly description_id: FieldRef<"Package", 'String'>
    readonly price_idr: FieldRef<"Package", 'Decimal'>
    readonly price_usd: FieldRef<"Package", 'Decimal'>
    readonly image: FieldRef<"Package", 'String'>
    readonly categoryId: FieldRef<"Package", 'String'>
    readonly subcategoryId: FieldRef<"Package", 'String'>
    readonly popular: FieldRef<"Package", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Package findUnique
   */
  export type PackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findUniqueOrThrow
   */
  export type PackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package findFirst
   */
  export type PackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findFirstOrThrow
   */
  export type PackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Package to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packages.
     */
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package findMany
   */
  export type PackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter, which Packages to fetch.
     */
    where?: PackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packages to fetch.
     */
    orderBy?: PackageOrderByWithRelationInput | PackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packages.
     */
    cursor?: PackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packages.
     */
    skip?: number
    distinct?: PackageScalarFieldEnum | PackageScalarFieldEnum[]
  }

  /**
   * Package create
   */
  export type PackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to create a Package.
     */
    data: XOR<PackageCreateInput, PackageUncheckedCreateInput>
  }

  /**
   * Package createMany
   */
  export type PackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Package createManyAndReturn
   */
  export type PackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to create many Packages.
     */
    data: PackageCreateManyInput | PackageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package update
   */
  export type PackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The data needed to update a Package.
     */
    data: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
    /**
     * Choose, which Package to update.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package updateMany
   */
  export type PackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
  }

  /**
   * Package updateManyAndReturn
   */
  export type PackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * The data used to update Packages.
     */
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyInput>
    /**
     * Filter which Packages to update
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Package upsert
   */
  export type PackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * The filter to search for the Package to update in case it exists.
     */
    where: PackageWhereUniqueInput
    /**
     * In case the Package found by the `where` argument doesn't exist, create a new Package with this data.
     */
    create: XOR<PackageCreateInput, PackageUncheckedCreateInput>
    /**
     * In case the Package was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackageUpdateInput, PackageUncheckedUpdateInput>
  }

  /**
   * Package delete
   */
  export type PackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    /**
     * Filter which Package to delete.
     */
    where: PackageWhereUniqueInput
  }

  /**
   * Package deleteMany
   */
  export type PackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packages to delete
     */
    where?: PackageWhereInput
    /**
     * Limit how many Packages to delete.
     */
    limit?: number
  }

  /**
   * Package.features
   */
  export type Package$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    cursor?: FeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Package.productTransactions
   */
  export type Package$productTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    where?: TransactionProductWhereInput
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    cursor?: TransactionProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionProductScalarFieldEnum | TransactionProductScalarFieldEnum[]
  }

  /**
   * Package.productCustomers
   */
  export type Package$productCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    where?: ServicesProductCustomersWhereInput
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    cursor?: ServicesProductCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * Package without action
   */
  export type PackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppSession
   */

  export type AggregateWhatsAppSession = {
    _count: WhatsAppSessionCountAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  export type WhatsAppSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    status: string | null
    qr: string | null
    isNotification: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    aiConfig: string | null
    message: string | null
    sessionName: string | null
    isTerminated: boolean | null
  }

  export type WhatsAppSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    status: string | null
    qr: string | null
    isNotification: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    aiConfig: string | null
    message: string | null
    sessionName: string | null
    isTerminated: boolean | null
  }

  export type WhatsAppSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    status: number
    qr: number
    isNotification: number
    createdAt: number
    updatedAt: number
    aiConfig: number
    message: number
    sessionName: number
    isTerminated: number
    _all: number
  }


  export type WhatsAppSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    qr?: true
    isNotification?: true
    createdAt?: true
    updatedAt?: true
    aiConfig?: true
    message?: true
    sessionName?: true
    isTerminated?: true
  }

  export type WhatsAppSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    qr?: true
    isNotification?: true
    createdAt?: true
    updatedAt?: true
    aiConfig?: true
    message?: true
    sessionName?: true
    isTerminated?: true
  }

  export type WhatsAppSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    status?: true
    qr?: true
    isNotification?: true
    createdAt?: true
    updatedAt?: true
    aiConfig?: true
    message?: true
    sessionName?: true
    isTerminated?: true
    _all?: true
  }

  export type WhatsAppSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSession to aggregate.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppSessions
    **/
    _count?: true | WhatsAppSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type GetWhatsAppSessionAggregateType<T extends WhatsAppSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppSession[P]>
      : GetScalarType<T[P], AggregateWhatsAppSession[P]>
  }




  export type WhatsAppSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppSessionWhereInput
    orderBy?: WhatsAppSessionOrderByWithAggregationInput | WhatsAppSessionOrderByWithAggregationInput[]
    by: WhatsAppSessionScalarFieldEnum[] | WhatsAppSessionScalarFieldEnum
    having?: WhatsAppSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppSessionCountAggregateInputType | true
    _min?: WhatsAppSessionMinAggregateInputType
    _max?: WhatsAppSessionMaxAggregateInputType
  }

  export type WhatsAppSessionGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    status: string
    qr: string | null
    isNotification: boolean
    createdAt: Date
    updatedAt: Date
    aiConfig: string | null
    message: string | null
    sessionName: string | null
    isTerminated: boolean
    _count: WhatsAppSessionCountAggregateOutputType | null
    _min: WhatsAppSessionMinAggregateOutputType | null
    _max: WhatsAppSessionMaxAggregateOutputType | null
  }

  type GetWhatsAppSessionGroupByPayload<T extends WhatsAppSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppSessionGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    qr?: boolean
    isNotification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiConfig?: boolean
    message?: boolean
    sessionName?: boolean
    isTerminated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    whatsappMessageStats?: boolean | WhatsAppSession$whatsappMessageStatsArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    qr?: boolean
    isNotification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiConfig?: boolean
    message?: boolean
    sessionName?: boolean
    isTerminated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    qr?: boolean
    isNotification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiConfig?: boolean
    message?: boolean
    sessionName?: boolean
    isTerminated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppSession"]>

  export type WhatsAppSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    status?: boolean
    qr?: boolean
    isNotification?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    aiConfig?: boolean
    message?: boolean
    sessionName?: boolean
    isTerminated?: boolean
  }

  export type WhatsAppSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "userId" | "status" | "qr" | "isNotification" | "createdAt" | "updatedAt" | "aiConfig" | "message" | "sessionName" | "isTerminated", ExtArgs["result"]["whatsAppSession"]>
  export type WhatsAppSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    whatsappMessageStats?: boolean | WhatsAppSession$whatsappMessageStatsArgs<ExtArgs>
    _count?: boolean | WhatsAppSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhatsAppSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhatsAppSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      whatsappMessageStats: Prisma.$WhatsAppMessageStatsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      status: string
      qr: string | null
      isNotification: boolean
      createdAt: Date
      updatedAt: Date
      aiConfig: string | null
      message: string | null
      sessionName: string | null
      isTerminated: boolean
    }, ExtArgs["result"]["whatsAppSession"]>
    composites: {}
  }

  type WhatsAppSessionGetPayload<S extends boolean | null | undefined | WhatsAppSessionDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppSessionPayload, S>

  type WhatsAppSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppSessionCountAggregateInputType | true
    }

  export interface WhatsAppSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppSession'], meta: { name: 'WhatsAppSession' } }
    /**
     * Find zero or one WhatsAppSession that matches the filter.
     * @param {WhatsAppSessionFindUniqueArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppSessionFindUniqueArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppSessionFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppSessionFindFirstArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindFirstOrThrowArgs} args - Arguments to find a WhatsAppSession
     * @example
     * // Get one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany()
     * 
     * // Get first 10 WhatsAppSessions
     * const whatsAppSessions = await prisma.whatsAppSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppSessionFindManyArgs>(args?: SelectSubset<T, WhatsAppSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppSession.
     * @param {WhatsAppSessionCreateArgs} args - Arguments to create a WhatsAppSession.
     * @example
     * // Create one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.create({
     *   data: {
     *     // ... data to create a WhatsAppSession
     *   }
     * })
     * 
     */
    create<T extends WhatsAppSessionCreateArgs>(args: SelectSubset<T, WhatsAppSessionCreateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppSessions.
     * @param {WhatsAppSessionCreateManyArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppSessionCreateManyArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppSessions and returns the data saved in the database.
     * @param {WhatsAppSessionCreateManyAndReturnArgs} args - Arguments to create many WhatsAppSessions.
     * @example
     * // Create many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppSessions and only return the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppSession.
     * @param {WhatsAppSessionDeleteArgs} args - Arguments to delete one WhatsAppSession.
     * @example
     * // Delete one WhatsAppSession
     * const WhatsAppSession = await prisma.whatsAppSession.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppSession
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppSessionDeleteArgs>(args: SelectSubset<T, WhatsAppSessionDeleteArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppSession.
     * @param {WhatsAppSessionUpdateArgs} args - Arguments to update one WhatsAppSession.
     * @example
     * // Update one WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppSessionUpdateArgs>(args: SelectSubset<T, WhatsAppSessionUpdateArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppSessions.
     * @param {WhatsAppSessionDeleteManyArgs} args - Arguments to filter WhatsAppSessions to delete.
     * @example
     * // Delete a few WhatsAppSessions
     * const { count } = await prisma.whatsAppSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppSessionDeleteManyArgs>(args?: SelectSubset<T, WhatsAppSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppSessionUpdateManyArgs>(args: SelectSubset<T, WhatsAppSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppSessions and returns the data updated in the database.
     * @param {WhatsAppSessionUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppSessions.
     * @example
     * // Update many WhatsAppSessions
     * const whatsAppSession = await prisma.whatsAppSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppSessions and only return the `id`
     * const whatsAppSessionWithIdOnly = await prisma.whatsAppSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppSession.
     * @param {WhatsAppSessionUpsertArgs} args - Arguments to update or create a WhatsAppSession.
     * @example
     * // Update or create a WhatsAppSession
     * const whatsAppSession = await prisma.whatsAppSession.upsert({
     *   create: {
     *     // ... data to create a WhatsAppSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppSession we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppSessionUpsertArgs>(args: SelectSubset<T, WhatsAppSessionUpsertArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionCountArgs} args - Arguments to filter WhatsAppSessions to count.
     * @example
     * // Count the number of WhatsAppSessions
     * const count = await prisma.whatsAppSession.count({
     *   where: {
     *     // ... the filter for the WhatsAppSessions we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppSessionCountArgs>(
      args?: Subset<T, WhatsAppSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppSessionAggregateArgs>(args: Subset<T, WhatsAppSessionAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppSessionAggregateType<T>>

    /**
     * Group by WhatsAppSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppSessionGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppSession model
   */
  readonly fields: WhatsAppSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whatsappMessageStats<T extends WhatsAppSession$whatsappMessageStatsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSession$whatsappMessageStatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppSession model
   */
  interface WhatsAppSessionFieldRefs {
    readonly id: FieldRef<"WhatsAppSession", 'String'>
    readonly sessionId: FieldRef<"WhatsAppSession", 'String'>
    readonly userId: FieldRef<"WhatsAppSession", 'String'>
    readonly status: FieldRef<"WhatsAppSession", 'String'>
    readonly qr: FieldRef<"WhatsAppSession", 'String'>
    readonly isNotification: FieldRef<"WhatsAppSession", 'Boolean'>
    readonly createdAt: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppSession", 'DateTime'>
    readonly aiConfig: FieldRef<"WhatsAppSession", 'String'>
    readonly message: FieldRef<"WhatsAppSession", 'String'>
    readonly sessionName: FieldRef<"WhatsAppSession", 'String'>
    readonly isTerminated: FieldRef<"WhatsAppSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppSession findUnique
   */
  export type WhatsAppSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findUniqueOrThrow
   */
  export type WhatsAppSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession findFirst
   */
  export type WhatsAppSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findFirstOrThrow
   */
  export type WhatsAppSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSession to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppSessions.
     */
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession findMany
   */
  export type WhatsAppSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppSessions to fetch.
     */
    where?: WhatsAppSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppSessions to fetch.
     */
    orderBy?: WhatsAppSessionOrderByWithRelationInput | WhatsAppSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppSessions.
     */
    cursor?: WhatsAppSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppSessions.
     */
    skip?: number
    distinct?: WhatsAppSessionScalarFieldEnum | WhatsAppSessionScalarFieldEnum[]
  }

  /**
   * WhatsAppSession create
   */
  export type WhatsAppSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
  }

  /**
   * WhatsAppSession createMany
   */
  export type WhatsAppSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppSession createManyAndReturn
   */
  export type WhatsAppSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppSessions.
     */
    data: WhatsAppSessionCreateManyInput | WhatsAppSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppSession update
   */
  export type WhatsAppSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppSession.
     */
    data: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppSession to update.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession updateMany
   */
  export type WhatsAppSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppSessions.
     */
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppSessions to update
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to update.
     */
    limit?: number
  }

  /**
   * WhatsAppSession updateManyAndReturn
   */
  export type WhatsAppSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppSessions.
     */
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppSessions to update
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppSession upsert
   */
  export type WhatsAppSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppSession to update in case it exists.
     */
    where: WhatsAppSessionWhereUniqueInput
    /**
     * In case the WhatsAppSession found by the `where` argument doesn't exist, create a new WhatsAppSession with this data.
     */
    create: XOR<WhatsAppSessionCreateInput, WhatsAppSessionUncheckedCreateInput>
    /**
     * In case the WhatsAppSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppSessionUpdateInput, WhatsAppSessionUncheckedUpdateInput>
  }

  /**
   * WhatsAppSession delete
   */
  export type WhatsAppSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppSession to delete.
     */
    where: WhatsAppSessionWhereUniqueInput
  }

  /**
   * WhatsAppSession deleteMany
   */
  export type WhatsAppSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppSessions to delete
     */
    where?: WhatsAppSessionWhereInput
    /**
     * Limit how many WhatsAppSessions to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppSession.whatsappMessageStats
   */
  export type WhatsAppSession$whatsappMessageStatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppSession without action
   */
  export type WhatsAppSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppSession
     */
    select?: WhatsAppSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppSession
     */
    omit?: WhatsAppSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppSessionInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionDate: Date | null
    status: string | null
    amount: Decimal | null
    createdAt: Date | null
    type: string | null
    updatedAt: Date | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    transactionDate: Date | null
    status: string | null
    amount: Decimal | null
    createdAt: Date | null
    type: string | null
    updatedAt: Date | null
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string | null
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    transactionDate: number
    status: number
    amount: number
    createdAt: number
    type: number
    updatedAt: number
    discountAmount: number
    originalAmount: number
    voucherId: number
    notes: number
    currency: number
    finalAmount: number
    serviceFeeAmount: number
    totalAfterDiscount: number
    expiresAt: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    discountAmount?: true
    originalAmount?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    discountAmount?: true
    originalAmount?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    transactionDate?: true
    status?: true
    amount?: true
    createdAt?: true
    type?: true
    updatedAt?: true
    discountAmount?: true
    originalAmount?: true
    voucherId?: true
    notes?: true
    currency?: true
    finalAmount?: true
    serviceFeeAmount?: true
    totalAfterDiscount?: true
    expiresAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string
    transactionDate: Date
    status: string
    amount: Decimal
    createdAt: Date
    type: string
    updatedAt: Date
    discountAmount: Decimal | null
    originalAmount: Decimal | null
    voucherId: string | null
    notes: string | null
    currency: string
    finalAmount: Decimal | null
    serviceFeeAmount: Decimal | null
    totalAfterDiscount: Decimal | null
    expiresAt: Date | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
    productTransactions?: boolean | Transaction$productTransactionsArgs<ExtArgs>
    addonTransactions?: boolean | Transaction$addonTransactionsArgs<ExtArgs>
    whatsappTransaction?: boolean | Transaction$whatsappTransactionArgs<ExtArgs>
    productCustomers?: boolean | Transaction$productCustomersArgs<ExtArgs>
    addonCustomers?: boolean | Transaction$addonCustomersArgs<ExtArgs>
    whatsappCustomers?: boolean | Transaction$whatsappCustomersArgs<ExtArgs>
    voucherUsage?: boolean | Transaction$voucherUsageArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    transactionDate?: boolean
    status?: boolean
    amount?: boolean
    createdAt?: boolean
    type?: boolean
    updatedAt?: boolean
    discountAmount?: boolean
    originalAmount?: boolean
    voucherId?: boolean
    notes?: boolean
    currency?: boolean
    finalAmount?: boolean
    serviceFeeAmount?: boolean
    totalAfterDiscount?: boolean
    expiresAt?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "transactionDate" | "status" | "amount" | "createdAt" | "type" | "updatedAt" | "discountAmount" | "originalAmount" | "voucherId" | "notes" | "currency" | "finalAmount" | "serviceFeeAmount" | "totalAfterDiscount" | "expiresAt", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | Transaction$paymentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
    productTransactions?: boolean | Transaction$productTransactionsArgs<ExtArgs>
    addonTransactions?: boolean | Transaction$addonTransactionsArgs<ExtArgs>
    whatsappTransaction?: boolean | Transaction$whatsappTransactionArgs<ExtArgs>
    productCustomers?: boolean | Transaction$productCustomersArgs<ExtArgs>
    addonCustomers?: boolean | Transaction$addonCustomersArgs<ExtArgs>
    whatsappCustomers?: boolean | Transaction$whatsappCustomersArgs<ExtArgs>
    voucherUsage?: boolean | Transaction$voucherUsageArgs<ExtArgs>
    _count?: boolean | TransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | Transaction$voucherArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs> | null
      productTransactions: Prisma.$TransactionProductPayload<ExtArgs>[]
      addonTransactions: Prisma.$TransactionAddonsPayload<ExtArgs>[]
      whatsappTransaction: Prisma.$TransactionWhatsappServicePayload<ExtArgs> | null
      productCustomers: Prisma.$ServicesProductCustomersPayload<ExtArgs>[]
      addonCustomers: Prisma.$ServicesAddonsCustomersPayload<ExtArgs>[]
      whatsappCustomers: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>[]
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      transactionDate: Date
      status: string
      amount: Prisma.Decimal
      createdAt: Date
      type: string
      updatedAt: Date
      discountAmount: Prisma.Decimal | null
      originalAmount: Prisma.Decimal | null
      voucherId: string | null
      notes: string | null
      currency: string
      finalAmount: Prisma.Decimal | null
      serviceFeeAmount: Prisma.Decimal | null
      totalAfterDiscount: Prisma.Decimal | null
      expiresAt: Date | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends Transaction$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voucher<T extends Transaction$voucherArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$voucherArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productTransactions<T extends Transaction$productTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$productTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addonTransactions<T extends Transaction$addonTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$addonTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappTransaction<T extends Transaction$whatsappTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$whatsappTransactionArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    productCustomers<T extends Transaction$productCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$productCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addonCustomers<T extends Transaction$addonCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$addonCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappCustomers<T extends Transaction$whatsappCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$whatsappCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsage<T extends Transaction$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly transactionDate: FieldRef<"Transaction", 'DateTime'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly type: FieldRef<"Transaction", 'String'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly discountAmount: FieldRef<"Transaction", 'Decimal'>
    readonly originalAmount: FieldRef<"Transaction", 'Decimal'>
    readonly voucherId: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly finalAmount: FieldRef<"Transaction", 'Decimal'>
    readonly serviceFeeAmount: FieldRef<"Transaction", 'Decimal'>
    readonly totalAfterDiscount: FieldRef<"Transaction", 'Decimal'>
    readonly expiresAt: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.payment
   */
  export type Transaction$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Transaction.voucher
   */
  export type Transaction$voucherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    where?: VoucherWhereInput
  }

  /**
   * Transaction.productTransactions
   */
  export type Transaction$productTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    where?: TransactionProductWhereInput
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    cursor?: TransactionProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionProductScalarFieldEnum | TransactionProductScalarFieldEnum[]
  }

  /**
   * Transaction.addonTransactions
   */
  export type Transaction$addonTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    where?: TransactionAddonsWhereInput
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    cursor?: TransactionAddonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionAddonsScalarFieldEnum | TransactionAddonsScalarFieldEnum[]
  }

  /**
   * Transaction.whatsappTransaction
   */
  export type Transaction$whatsappTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    where?: TransactionWhatsappServiceWhereInput
  }

  /**
   * Transaction.productCustomers
   */
  export type Transaction$productCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    where?: ServicesProductCustomersWhereInput
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    cursor?: ServicesProductCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * Transaction.addonCustomers
   */
  export type Transaction$addonCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    where?: ServicesAddonsCustomersWhereInput
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesAddonsCustomersScalarFieldEnum | ServicesAddonsCustomersScalarFieldEnum[]
  }

  /**
   * Transaction.whatsappCustomers
   */
  export type Transaction$whatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * Transaction.voucherUsage
   */
  export type Transaction$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model TransactionProduct
   */

  export type AggregateTransactionProduct = {
    _count: TransactionProductCountAggregateOutputType | null
    _avg: TransactionProductAvgAggregateOutputType | null
    _sum: TransactionProductSumAggregateOutputType | null
    _min: TransactionProductMinAggregateOutputType | null
    _max: TransactionProductMaxAggregateOutputType | null
  }

  export type TransactionProductAvgAggregateOutputType = {
    quantity: number | null
  }

  export type TransactionProductSumAggregateOutputType = {
    quantity: number | null
  }

  export type TransactionProductMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    packageId: string | null
    quantity: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    referenceLink: string | null
  }

  export type TransactionProductMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    packageId: string | null
    quantity: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    referenceLink: string | null
  }

  export type TransactionProductCountAggregateOutputType = {
    id: number
    transactionId: number
    packageId: number
    quantity: number
    status: number
    startDate: number
    endDate: number
    referenceLink: number
    _all: number
  }


  export type TransactionProductAvgAggregateInputType = {
    quantity?: true
  }

  export type TransactionProductSumAggregateInputType = {
    quantity?: true
  }

  export type TransactionProductMinAggregateInputType = {
    id?: true
    transactionId?: true
    packageId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
    referenceLink?: true
  }

  export type TransactionProductMaxAggregateInputType = {
    id?: true
    transactionId?: true
    packageId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
    referenceLink?: true
  }

  export type TransactionProductCountAggregateInputType = {
    id?: true
    transactionId?: true
    packageId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
    referenceLink?: true
    _all?: true
  }

  export type TransactionProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionProduct to aggregate.
     */
    where?: TransactionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionProducts to fetch.
     */
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionProducts
    **/
    _count?: true | TransactionProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionProductMaxAggregateInputType
  }

  export type GetTransactionProductAggregateType<T extends TransactionProductAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionProduct[P]>
      : GetScalarType<T[P], AggregateTransactionProduct[P]>
  }




  export type TransactionProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionProductWhereInput
    orderBy?: TransactionProductOrderByWithAggregationInput | TransactionProductOrderByWithAggregationInput[]
    by: TransactionProductScalarFieldEnum[] | TransactionProductScalarFieldEnum
    having?: TransactionProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionProductCountAggregateInputType | true
    _avg?: TransactionProductAvgAggregateInputType
    _sum?: TransactionProductSumAggregateInputType
    _min?: TransactionProductMinAggregateInputType
    _max?: TransactionProductMaxAggregateInputType
  }

  export type TransactionProductGroupByOutputType = {
    id: string
    transactionId: string
    packageId: string | null
    quantity: number
    status: string
    startDate: Date | null
    endDate: Date | null
    referenceLink: string | null
    _count: TransactionProductCountAggregateOutputType | null
    _avg: TransactionProductAvgAggregateOutputType | null
    _sum: TransactionProductSumAggregateOutputType | null
    _min: TransactionProductMinAggregateOutputType | null
    _max: TransactionProductMaxAggregateOutputType | null
  }

  type GetTransactionProductGroupByPayload<T extends TransactionProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionProductGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionProductGroupByOutputType[P]>
        }
      >
    >


  export type TransactionProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    packageId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    referenceLink?: boolean
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionProduct"]>

  export type TransactionProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    packageId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    referenceLink?: boolean
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionProduct"]>

  export type TransactionProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    packageId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    referenceLink?: boolean
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionProduct"]>

  export type TransactionProductSelectScalar = {
    id?: boolean
    transactionId?: boolean
    packageId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    referenceLink?: boolean
  }

  export type TransactionProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "packageId" | "quantity" | "status" | "startDate" | "endDate" | "referenceLink", ExtArgs["result"]["transactionProduct"]>
  export type TransactionProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    package?: boolean | TransactionProduct$packageArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionProduct"
    objects: {
      package: Prisma.$PackagePayload<ExtArgs> | null
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      packageId: string | null
      quantity: number
      status: string
      startDate: Date | null
      endDate: Date | null
      referenceLink: string | null
    }, ExtArgs["result"]["transactionProduct"]>
    composites: {}
  }

  type TransactionProductGetPayload<S extends boolean | null | undefined | TransactionProductDefaultArgs> = $Result.GetResult<Prisma.$TransactionProductPayload, S>

  type TransactionProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionProductCountAggregateInputType | true
    }

  export interface TransactionProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionProduct'], meta: { name: 'TransactionProduct' } }
    /**
     * Find zero or one TransactionProduct that matches the filter.
     * @param {TransactionProductFindUniqueArgs} args - Arguments to find a TransactionProduct
     * @example
     * // Get one TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionProductFindUniqueArgs>(args: SelectSubset<T, TransactionProductFindUniqueArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionProductFindUniqueOrThrowArgs} args - Arguments to find a TransactionProduct
     * @example
     * // Get one TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionProductFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductFindFirstArgs} args - Arguments to find a TransactionProduct
     * @example
     * // Get one TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionProductFindFirstArgs>(args?: SelectSubset<T, TransactionProductFindFirstArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductFindFirstOrThrowArgs} args - Arguments to find a TransactionProduct
     * @example
     * // Get one TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionProductFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionProducts
     * const transactionProducts = await prisma.transactionProduct.findMany()
     * 
     * // Get first 10 TransactionProducts
     * const transactionProducts = await prisma.transactionProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionProductWithIdOnly = await prisma.transactionProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionProductFindManyArgs>(args?: SelectSubset<T, TransactionProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionProduct.
     * @param {TransactionProductCreateArgs} args - Arguments to create a TransactionProduct.
     * @example
     * // Create one TransactionProduct
     * const TransactionProduct = await prisma.transactionProduct.create({
     *   data: {
     *     // ... data to create a TransactionProduct
     *   }
     * })
     * 
     */
    create<T extends TransactionProductCreateArgs>(args: SelectSubset<T, TransactionProductCreateArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionProducts.
     * @param {TransactionProductCreateManyArgs} args - Arguments to create many TransactionProducts.
     * @example
     * // Create many TransactionProducts
     * const transactionProduct = await prisma.transactionProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionProductCreateManyArgs>(args?: SelectSubset<T, TransactionProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionProducts and returns the data saved in the database.
     * @param {TransactionProductCreateManyAndReturnArgs} args - Arguments to create many TransactionProducts.
     * @example
     * // Create many TransactionProducts
     * const transactionProduct = await prisma.transactionProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionProducts and only return the `id`
     * const transactionProductWithIdOnly = await prisma.transactionProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionProductCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionProduct.
     * @param {TransactionProductDeleteArgs} args - Arguments to delete one TransactionProduct.
     * @example
     * // Delete one TransactionProduct
     * const TransactionProduct = await prisma.transactionProduct.delete({
     *   where: {
     *     // ... filter to delete one TransactionProduct
     *   }
     * })
     * 
     */
    delete<T extends TransactionProductDeleteArgs>(args: SelectSubset<T, TransactionProductDeleteArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionProduct.
     * @param {TransactionProductUpdateArgs} args - Arguments to update one TransactionProduct.
     * @example
     * // Update one TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionProductUpdateArgs>(args: SelectSubset<T, TransactionProductUpdateArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionProducts.
     * @param {TransactionProductDeleteManyArgs} args - Arguments to filter TransactionProducts to delete.
     * @example
     * // Delete a few TransactionProducts
     * const { count } = await prisma.transactionProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionProductDeleteManyArgs>(args?: SelectSubset<T, TransactionProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionProducts
     * const transactionProduct = await prisma.transactionProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionProductUpdateManyArgs>(args: SelectSubset<T, TransactionProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionProducts and returns the data updated in the database.
     * @param {TransactionProductUpdateManyAndReturnArgs} args - Arguments to update many TransactionProducts.
     * @example
     * // Update many TransactionProducts
     * const transactionProduct = await prisma.transactionProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionProducts and only return the `id`
     * const transactionProductWithIdOnly = await prisma.transactionProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionProductUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionProduct.
     * @param {TransactionProductUpsertArgs} args - Arguments to update or create a TransactionProduct.
     * @example
     * // Update or create a TransactionProduct
     * const transactionProduct = await prisma.transactionProduct.upsert({
     *   create: {
     *     // ... data to create a TransactionProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionProduct we want to update
     *   }
     * })
     */
    upsert<T extends TransactionProductUpsertArgs>(args: SelectSubset<T, TransactionProductUpsertArgs<ExtArgs>>): Prisma__TransactionProductClient<$Result.GetResult<Prisma.$TransactionProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductCountArgs} args - Arguments to filter TransactionProducts to count.
     * @example
     * // Count the number of TransactionProducts
     * const count = await prisma.transactionProduct.count({
     *   where: {
     *     // ... the filter for the TransactionProducts we want to count
     *   }
     * })
    **/
    count<T extends TransactionProductCountArgs>(
      args?: Subset<T, TransactionProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionProductAggregateArgs>(args: Subset<T, TransactionProductAggregateArgs>): Prisma.PrismaPromise<GetTransactionProductAggregateType<T>>

    /**
     * Group by TransactionProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionProductGroupByArgs['orderBy'] }
        : { orderBy?: TransactionProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionProduct model
   */
  readonly fields: TransactionProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    package<T extends TransactionProduct$packageArgs<ExtArgs> = {}>(args?: Subset<T, TransactionProduct$packageArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionProduct model
   */
  interface TransactionProductFieldRefs {
    readonly id: FieldRef<"TransactionProduct", 'String'>
    readonly transactionId: FieldRef<"TransactionProduct", 'String'>
    readonly packageId: FieldRef<"TransactionProduct", 'String'>
    readonly quantity: FieldRef<"TransactionProduct", 'Int'>
    readonly status: FieldRef<"TransactionProduct", 'String'>
    readonly startDate: FieldRef<"TransactionProduct", 'DateTime'>
    readonly endDate: FieldRef<"TransactionProduct", 'DateTime'>
    readonly referenceLink: FieldRef<"TransactionProduct", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TransactionProduct findUnique
   */
  export type TransactionProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionProduct to fetch.
     */
    where: TransactionProductWhereUniqueInput
  }

  /**
   * TransactionProduct findUniqueOrThrow
   */
  export type TransactionProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionProduct to fetch.
     */
    where: TransactionProductWhereUniqueInput
  }

  /**
   * TransactionProduct findFirst
   */
  export type TransactionProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionProduct to fetch.
     */
    where?: TransactionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionProducts to fetch.
     */
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionProducts.
     */
    cursor?: TransactionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionProducts.
     */
    distinct?: TransactionProductScalarFieldEnum | TransactionProductScalarFieldEnum[]
  }

  /**
   * TransactionProduct findFirstOrThrow
   */
  export type TransactionProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionProduct to fetch.
     */
    where?: TransactionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionProducts to fetch.
     */
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionProducts.
     */
    cursor?: TransactionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionProducts.
     */
    distinct?: TransactionProductScalarFieldEnum | TransactionProductScalarFieldEnum[]
  }

  /**
   * TransactionProduct findMany
   */
  export type TransactionProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter, which TransactionProducts to fetch.
     */
    where?: TransactionProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionProducts to fetch.
     */
    orderBy?: TransactionProductOrderByWithRelationInput | TransactionProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionProducts.
     */
    cursor?: TransactionProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionProducts.
     */
    skip?: number
    distinct?: TransactionProductScalarFieldEnum | TransactionProductScalarFieldEnum[]
  }

  /**
   * TransactionProduct create
   */
  export type TransactionProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionProduct.
     */
    data: XOR<TransactionProductCreateInput, TransactionProductUncheckedCreateInput>
  }

  /**
   * TransactionProduct createMany
   */
  export type TransactionProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionProducts.
     */
    data: TransactionProductCreateManyInput | TransactionProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionProduct createManyAndReturn
   */
  export type TransactionProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionProducts.
     */
    data: TransactionProductCreateManyInput | TransactionProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionProduct update
   */
  export type TransactionProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionProduct.
     */
    data: XOR<TransactionProductUpdateInput, TransactionProductUncheckedUpdateInput>
    /**
     * Choose, which TransactionProduct to update.
     */
    where: TransactionProductWhereUniqueInput
  }

  /**
   * TransactionProduct updateMany
   */
  export type TransactionProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionProducts.
     */
    data: XOR<TransactionProductUpdateManyMutationInput, TransactionProductUncheckedUpdateManyInput>
    /**
     * Filter which TransactionProducts to update
     */
    where?: TransactionProductWhereInput
    /**
     * Limit how many TransactionProducts to update.
     */
    limit?: number
  }

  /**
   * TransactionProduct updateManyAndReturn
   */
  export type TransactionProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * The data used to update TransactionProducts.
     */
    data: XOR<TransactionProductUpdateManyMutationInput, TransactionProductUncheckedUpdateManyInput>
    /**
     * Filter which TransactionProducts to update
     */
    where?: TransactionProductWhereInput
    /**
     * Limit how many TransactionProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionProduct upsert
   */
  export type TransactionProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionProduct to update in case it exists.
     */
    where: TransactionProductWhereUniqueInput
    /**
     * In case the TransactionProduct found by the `where` argument doesn't exist, create a new TransactionProduct with this data.
     */
    create: XOR<TransactionProductCreateInput, TransactionProductUncheckedCreateInput>
    /**
     * In case the TransactionProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionProductUpdateInput, TransactionProductUncheckedUpdateInput>
  }

  /**
   * TransactionProduct delete
   */
  export type TransactionProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
    /**
     * Filter which TransactionProduct to delete.
     */
    where: TransactionProductWhereUniqueInput
  }

  /**
   * TransactionProduct deleteMany
   */
  export type TransactionProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionProducts to delete
     */
    where?: TransactionProductWhereInput
    /**
     * Limit how many TransactionProducts to delete.
     */
    limit?: number
  }

  /**
   * TransactionProduct.package
   */
  export type TransactionProduct$packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
  }

  /**
   * TransactionProduct without action
   */
  export type TransactionProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionProduct
     */
    select?: TransactionProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionProduct
     */
    omit?: TransactionProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionProductInclude<ExtArgs> | null
  }


  /**
   * Model TransactionAddons
   */

  export type AggregateTransactionAddons = {
    _count: TransactionAddonsCountAggregateOutputType | null
    _avg: TransactionAddonsAvgAggregateOutputType | null
    _sum: TransactionAddonsSumAggregateOutputType | null
    _min: TransactionAddonsMinAggregateOutputType | null
    _max: TransactionAddonsMaxAggregateOutputType | null
  }

  export type TransactionAddonsAvgAggregateOutputType = {
    quantity: number | null
  }

  export type TransactionAddonsSumAggregateOutputType = {
    quantity: number | null
  }

  export type TransactionAddonsMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    addonId: string | null
    quantity: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionAddonsMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    addonId: string | null
    quantity: number | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionAddonsCountAggregateOutputType = {
    id: number
    transactionId: number
    addonId: number
    quantity: number
    status: number
    startDate: number
    endDate: number
    _all: number
  }


  export type TransactionAddonsAvgAggregateInputType = {
    quantity?: true
  }

  export type TransactionAddonsSumAggregateInputType = {
    quantity?: true
  }

  export type TransactionAddonsMinAggregateInputType = {
    id?: true
    transactionId?: true
    addonId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionAddonsMaxAggregateInputType = {
    id?: true
    transactionId?: true
    addonId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionAddonsCountAggregateInputType = {
    id?: true
    transactionId?: true
    addonId?: true
    quantity?: true
    status?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type TransactionAddonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionAddons to aggregate.
     */
    where?: TransactionAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAddons to fetch.
     */
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionAddons
    **/
    _count?: true | TransactionAddonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAddonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionAddonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionAddonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionAddonsMaxAggregateInputType
  }

  export type GetTransactionAddonsAggregateType<T extends TransactionAddonsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionAddons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionAddons[P]>
      : GetScalarType<T[P], AggregateTransactionAddons[P]>
  }




  export type TransactionAddonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionAddonsWhereInput
    orderBy?: TransactionAddonsOrderByWithAggregationInput | TransactionAddonsOrderByWithAggregationInput[]
    by: TransactionAddonsScalarFieldEnum[] | TransactionAddonsScalarFieldEnum
    having?: TransactionAddonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionAddonsCountAggregateInputType | true
    _avg?: TransactionAddonsAvgAggregateInputType
    _sum?: TransactionAddonsSumAggregateInputType
    _min?: TransactionAddonsMinAggregateInputType
    _max?: TransactionAddonsMaxAggregateInputType
  }

  export type TransactionAddonsGroupByOutputType = {
    id: string
    transactionId: string
    addonId: string
    quantity: number
    status: string
    startDate: Date | null
    endDate: Date | null
    _count: TransactionAddonsCountAggregateOutputType | null
    _avg: TransactionAddonsAvgAggregateOutputType | null
    _sum: TransactionAddonsSumAggregateOutputType | null
    _min: TransactionAddonsMinAggregateOutputType | null
    _max: TransactionAddonsMaxAggregateOutputType | null
  }

  type GetTransactionAddonsGroupByPayload<T extends TransactionAddonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionAddonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionAddonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionAddonsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionAddonsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionAddonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    addonId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionAddons"]>

  export type TransactionAddonsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    addonId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionAddons"]>

  export type TransactionAddonsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    addonId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionAddons"]>

  export type TransactionAddonsSelectScalar = {
    id?: boolean
    transactionId?: boolean
    addonId?: boolean
    quantity?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type TransactionAddonsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "addonId" | "quantity" | "status" | "startDate" | "endDate", ExtArgs["result"]["transactionAddons"]>
  export type TransactionAddonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionAddonsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type TransactionAddonsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addon?: boolean | AddonDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionAddonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionAddons"
    objects: {
      addon: Prisma.$AddonPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      addonId: string
      quantity: number
      status: string
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["transactionAddons"]>
    composites: {}
  }

  type TransactionAddonsGetPayload<S extends boolean | null | undefined | TransactionAddonsDefaultArgs> = $Result.GetResult<Prisma.$TransactionAddonsPayload, S>

  type TransactionAddonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionAddonsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionAddonsCountAggregateInputType | true
    }

  export interface TransactionAddonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionAddons'], meta: { name: 'TransactionAddons' } }
    /**
     * Find zero or one TransactionAddons that matches the filter.
     * @param {TransactionAddonsFindUniqueArgs} args - Arguments to find a TransactionAddons
     * @example
     * // Get one TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionAddonsFindUniqueArgs>(args: SelectSubset<T, TransactionAddonsFindUniqueArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionAddons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionAddonsFindUniqueOrThrowArgs} args - Arguments to find a TransactionAddons
     * @example
     * // Get one TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionAddonsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionAddonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsFindFirstArgs} args - Arguments to find a TransactionAddons
     * @example
     * // Get one TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionAddonsFindFirstArgs>(args?: SelectSubset<T, TransactionAddonsFindFirstArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionAddons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsFindFirstOrThrowArgs} args - Arguments to find a TransactionAddons
     * @example
     * // Get one TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionAddonsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionAddonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionAddons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findMany()
     * 
     * // Get first 10 TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionAddonsWithIdOnly = await prisma.transactionAddons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionAddonsFindManyArgs>(args?: SelectSubset<T, TransactionAddonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionAddons.
     * @param {TransactionAddonsCreateArgs} args - Arguments to create a TransactionAddons.
     * @example
     * // Create one TransactionAddons
     * const TransactionAddons = await prisma.transactionAddons.create({
     *   data: {
     *     // ... data to create a TransactionAddons
     *   }
     * })
     * 
     */
    create<T extends TransactionAddonsCreateArgs>(args: SelectSubset<T, TransactionAddonsCreateArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionAddons.
     * @param {TransactionAddonsCreateManyArgs} args - Arguments to create many TransactionAddons.
     * @example
     * // Create many TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionAddonsCreateManyArgs>(args?: SelectSubset<T, TransactionAddonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionAddons and returns the data saved in the database.
     * @param {TransactionAddonsCreateManyAndReturnArgs} args - Arguments to create many TransactionAddons.
     * @example
     * // Create many TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionAddons and only return the `id`
     * const transactionAddonsWithIdOnly = await prisma.transactionAddons.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionAddonsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionAddonsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionAddons.
     * @param {TransactionAddonsDeleteArgs} args - Arguments to delete one TransactionAddons.
     * @example
     * // Delete one TransactionAddons
     * const TransactionAddons = await prisma.transactionAddons.delete({
     *   where: {
     *     // ... filter to delete one TransactionAddons
     *   }
     * })
     * 
     */
    delete<T extends TransactionAddonsDeleteArgs>(args: SelectSubset<T, TransactionAddonsDeleteArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionAddons.
     * @param {TransactionAddonsUpdateArgs} args - Arguments to update one TransactionAddons.
     * @example
     * // Update one TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionAddonsUpdateArgs>(args: SelectSubset<T, TransactionAddonsUpdateArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionAddons.
     * @param {TransactionAddonsDeleteManyArgs} args - Arguments to filter TransactionAddons to delete.
     * @example
     * // Delete a few TransactionAddons
     * const { count } = await prisma.transactionAddons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionAddonsDeleteManyArgs>(args?: SelectSubset<T, TransactionAddonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionAddonsUpdateManyArgs>(args: SelectSubset<T, TransactionAddonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionAddons and returns the data updated in the database.
     * @param {TransactionAddonsUpdateManyAndReturnArgs} args - Arguments to update many TransactionAddons.
     * @example
     * // Update many TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionAddons and only return the `id`
     * const transactionAddonsWithIdOnly = await prisma.transactionAddons.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionAddonsUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionAddonsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionAddons.
     * @param {TransactionAddonsUpsertArgs} args - Arguments to update or create a TransactionAddons.
     * @example
     * // Update or create a TransactionAddons
     * const transactionAddons = await prisma.transactionAddons.upsert({
     *   create: {
     *     // ... data to create a TransactionAddons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionAddons we want to update
     *   }
     * })
     */
    upsert<T extends TransactionAddonsUpsertArgs>(args: SelectSubset<T, TransactionAddonsUpsertArgs<ExtArgs>>): Prisma__TransactionAddonsClient<$Result.GetResult<Prisma.$TransactionAddonsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsCountArgs} args - Arguments to filter TransactionAddons to count.
     * @example
     * // Count the number of TransactionAddons
     * const count = await prisma.transactionAddons.count({
     *   where: {
     *     // ... the filter for the TransactionAddons we want to count
     *   }
     * })
    **/
    count<T extends TransactionAddonsCountArgs>(
      args?: Subset<T, TransactionAddonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionAddonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAddonsAggregateArgs>(args: Subset<T, TransactionAddonsAggregateArgs>): Prisma.PrismaPromise<GetTransactionAddonsAggregateType<T>>

    /**
     * Group by TransactionAddons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAddonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionAddonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionAddonsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionAddonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionAddonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionAddonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionAddons model
   */
  readonly fields: TransactionAddonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionAddons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionAddonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addon<T extends AddonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AddonDefaultArgs<ExtArgs>>): Prisma__AddonClient<$Result.GetResult<Prisma.$AddonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionAddons model
   */
  interface TransactionAddonsFieldRefs {
    readonly id: FieldRef<"TransactionAddons", 'String'>
    readonly transactionId: FieldRef<"TransactionAddons", 'String'>
    readonly addonId: FieldRef<"TransactionAddons", 'String'>
    readonly quantity: FieldRef<"TransactionAddons", 'Int'>
    readonly status: FieldRef<"TransactionAddons", 'String'>
    readonly startDate: FieldRef<"TransactionAddons", 'DateTime'>
    readonly endDate: FieldRef<"TransactionAddons", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionAddons findUnique
   */
  export type TransactionAddonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAddons to fetch.
     */
    where: TransactionAddonsWhereUniqueInput
  }

  /**
   * TransactionAddons findUniqueOrThrow
   */
  export type TransactionAddonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAddons to fetch.
     */
    where: TransactionAddonsWhereUniqueInput
  }

  /**
   * TransactionAddons findFirst
   */
  export type TransactionAddonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAddons to fetch.
     */
    where?: TransactionAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAddons to fetch.
     */
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionAddons.
     */
    cursor?: TransactionAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionAddons.
     */
    distinct?: TransactionAddonsScalarFieldEnum | TransactionAddonsScalarFieldEnum[]
  }

  /**
   * TransactionAddons findFirstOrThrow
   */
  export type TransactionAddonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAddons to fetch.
     */
    where?: TransactionAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAddons to fetch.
     */
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionAddons.
     */
    cursor?: TransactionAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAddons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionAddons.
     */
    distinct?: TransactionAddonsScalarFieldEnum | TransactionAddonsScalarFieldEnum[]
  }

  /**
   * TransactionAddons findMany
   */
  export type TransactionAddonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter, which TransactionAddons to fetch.
     */
    where?: TransactionAddonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionAddons to fetch.
     */
    orderBy?: TransactionAddonsOrderByWithRelationInput | TransactionAddonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionAddons.
     */
    cursor?: TransactionAddonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionAddons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionAddons.
     */
    skip?: number
    distinct?: TransactionAddonsScalarFieldEnum | TransactionAddonsScalarFieldEnum[]
  }

  /**
   * TransactionAddons create
   */
  export type TransactionAddonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionAddons.
     */
    data: XOR<TransactionAddonsCreateInput, TransactionAddonsUncheckedCreateInput>
  }

  /**
   * TransactionAddons createMany
   */
  export type TransactionAddonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionAddons.
     */
    data: TransactionAddonsCreateManyInput | TransactionAddonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionAddons createManyAndReturn
   */
  export type TransactionAddonsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionAddons.
     */
    data: TransactionAddonsCreateManyInput | TransactionAddonsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionAddons update
   */
  export type TransactionAddonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionAddons.
     */
    data: XOR<TransactionAddonsUpdateInput, TransactionAddonsUncheckedUpdateInput>
    /**
     * Choose, which TransactionAddons to update.
     */
    where: TransactionAddonsWhereUniqueInput
  }

  /**
   * TransactionAddons updateMany
   */
  export type TransactionAddonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionAddons.
     */
    data: XOR<TransactionAddonsUpdateManyMutationInput, TransactionAddonsUncheckedUpdateManyInput>
    /**
     * Filter which TransactionAddons to update
     */
    where?: TransactionAddonsWhereInput
    /**
     * Limit how many TransactionAddons to update.
     */
    limit?: number
  }

  /**
   * TransactionAddons updateManyAndReturn
   */
  export type TransactionAddonsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * The data used to update TransactionAddons.
     */
    data: XOR<TransactionAddonsUpdateManyMutationInput, TransactionAddonsUncheckedUpdateManyInput>
    /**
     * Filter which TransactionAddons to update
     */
    where?: TransactionAddonsWhereInput
    /**
     * Limit how many TransactionAddons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionAddons upsert
   */
  export type TransactionAddonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionAddons to update in case it exists.
     */
    where: TransactionAddonsWhereUniqueInput
    /**
     * In case the TransactionAddons found by the `where` argument doesn't exist, create a new TransactionAddons with this data.
     */
    create: XOR<TransactionAddonsCreateInput, TransactionAddonsUncheckedCreateInput>
    /**
     * In case the TransactionAddons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionAddonsUpdateInput, TransactionAddonsUncheckedUpdateInput>
  }

  /**
   * TransactionAddons delete
   */
  export type TransactionAddonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
    /**
     * Filter which TransactionAddons to delete.
     */
    where: TransactionAddonsWhereUniqueInput
  }

  /**
   * TransactionAddons deleteMany
   */
  export type TransactionAddonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionAddons to delete
     */
    where?: TransactionAddonsWhereInput
    /**
     * Limit how many TransactionAddons to delete.
     */
    limit?: number
  }

  /**
   * TransactionAddons without action
   */
  export type TransactionAddonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionAddons
     */
    select?: TransactionAddonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionAddons
     */
    omit?: TransactionAddonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionAddonsInclude<ExtArgs> | null
  }


  /**
   * Model TransactionWhatsappService
   */

  export type AggregateTransactionWhatsappService = {
    _count: TransactionWhatsappServiceCountAggregateOutputType | null
    _min: TransactionWhatsappServiceMinAggregateOutputType | null
    _max: TransactionWhatsappServiceMaxAggregateOutputType | null
  }

  export type TransactionWhatsappServiceMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    whatsappPackageId: string | null
    duration: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionWhatsappServiceMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    whatsappPackageId: string | null
    duration: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
  }

  export type TransactionWhatsappServiceCountAggregateOutputType = {
    id: number
    transactionId: number
    whatsappPackageId: number
    duration: number
    status: number
    startDate: number
    endDate: number
    _all: number
  }


  export type TransactionWhatsappServiceMinAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionWhatsappServiceMaxAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
  }

  export type TransactionWhatsappServiceCountAggregateInputType = {
    id?: true
    transactionId?: true
    whatsappPackageId?: true
    duration?: true
    status?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type TransactionWhatsappServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionWhatsappService to aggregate.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionWhatsappServices
    **/
    _count?: true | TransactionWhatsappServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionWhatsappServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionWhatsappServiceMaxAggregateInputType
  }

  export type GetTransactionWhatsappServiceAggregateType<T extends TransactionWhatsappServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionWhatsappService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionWhatsappService[P]>
      : GetScalarType<T[P], AggregateTransactionWhatsappService[P]>
  }




  export type TransactionWhatsappServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhatsappServiceWhereInput
    orderBy?: TransactionWhatsappServiceOrderByWithAggregationInput | TransactionWhatsappServiceOrderByWithAggregationInput[]
    by: TransactionWhatsappServiceScalarFieldEnum[] | TransactionWhatsappServiceScalarFieldEnum
    having?: TransactionWhatsappServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionWhatsappServiceCountAggregateInputType | true
    _min?: TransactionWhatsappServiceMinAggregateInputType
    _max?: TransactionWhatsappServiceMaxAggregateInputType
  }

  export type TransactionWhatsappServiceGroupByOutputType = {
    id: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status: string
    startDate: Date | null
    endDate: Date | null
    _count: TransactionWhatsappServiceCountAggregateOutputType | null
    _min: TransactionWhatsappServiceMinAggregateOutputType | null
    _max: TransactionWhatsappServiceMaxAggregateOutputType | null
  }

  type GetTransactionWhatsappServiceGroupByPayload<T extends TransactionWhatsappServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionWhatsappServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionWhatsappServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionWhatsappServiceGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionWhatsappServiceGroupByOutputType[P]>
        }
      >
    >


  export type TransactionWhatsappServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionWhatsappService"]>

  export type TransactionWhatsappServiceSelectScalar = {
    id?: boolean
    transactionId?: boolean
    whatsappPackageId?: boolean
    duration?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type TransactionWhatsappServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "whatsappPackageId" | "duration" | "status" | "startDate" | "endDate", ExtArgs["result"]["transactionWhatsappService"]>
  export type TransactionWhatsappServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type TransactionWhatsappServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type TransactionWhatsappServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    whatsappPackage?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }

  export type $TransactionWhatsappServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionWhatsappService"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs>
      whatsappPackage: Prisma.$WhatsappApiPackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      whatsappPackageId: string
      duration: string
      status: string
      startDate: Date | null
      endDate: Date | null
    }, ExtArgs["result"]["transactionWhatsappService"]>
    composites: {}
  }

  type TransactionWhatsappServiceGetPayload<S extends boolean | null | undefined | TransactionWhatsappServiceDefaultArgs> = $Result.GetResult<Prisma.$TransactionWhatsappServicePayload, S>

  type TransactionWhatsappServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionWhatsappServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionWhatsappServiceCountAggregateInputType | true
    }

  export interface TransactionWhatsappServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionWhatsappService'], meta: { name: 'TransactionWhatsappService' } }
    /**
     * Find zero or one TransactionWhatsappService that matches the filter.
     * @param {TransactionWhatsappServiceFindUniqueArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionWhatsappServiceFindUniqueArgs>(args: SelectSubset<T, TransactionWhatsappServiceFindUniqueArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionWhatsappService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionWhatsappServiceFindUniqueOrThrowArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionWhatsappServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionWhatsappService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindFirstArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionWhatsappServiceFindFirstArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindFirstArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionWhatsappService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindFirstOrThrowArgs} args - Arguments to find a TransactionWhatsappService
     * @example
     * // Get one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionWhatsappServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionWhatsappServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionWhatsappServices
     * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany()
     * 
     * // Get first 10 TransactionWhatsappServices
     * const transactionWhatsappServices = await prisma.transactionWhatsappService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionWhatsappServiceFindManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionWhatsappService.
     * @param {TransactionWhatsappServiceCreateArgs} args - Arguments to create a TransactionWhatsappService.
     * @example
     * // Create one TransactionWhatsappService
     * const TransactionWhatsappService = await prisma.transactionWhatsappService.create({
     *   data: {
     *     // ... data to create a TransactionWhatsappService
     *   }
     * })
     * 
     */
    create<T extends TransactionWhatsappServiceCreateArgs>(args: SelectSubset<T, TransactionWhatsappServiceCreateArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionWhatsappServices.
     * @param {TransactionWhatsappServiceCreateManyArgs} args - Arguments to create many TransactionWhatsappServices.
     * @example
     * // Create many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionWhatsappServiceCreateManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionWhatsappServices and returns the data saved in the database.
     * @param {TransactionWhatsappServiceCreateManyAndReturnArgs} args - Arguments to create many TransactionWhatsappServices.
     * @example
     * // Create many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionWhatsappServices and only return the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionWhatsappServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionWhatsappService.
     * @param {TransactionWhatsappServiceDeleteArgs} args - Arguments to delete one TransactionWhatsappService.
     * @example
     * // Delete one TransactionWhatsappService
     * const TransactionWhatsappService = await prisma.transactionWhatsappService.delete({
     *   where: {
     *     // ... filter to delete one TransactionWhatsappService
     *   }
     * })
     * 
     */
    delete<T extends TransactionWhatsappServiceDeleteArgs>(args: SelectSubset<T, TransactionWhatsappServiceDeleteArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionWhatsappService.
     * @param {TransactionWhatsappServiceUpdateArgs} args - Arguments to update one TransactionWhatsappService.
     * @example
     * // Update one TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionWhatsappServiceUpdateArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionWhatsappServices.
     * @param {TransactionWhatsappServiceDeleteManyArgs} args - Arguments to filter TransactionWhatsappServices to delete.
     * @example
     * // Delete a few TransactionWhatsappServices
     * const { count } = await prisma.transactionWhatsappService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionWhatsappServiceDeleteManyArgs>(args?: SelectSubset<T, TransactionWhatsappServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionWhatsappServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionWhatsappServiceUpdateManyArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionWhatsappServices and returns the data updated in the database.
     * @param {TransactionWhatsappServiceUpdateManyAndReturnArgs} args - Arguments to update many TransactionWhatsappServices.
     * @example
     * // Update many TransactionWhatsappServices
     * const transactionWhatsappService = await prisma.transactionWhatsappService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionWhatsappServices and only return the `id`
     * const transactionWhatsappServiceWithIdOnly = await prisma.transactionWhatsappService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionWhatsappServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionWhatsappService.
     * @param {TransactionWhatsappServiceUpsertArgs} args - Arguments to update or create a TransactionWhatsappService.
     * @example
     * // Update or create a TransactionWhatsappService
     * const transactionWhatsappService = await prisma.transactionWhatsappService.upsert({
     *   create: {
     *     // ... data to create a TransactionWhatsappService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionWhatsappService we want to update
     *   }
     * })
     */
    upsert<T extends TransactionWhatsappServiceUpsertArgs>(args: SelectSubset<T, TransactionWhatsappServiceUpsertArgs<ExtArgs>>): Prisma__TransactionWhatsappServiceClient<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionWhatsappServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceCountArgs} args - Arguments to filter TransactionWhatsappServices to count.
     * @example
     * // Count the number of TransactionWhatsappServices
     * const count = await prisma.transactionWhatsappService.count({
     *   where: {
     *     // ... the filter for the TransactionWhatsappServices we want to count
     *   }
     * })
    **/
    count<T extends TransactionWhatsappServiceCountArgs>(
      args?: Subset<T, TransactionWhatsappServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionWhatsappServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionWhatsappService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionWhatsappServiceAggregateArgs>(args: Subset<T, TransactionWhatsappServiceAggregateArgs>): Prisma.PrismaPromise<GetTransactionWhatsappServiceAggregateType<T>>

    /**
     * Group by TransactionWhatsappService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionWhatsappServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionWhatsappServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionWhatsappServiceGroupByArgs['orderBy'] }
        : { orderBy?: TransactionWhatsappServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionWhatsappServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionWhatsappServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionWhatsappService model
   */
  readonly fields: TransactionWhatsappServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionWhatsappService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionWhatsappServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    whatsappPackage<T extends WhatsappApiPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackageDefaultArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionWhatsappService model
   */
  interface TransactionWhatsappServiceFieldRefs {
    readonly id: FieldRef<"TransactionWhatsappService", 'String'>
    readonly transactionId: FieldRef<"TransactionWhatsappService", 'String'>
    readonly whatsappPackageId: FieldRef<"TransactionWhatsappService", 'String'>
    readonly duration: FieldRef<"TransactionWhatsappService", 'String'>
    readonly status: FieldRef<"TransactionWhatsappService", 'String'>
    readonly startDate: FieldRef<"TransactionWhatsappService", 'DateTime'>
    readonly endDate: FieldRef<"TransactionWhatsappService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionWhatsappService findUnique
   */
  export type TransactionWhatsappServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService findUniqueOrThrow
   */
  export type TransactionWhatsappServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService findFirst
   */
  export type TransactionWhatsappServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionWhatsappServices.
     */
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService findFirstOrThrow
   */
  export type TransactionWhatsappServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappService to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionWhatsappServices.
     */
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService findMany
   */
  export type TransactionWhatsappServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter, which TransactionWhatsappServices to fetch.
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionWhatsappServices to fetch.
     */
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionWhatsappServices.
     */
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionWhatsappServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionWhatsappServices.
     */
    skip?: number
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * TransactionWhatsappService create
   */
  export type TransactionWhatsappServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionWhatsappService.
     */
    data: XOR<TransactionWhatsappServiceCreateInput, TransactionWhatsappServiceUncheckedCreateInput>
  }

  /**
   * TransactionWhatsappService createMany
   */
  export type TransactionWhatsappServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionWhatsappServices.
     */
    data: TransactionWhatsappServiceCreateManyInput | TransactionWhatsappServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionWhatsappService createManyAndReturn
   */
  export type TransactionWhatsappServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionWhatsappServices.
     */
    data: TransactionWhatsappServiceCreateManyInput | TransactionWhatsappServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionWhatsappService update
   */
  export type TransactionWhatsappServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionWhatsappService.
     */
    data: XOR<TransactionWhatsappServiceUpdateInput, TransactionWhatsappServiceUncheckedUpdateInput>
    /**
     * Choose, which TransactionWhatsappService to update.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService updateMany
   */
  export type TransactionWhatsappServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionWhatsappServices.
     */
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyInput>
    /**
     * Filter which TransactionWhatsappServices to update
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to update.
     */
    limit?: number
  }

  /**
   * TransactionWhatsappService updateManyAndReturn
   */
  export type TransactionWhatsappServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * The data used to update TransactionWhatsappServices.
     */
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyInput>
    /**
     * Filter which TransactionWhatsappServices to update
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionWhatsappService upsert
   */
  export type TransactionWhatsappServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionWhatsappService to update in case it exists.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
    /**
     * In case the TransactionWhatsappService found by the `where` argument doesn't exist, create a new TransactionWhatsappService with this data.
     */
    create: XOR<TransactionWhatsappServiceCreateInput, TransactionWhatsappServiceUncheckedCreateInput>
    /**
     * In case the TransactionWhatsappService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionWhatsappServiceUpdateInput, TransactionWhatsappServiceUncheckedUpdateInput>
  }

  /**
   * TransactionWhatsappService delete
   */
  export type TransactionWhatsappServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    /**
     * Filter which TransactionWhatsappService to delete.
     */
    where: TransactionWhatsappServiceWhereUniqueInput
  }

  /**
   * TransactionWhatsappService deleteMany
   */
  export type TransactionWhatsappServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionWhatsappServices to delete
     */
    where?: TransactionWhatsappServiceWhereInput
    /**
     * Limit how many TransactionWhatsappServices to delete.
     */
    limit?: number
  }

  /**
   * TransactionWhatsappService without action
   */
  export type TransactionWhatsappServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
    serviceFee: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
    serviceFee: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    amount: Decimal | null
    method: string | null
    status: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    transactionId: number
    amount: number
    method: number
    status: number
    paymentDate: number
    createdAt: number
    updatedAt: number
    expiresAt: number
    externalId: number
    paymentUrl: number
    serviceFee: number
    adminNotes: number
    adminAction: number
    adminUserId: number
    actionDate: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    serviceFee?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    serviceFee?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    transactionId?: true
    amount?: true
    method?: true
    status?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    expiresAt?: true
    externalId?: true
    paymentUrl?: true
    serviceFee?: true
    adminNotes?: true
    adminAction?: true
    adminUserId?: true
    actionDate?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    transactionId: string | null
    amount: Decimal
    method: string
    status: string
    paymentDate: Date | null
    createdAt: Date
    updatedAt: Date
    expiresAt: Date | null
    externalId: string | null
    paymentUrl: string | null
    serviceFee: Decimal | null
    adminNotes: string | null
    adminAction: string | null
    adminUserId: string | null
    actionDate: Date | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    transactionId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expiresAt?: boolean
    externalId?: boolean
    paymentUrl?: boolean
    serviceFee?: boolean
    adminNotes?: boolean
    adminAction?: boolean
    adminUserId?: boolean
    actionDate?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "amount" | "method" | "status" | "paymentDate" | "createdAt" | "updatedAt" | "expiresAt" | "externalId" | "paymentUrl" | "serviceFee" | "adminNotes" | "adminAction" | "adminUserId" | "actionDate", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Payment$transactionArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string | null
      amount: Prisma.Decimal
      method: string
      status: string
      paymentDate: Date | null
      createdAt: Date
      updatedAt: Date
      expiresAt: Date | null
      externalId: string | null
      paymentUrl: string | null
      serviceFee: Prisma.Decimal | null
      adminNotes: string | null
      adminAction: string | null
      adminUserId: string | null
      actionDate: Date | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends Payment$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Payment$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
    readonly expiresAt: FieldRef<"Payment", 'DateTime'>
    readonly externalId: FieldRef<"Payment", 'String'>
    readonly paymentUrl: FieldRef<"Payment", 'String'>
    readonly serviceFee: FieldRef<"Payment", 'Decimal'>
    readonly adminNotes: FieldRef<"Payment", 'String'>
    readonly adminAction: FieldRef<"Payment", 'String'>
    readonly adminUserId: FieldRef<"Payment", 'String'>
    readonly actionDate: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.transaction
   */
  export type Payment$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model WhatsappApiPackage
   */

  export type AggregateWhatsappApiPackage = {
    _count: WhatsappApiPackageCountAggregateOutputType | null
    _avg: WhatsappApiPackageAvgAggregateOutputType | null
    _sum: WhatsappApiPackageSumAggregateOutputType | null
    _min: WhatsappApiPackageMinAggregateOutputType | null
    _max: WhatsappApiPackageMaxAggregateOutputType | null
  }

  export type WhatsappApiPackageAvgAggregateOutputType = {
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
  }

  export type WhatsappApiPackageSumAggregateOutputType = {
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
  }

  export type WhatsappApiPackageMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappApiPackageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    priceMonth: number | null
    priceYear: number | null
    maxSession: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsappApiPackageCountAggregateOutputType = {
    id: number
    name: number
    description: number
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsappApiPackageAvgAggregateInputType = {
    priceMonth?: true
    priceYear?: true
    maxSession?: true
  }

  export type WhatsappApiPackageSumAggregateInputType = {
    priceMonth?: true
    priceYear?: true
    maxSession?: true
  }

  export type WhatsappApiPackageMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappApiPackageMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsappApiPackageCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    priceMonth?: true
    priceYear?: true
    maxSession?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsappApiPackageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappApiPackage to aggregate.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsappApiPackages
    **/
    _count?: true | WhatsappApiPackageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsappApiPackageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsappApiPackageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsappApiPackageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsappApiPackageMaxAggregateInputType
  }

  export type GetWhatsappApiPackageAggregateType<T extends WhatsappApiPackageAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsappApiPackage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsappApiPackage[P]>
      : GetScalarType<T[P], AggregateWhatsappApiPackage[P]>
  }




  export type WhatsappApiPackageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsappApiPackageWhereInput
    orderBy?: WhatsappApiPackageOrderByWithAggregationInput | WhatsappApiPackageOrderByWithAggregationInput[]
    by: WhatsappApiPackageScalarFieldEnum[] | WhatsappApiPackageScalarFieldEnum
    having?: WhatsappApiPackageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsappApiPackageCountAggregateInputType | true
    _avg?: WhatsappApiPackageAvgAggregateInputType
    _sum?: WhatsappApiPackageSumAggregateInputType
    _min?: WhatsappApiPackageMinAggregateInputType
    _max?: WhatsappApiPackageMaxAggregateInputType
  }

  export type WhatsappApiPackageGroupByOutputType = {
    id: string
    name: string
    description: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt: Date
    updatedAt: Date
    _count: WhatsappApiPackageCountAggregateOutputType | null
    _avg: WhatsappApiPackageAvgAggregateOutputType | null
    _sum: WhatsappApiPackageSumAggregateOutputType | null
    _min: WhatsappApiPackageMinAggregateOutputType | null
    _max: WhatsappApiPackageMaxAggregateOutputType | null
  }

  type GetWhatsappApiPackageGroupByPayload<T extends WhatsappApiPackageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsappApiPackageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsappApiPackageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsappApiPackageGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsappApiPackageGroupByOutputType[P]>
        }
      >
    >


  export type WhatsappApiPackageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    whatsappTransactions?: boolean | WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>
    whatsappCustomers?: boolean | WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>
    _count?: boolean | WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["whatsappApiPackage"]>

  export type WhatsappApiPackageSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    priceMonth?: boolean
    priceYear?: boolean
    maxSession?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsappApiPackageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "priceMonth" | "priceYear" | "maxSession" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsappApiPackage"]>
  export type WhatsappApiPackageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsappTransactions?: boolean | WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>
    whatsappCustomers?: boolean | WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>
    _count?: boolean | WhatsappApiPackageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WhatsappApiPackageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WhatsappApiPackageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WhatsappApiPackagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsappApiPackage"
    objects: {
      whatsappTransactions: Prisma.$TransactionWhatsappServicePayload<ExtArgs>[]
      whatsappCustomers: Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      priceMonth: number
      priceYear: number
      maxSession: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsappApiPackage"]>
    composites: {}
  }

  type WhatsappApiPackageGetPayload<S extends boolean | null | undefined | WhatsappApiPackageDefaultArgs> = $Result.GetResult<Prisma.$WhatsappApiPackagePayload, S>

  type WhatsappApiPackageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsappApiPackageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsappApiPackageCountAggregateInputType | true
    }

  export interface WhatsappApiPackageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsappApiPackage'], meta: { name: 'WhatsappApiPackage' } }
    /**
     * Find zero or one WhatsappApiPackage that matches the filter.
     * @param {WhatsappApiPackageFindUniqueArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsappApiPackageFindUniqueArgs>(args: SelectSubset<T, WhatsappApiPackageFindUniqueArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsappApiPackage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsappApiPackageFindUniqueOrThrowArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsappApiPackageFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappApiPackage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindFirstArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsappApiPackageFindFirstArgs>(args?: SelectSubset<T, WhatsappApiPackageFindFirstArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsappApiPackage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindFirstOrThrowArgs} args - Arguments to find a WhatsappApiPackage
     * @example
     * // Get one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsappApiPackageFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsappApiPackages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsappApiPackages
     * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany()
     * 
     * // Get first 10 WhatsappApiPackages
     * const whatsappApiPackages = await prisma.whatsappApiPackage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsappApiPackageFindManyArgs>(args?: SelectSubset<T, WhatsappApiPackageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsappApiPackage.
     * @param {WhatsappApiPackageCreateArgs} args - Arguments to create a WhatsappApiPackage.
     * @example
     * // Create one WhatsappApiPackage
     * const WhatsappApiPackage = await prisma.whatsappApiPackage.create({
     *   data: {
     *     // ... data to create a WhatsappApiPackage
     *   }
     * })
     * 
     */
    create<T extends WhatsappApiPackageCreateArgs>(args: SelectSubset<T, WhatsappApiPackageCreateArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsappApiPackages.
     * @param {WhatsappApiPackageCreateManyArgs} args - Arguments to create many WhatsappApiPackages.
     * @example
     * // Create many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsappApiPackageCreateManyArgs>(args?: SelectSubset<T, WhatsappApiPackageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsappApiPackages and returns the data saved in the database.
     * @param {WhatsappApiPackageCreateManyAndReturnArgs} args - Arguments to create many WhatsappApiPackages.
     * @example
     * // Create many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsappApiPackages and only return the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsappApiPackageCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsappApiPackage.
     * @param {WhatsappApiPackageDeleteArgs} args - Arguments to delete one WhatsappApiPackage.
     * @example
     * // Delete one WhatsappApiPackage
     * const WhatsappApiPackage = await prisma.whatsappApiPackage.delete({
     *   where: {
     *     // ... filter to delete one WhatsappApiPackage
     *   }
     * })
     * 
     */
    delete<T extends WhatsappApiPackageDeleteArgs>(args: SelectSubset<T, WhatsappApiPackageDeleteArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsappApiPackage.
     * @param {WhatsappApiPackageUpdateArgs} args - Arguments to update one WhatsappApiPackage.
     * @example
     * // Update one WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsappApiPackageUpdateArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsappApiPackages.
     * @param {WhatsappApiPackageDeleteManyArgs} args - Arguments to filter WhatsappApiPackages to delete.
     * @example
     * // Delete a few WhatsappApiPackages
     * const { count } = await prisma.whatsappApiPackage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsappApiPackageDeleteManyArgs>(args?: SelectSubset<T, WhatsappApiPackageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappApiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsappApiPackageUpdateManyArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsappApiPackages and returns the data updated in the database.
     * @param {WhatsappApiPackageUpdateManyAndReturnArgs} args - Arguments to update many WhatsappApiPackages.
     * @example
     * // Update many WhatsappApiPackages
     * const whatsappApiPackage = await prisma.whatsappApiPackage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsappApiPackages and only return the `id`
     * const whatsappApiPackageWithIdOnly = await prisma.whatsappApiPackage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsappApiPackageUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsappApiPackage.
     * @param {WhatsappApiPackageUpsertArgs} args - Arguments to update or create a WhatsappApiPackage.
     * @example
     * // Update or create a WhatsappApiPackage
     * const whatsappApiPackage = await prisma.whatsappApiPackage.upsert({
     *   create: {
     *     // ... data to create a WhatsappApiPackage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsappApiPackage we want to update
     *   }
     * })
     */
    upsert<T extends WhatsappApiPackageUpsertArgs>(args: SelectSubset<T, WhatsappApiPackageUpsertArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsappApiPackages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageCountArgs} args - Arguments to filter WhatsappApiPackages to count.
     * @example
     * // Count the number of WhatsappApiPackages
     * const count = await prisma.whatsappApiPackage.count({
     *   where: {
     *     // ... the filter for the WhatsappApiPackages we want to count
     *   }
     * })
    **/
    count<T extends WhatsappApiPackageCountArgs>(
      args?: Subset<T, WhatsappApiPackageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsappApiPackageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsappApiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsappApiPackageAggregateArgs>(args: Subset<T, WhatsappApiPackageAggregateArgs>): Prisma.PrismaPromise<GetWhatsappApiPackageAggregateType<T>>

    /**
     * Group by WhatsappApiPackage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsappApiPackageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsappApiPackageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsappApiPackageGroupByArgs['orderBy'] }
        : { orderBy?: WhatsappApiPackageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsappApiPackageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsappApiPackageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsappApiPackage model
   */
  readonly fields: WhatsappApiPackageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsappApiPackage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsappApiPackageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsappTransactions<T extends WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionWhatsappServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappCustomers<T extends WhatsappApiPackage$whatsappCustomersArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackage$whatsappCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsappApiPackage model
   */
  interface WhatsappApiPackageFieldRefs {
    readonly id: FieldRef<"WhatsappApiPackage", 'String'>
    readonly name: FieldRef<"WhatsappApiPackage", 'String'>
    readonly description: FieldRef<"WhatsappApiPackage", 'String'>
    readonly priceMonth: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly priceYear: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly maxSession: FieldRef<"WhatsappApiPackage", 'Int'>
    readonly createdAt: FieldRef<"WhatsappApiPackage", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsappApiPackage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsappApiPackage findUnique
   */
  export type WhatsappApiPackageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage findUniqueOrThrow
   */
  export type WhatsappApiPackageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage findFirst
   */
  export type WhatsappApiPackageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappApiPackages.
     */
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage findFirstOrThrow
   */
  export type WhatsappApiPackageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackage to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsappApiPackages.
     */
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage findMany
   */
  export type WhatsappApiPackageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter, which WhatsappApiPackages to fetch.
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsappApiPackages to fetch.
     */
    orderBy?: WhatsappApiPackageOrderByWithRelationInput | WhatsappApiPackageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsappApiPackages.
     */
    cursor?: WhatsappApiPackageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsappApiPackages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsappApiPackages.
     */
    skip?: number
    distinct?: WhatsappApiPackageScalarFieldEnum | WhatsappApiPackageScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage create
   */
  export type WhatsappApiPackageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsappApiPackage.
     */
    data: XOR<WhatsappApiPackageCreateInput, WhatsappApiPackageUncheckedCreateInput>
  }

  /**
   * WhatsappApiPackage createMany
   */
  export type WhatsappApiPackageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsappApiPackages.
     */
    data: WhatsappApiPackageCreateManyInput | WhatsappApiPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappApiPackage createManyAndReturn
   */
  export type WhatsappApiPackageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsappApiPackages.
     */
    data: WhatsappApiPackageCreateManyInput | WhatsappApiPackageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsappApiPackage update
   */
  export type WhatsappApiPackageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsappApiPackage.
     */
    data: XOR<WhatsappApiPackageUpdateInput, WhatsappApiPackageUncheckedUpdateInput>
    /**
     * Choose, which WhatsappApiPackage to update.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage updateMany
   */
  export type WhatsappApiPackageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsappApiPackages.
     */
    data: XOR<WhatsappApiPackageUpdateManyMutationInput, WhatsappApiPackageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappApiPackages to update
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to update.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage updateManyAndReturn
   */
  export type WhatsappApiPackageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * The data used to update WhatsappApiPackages.
     */
    data: XOR<WhatsappApiPackageUpdateManyMutationInput, WhatsappApiPackageUncheckedUpdateManyInput>
    /**
     * Filter which WhatsappApiPackages to update
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to update.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage upsert
   */
  export type WhatsappApiPackageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsappApiPackage to update in case it exists.
     */
    where: WhatsappApiPackageWhereUniqueInput
    /**
     * In case the WhatsappApiPackage found by the `where` argument doesn't exist, create a new WhatsappApiPackage with this data.
     */
    create: XOR<WhatsappApiPackageCreateInput, WhatsappApiPackageUncheckedCreateInput>
    /**
     * In case the WhatsappApiPackage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsappApiPackageUpdateInput, WhatsappApiPackageUncheckedUpdateInput>
  }

  /**
   * WhatsappApiPackage delete
   */
  export type WhatsappApiPackageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
    /**
     * Filter which WhatsappApiPackage to delete.
     */
    where: WhatsappApiPackageWhereUniqueInput
  }

  /**
   * WhatsappApiPackage deleteMany
   */
  export type WhatsappApiPackageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsappApiPackages to delete
     */
    where?: WhatsappApiPackageWhereInput
    /**
     * Limit how many WhatsappApiPackages to delete.
     */
    limit?: number
  }

  /**
   * WhatsappApiPackage.whatsappTransactions
   */
  export type WhatsappApiPackage$whatsappTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionWhatsappService
     */
    select?: TransactionWhatsappServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionWhatsappService
     */
    omit?: TransactionWhatsappServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionWhatsappServiceInclude<ExtArgs> | null
    where?: TransactionWhatsappServiceWhereInput
    orderBy?: TransactionWhatsappServiceOrderByWithRelationInput | TransactionWhatsappServiceOrderByWithRelationInput[]
    cursor?: TransactionWhatsappServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionWhatsappServiceScalarFieldEnum | TransactionWhatsappServiceScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage.whatsappCustomers
   */
  export type WhatsappApiPackage$whatsappCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * WhatsappApiPackage without action
   */
  export type WhatsappApiPackageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsappApiPackage
     */
    select?: WhatsappApiPackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsappApiPackage
     */
    omit?: WhatsappApiPackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsappApiPackageInclude<ExtArgs> | null
  }


  /**
   * Model ServicesWhatsappCustomers
   */

  export type AggregateServicesWhatsappCustomers = {
    _count: ServicesWhatsappCustomersCountAggregateOutputType | null
    _min: ServicesWhatsappCustomersMinAggregateOutputType | null
    _max: ServicesWhatsappCustomersMaxAggregateOutputType | null
  }

  export type ServicesWhatsappCustomersMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    packageId: string | null
    sessionId: string | null
    qrCode: string | null
    status: string | null
    expiredAt: Date | null
    activatedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesWhatsappCustomersMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    packageId: string | null
    sessionId: string | null
    qrCode: string | null
    status: string | null
    expiredAt: Date | null
    activatedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesWhatsappCustomersCountAggregateOutputType = {
    id: number
    transactionId: number
    customerId: number
    packageId: number
    sessionId: number
    qrCode: number
    status: number
    expiredAt: number
    activatedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesWhatsappCustomersMinAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    sessionId?: true
    qrCode?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesWhatsappCustomersMaxAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    sessionId?: true
    qrCode?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesWhatsappCustomersCountAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    sessionId?: true
    qrCode?: true
    status?: true
    expiredAt?: true
    activatedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesWhatsappCustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesWhatsappCustomers to aggregate.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicesWhatsappCustomers
    **/
    _count?: true | ServicesWhatsappCustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesWhatsappCustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesWhatsappCustomersMaxAggregateInputType
  }

  export type GetServicesWhatsappCustomersAggregateType<T extends ServicesWhatsappCustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesWhatsappCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesWhatsappCustomers[P]>
      : GetScalarType<T[P], AggregateServicesWhatsappCustomers[P]>
  }




  export type ServicesWhatsappCustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesWhatsappCustomersWhereInput
    orderBy?: ServicesWhatsappCustomersOrderByWithAggregationInput | ServicesWhatsappCustomersOrderByWithAggregationInput[]
    by: ServicesWhatsappCustomersScalarFieldEnum[] | ServicesWhatsappCustomersScalarFieldEnum
    having?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesWhatsappCustomersCountAggregateInputType | true
    _min?: ServicesWhatsappCustomersMinAggregateInputType
    _max?: ServicesWhatsappCustomersMaxAggregateInputType
  }

  export type ServicesWhatsappCustomersGroupByOutputType = {
    id: string
    transactionId: string
    customerId: string
    packageId: string
    sessionId: string | null
    qrCode: string | null
    status: string
    expiredAt: Date
    activatedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesWhatsappCustomersCountAggregateOutputType | null
    _min: ServicesWhatsappCustomersMinAggregateOutputType | null
    _max: ServicesWhatsappCustomersMaxAggregateOutputType | null
  }

  type GetServicesWhatsappCustomersGroupByPayload<T extends ServicesWhatsappCustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesWhatsappCustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesWhatsappCustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesWhatsappCustomersGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesWhatsappCustomersGroupByOutputType[P]>
        }
      >
    >


  export type ServicesWhatsappCustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    sessionId?: boolean
    qrCode?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    sessionId?: boolean
    qrCode?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    sessionId?: boolean
    qrCode?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesWhatsappCustomers"]>

  export type ServicesWhatsappCustomersSelectScalar = {
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    sessionId?: boolean
    qrCode?: boolean
    status?: boolean
    expiredAt?: boolean
    activatedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicesWhatsappCustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "customerId" | "packageId" | "sessionId" | "qrCode" | "status" | "expiredAt" | "activatedAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["servicesWhatsappCustomers"]>
  export type ServicesWhatsappCustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type ServicesWhatsappCustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }
  export type ServicesWhatsappCustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | WhatsappApiPackageDefaultArgs<ExtArgs>
  }

  export type $ServicesWhatsappCustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicesWhatsappCustomers"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
      package: Prisma.$WhatsappApiPackagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      customerId: string
      packageId: string
      sessionId: string | null
      qrCode: string | null
      status: string
      expiredAt: Date
      activatedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicesWhatsappCustomers"]>
    composites: {}
  }

  type ServicesWhatsappCustomersGetPayload<S extends boolean | null | undefined | ServicesWhatsappCustomersDefaultArgs> = $Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload, S>

  type ServicesWhatsappCustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesWhatsappCustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesWhatsappCustomersCountAggregateInputType | true
    }

  export interface ServicesWhatsappCustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicesWhatsappCustomers'], meta: { name: 'ServicesWhatsappCustomers' } }
    /**
     * Find zero or one ServicesWhatsappCustomers that matches the filter.
     * @param {ServicesWhatsappCustomersFindUniqueArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesWhatsappCustomersFindUniqueArgs>(args: SelectSubset<T, ServicesWhatsappCustomersFindUniqueArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicesWhatsappCustomers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesWhatsappCustomersFindUniqueOrThrowArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesWhatsappCustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesWhatsappCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindFirstArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesWhatsappCustomersFindFirstArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindFirstArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesWhatsappCustomers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindFirstOrThrowArgs} args - Arguments to find a ServicesWhatsappCustomers
     * @example
     * // Get one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesWhatsappCustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicesWhatsappCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany()
     * 
     * // Get first 10 ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesWhatsappCustomersFindManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersCreateArgs} args - Arguments to create a ServicesWhatsappCustomers.
     * @example
     * // Create one ServicesWhatsappCustomers
     * const ServicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.create({
     *   data: {
     *     // ... data to create a ServicesWhatsappCustomers
     *   }
     * })
     * 
     */
    create<T extends ServicesWhatsappCustomersCreateArgs>(args: SelectSubset<T, ServicesWhatsappCustomersCreateArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersCreateManyArgs} args - Arguments to create many ServicesWhatsappCustomers.
     * @example
     * // Create many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesWhatsappCustomersCreateManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicesWhatsappCustomers and returns the data saved in the database.
     * @param {ServicesWhatsappCustomersCreateManyAndReturnArgs} args - Arguments to create many ServicesWhatsappCustomers.
     * @example
     * // Create many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicesWhatsappCustomers and only return the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesWhatsappCustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersDeleteArgs} args - Arguments to delete one ServicesWhatsappCustomers.
     * @example
     * // Delete one ServicesWhatsappCustomers
     * const ServicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.delete({
     *   where: {
     *     // ... filter to delete one ServicesWhatsappCustomers
     *   }
     * })
     * 
     */
    delete<T extends ServicesWhatsappCustomersDeleteArgs>(args: SelectSubset<T, ServicesWhatsappCustomersDeleteArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersUpdateArgs} args - Arguments to update one ServicesWhatsappCustomers.
     * @example
     * // Update one ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesWhatsappCustomersUpdateArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersDeleteManyArgs} args - Arguments to filter ServicesWhatsappCustomers to delete.
     * @example
     * // Delete a few ServicesWhatsappCustomers
     * const { count } = await prisma.servicesWhatsappCustomers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesWhatsappCustomersDeleteManyArgs>(args?: SelectSubset<T, ServicesWhatsappCustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesWhatsappCustomersUpdateManyArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesWhatsappCustomers and returns the data updated in the database.
     * @param {ServicesWhatsappCustomersUpdateManyAndReturnArgs} args - Arguments to update many ServicesWhatsappCustomers.
     * @example
     * // Update many ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicesWhatsappCustomers and only return the `id`
     * const servicesWhatsappCustomersWithIdOnly = await prisma.servicesWhatsappCustomers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesWhatsappCustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicesWhatsappCustomers.
     * @param {ServicesWhatsappCustomersUpsertArgs} args - Arguments to update or create a ServicesWhatsappCustomers.
     * @example
     * // Update or create a ServicesWhatsappCustomers
     * const servicesWhatsappCustomers = await prisma.servicesWhatsappCustomers.upsert({
     *   create: {
     *     // ... data to create a ServicesWhatsappCustomers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicesWhatsappCustomers we want to update
     *   }
     * })
     */
    upsert<T extends ServicesWhatsappCustomersUpsertArgs>(args: SelectSubset<T, ServicesWhatsappCustomersUpsertArgs<ExtArgs>>): Prisma__ServicesWhatsappCustomersClient<$Result.GetResult<Prisma.$ServicesWhatsappCustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersCountArgs} args - Arguments to filter ServicesWhatsappCustomers to count.
     * @example
     * // Count the number of ServicesWhatsappCustomers
     * const count = await prisma.servicesWhatsappCustomers.count({
     *   where: {
     *     // ... the filter for the ServicesWhatsappCustomers we want to count
     *   }
     * })
    **/
    count<T extends ServicesWhatsappCustomersCountArgs>(
      args?: Subset<T, ServicesWhatsappCustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesWhatsappCustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesWhatsappCustomersAggregateArgs>(args: Subset<T, ServicesWhatsappCustomersAggregateArgs>): Prisma.PrismaPromise<GetServicesWhatsappCustomersAggregateType<T>>

    /**
     * Group by ServicesWhatsappCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesWhatsappCustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesWhatsappCustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesWhatsappCustomersGroupByArgs['orderBy'] }
        : { orderBy?: ServicesWhatsappCustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesWhatsappCustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesWhatsappCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicesWhatsappCustomers model
   */
  readonly fields: ServicesWhatsappCustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicesWhatsappCustomers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesWhatsappCustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    package<T extends WhatsappApiPackageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsappApiPackageDefaultArgs<ExtArgs>>): Prisma__WhatsappApiPackageClient<$Result.GetResult<Prisma.$WhatsappApiPackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicesWhatsappCustomers model
   */
  interface ServicesWhatsappCustomersFieldRefs {
    readonly id: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly transactionId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly customerId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly packageId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly sessionId: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly qrCode: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly status: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly expiredAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly activatedAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly notes: FieldRef<"ServicesWhatsappCustomers", 'String'>
    readonly createdAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicesWhatsappCustomers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicesWhatsappCustomers findUnique
   */
  export type ServicesWhatsappCustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers findUniqueOrThrow
   */
  export type ServicesWhatsappCustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers findFirst
   */
  export type ServicesWhatsappCustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesWhatsappCustomers.
     */
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers findFirstOrThrow
   */
  export type ServicesWhatsappCustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesWhatsappCustomers.
     */
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers findMany
   */
  export type ServicesWhatsappCustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesWhatsappCustomers to fetch.
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesWhatsappCustomers to fetch.
     */
    orderBy?: ServicesWhatsappCustomersOrderByWithRelationInput | ServicesWhatsappCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicesWhatsappCustomers.
     */
    cursor?: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesWhatsappCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesWhatsappCustomers.
     */
    skip?: number
    distinct?: ServicesWhatsappCustomersScalarFieldEnum | ServicesWhatsappCustomersScalarFieldEnum[]
  }

  /**
   * ServicesWhatsappCustomers create
   */
  export type ServicesWhatsappCustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersCreateInput, ServicesWhatsappCustomersUncheckedCreateInput>
  }

  /**
   * ServicesWhatsappCustomers createMany
   */
  export type ServicesWhatsappCustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicesWhatsappCustomers.
     */
    data: ServicesWhatsappCustomersCreateManyInput | ServicesWhatsappCustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicesWhatsappCustomers createManyAndReturn
   */
  export type ServicesWhatsappCustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * The data used to create many ServicesWhatsappCustomers.
     */
    data: ServicesWhatsappCustomersCreateManyInput | ServicesWhatsappCustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesWhatsappCustomers update
   */
  export type ServicesWhatsappCustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateInput, ServicesWhatsappCustomersUncheckedUpdateInput>
    /**
     * Choose, which ServicesWhatsappCustomers to update.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers updateMany
   */
  export type ServicesWhatsappCustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesWhatsappCustomers to update
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to update.
     */
    limit?: number
  }

  /**
   * ServicesWhatsappCustomers updateManyAndReturn
   */
  export type ServicesWhatsappCustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * The data used to update ServicesWhatsappCustomers.
     */
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesWhatsappCustomers to update
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesWhatsappCustomers upsert
   */
  export type ServicesWhatsappCustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicesWhatsappCustomers to update in case it exists.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
    /**
     * In case the ServicesWhatsappCustomers found by the `where` argument doesn't exist, create a new ServicesWhatsappCustomers with this data.
     */
    create: XOR<ServicesWhatsappCustomersCreateInput, ServicesWhatsappCustomersUncheckedCreateInput>
    /**
     * In case the ServicesWhatsappCustomers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesWhatsappCustomersUpdateInput, ServicesWhatsappCustomersUncheckedUpdateInput>
  }

  /**
   * ServicesWhatsappCustomers delete
   */
  export type ServicesWhatsappCustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
    /**
     * Filter which ServicesWhatsappCustomers to delete.
     */
    where: ServicesWhatsappCustomersWhereUniqueInput
  }

  /**
   * ServicesWhatsappCustomers deleteMany
   */
  export type ServicesWhatsappCustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesWhatsappCustomers to delete
     */
    where?: ServicesWhatsappCustomersWhereInput
    /**
     * Limit how many ServicesWhatsappCustomers to delete.
     */
    limit?: number
  }

  /**
   * ServicesWhatsappCustomers without action
   */
  export type ServicesWhatsappCustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesWhatsappCustomers
     */
    select?: ServicesWhatsappCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesWhatsappCustomers
     */
    omit?: ServicesWhatsappCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesWhatsappCustomersInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserSessionMaxAggregateOutputType = {
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    lastUsed: Date | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserSessionCountAggregateOutputType = {
    userId: number
    token: number
    deviceInfo: number
    ipAddress: number
    userAgent: number
    isActive: number
    lastUsed: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserSessionMaxAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserSessionCountAggregateInputType = {
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    lastUsed?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    userId: string
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean
    lastUsed: Date
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    id: string
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    lastUsed?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "token" | "deviceInfo" | "ipAddress" | "userAgent" | "isActive" | "lastUsed" | "expiresAt" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      userAgent: string | null
      isActive: boolean
      lastUsed: Date
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `userId`
     * const userSessionWithUserIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly lastUsed: FieldRef<"UserSession", 'DateTime'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
    readonly id: FieldRef<"UserSession", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Voucher
   */

  export type AggregateVoucher = {
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  export type VoucherAvgAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
  }

  export type VoucherSumAggregateOutputType = {
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
  }

  export type VoucherMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    discountType: string | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
    allowMultipleUsePerUser: boolean | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: string | null
    discountType: string | null
    value: Decimal | null
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number | null
    allowMultipleUsePerUser: boolean | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VoucherCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    discountType: number
    value: number
    minAmount: number
    maxDiscount: number
    maxUses: number
    usedCount: number
    allowMultipleUsePerUser: number
    isActive: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VoucherAvgAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
  }

  export type VoucherSumAggregateInputType = {
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
  }

  export type VoucherMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VoucherCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    discountType?: true
    value?: true
    minAmount?: true
    maxDiscount?: true
    maxUses?: true
    usedCount?: true
    allowMultipleUsePerUser?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VoucherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voucher to aggregate.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vouchers
    **/
    _count?: true | VoucherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherMaxAggregateInputType
  }

  export type GetVoucherAggregateType<T extends VoucherAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucher[P]>
      : GetScalarType<T[P], AggregateVoucher[P]>
  }




  export type VoucherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherWhereInput
    orderBy?: VoucherOrderByWithAggregationInput | VoucherOrderByWithAggregationInput[]
    by: VoucherScalarFieldEnum[] | VoucherScalarFieldEnum
    having?: VoucherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherCountAggregateInputType | true
    _avg?: VoucherAvgAggregateInputType
    _sum?: VoucherSumAggregateInputType
    _min?: VoucherMinAggregateInputType
    _max?: VoucherMaxAggregateInputType
  }

  export type VoucherGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: string
    discountType: string
    value: Decimal
    minAmount: Decimal | null
    maxDiscount: Decimal | null
    maxUses: number | null
    usedCount: number
    allowMultipleUsePerUser: boolean
    isActive: boolean
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VoucherCountAggregateOutputType | null
    _avg: VoucherAvgAggregateOutputType | null
    _sum: VoucherSumAggregateOutputType | null
    _min: VoucherMinAggregateOutputType | null
    _max: VoucherMaxAggregateOutputType | null
  }

  type GetVoucherGroupByPayload<T extends VoucherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherGroupByOutputType[P]>
        }
      >
    >


  export type VoucherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | Voucher$transactionsArgs<ExtArgs>
    voucherUsage?: boolean | Voucher$voucherUsageArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["voucher"]>

  export type VoucherSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    discountType?: boolean
    value?: boolean
    minAmount?: boolean
    maxDiscount?: boolean
    maxUses?: boolean
    usedCount?: boolean
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VoucherOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "type" | "discountType" | "value" | "minAmount" | "maxDiscount" | "maxUses" | "usedCount" | "allowMultipleUsePerUser" | "isActive" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["voucher"]>
  export type VoucherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | Voucher$transactionsArgs<ExtArgs>
    voucherUsage?: boolean | Voucher$voucherUsageArgs<ExtArgs>
    _count?: boolean | VoucherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VoucherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VoucherIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VoucherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voucher"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      voucherUsage: Prisma.$VoucherUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: string
      discountType: string
      value: Prisma.Decimal
      minAmount: Prisma.Decimal | null
      maxDiscount: Prisma.Decimal | null
      maxUses: number | null
      usedCount: number
      allowMultipleUsePerUser: boolean
      isActive: boolean
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["voucher"]>
    composites: {}
  }

  type VoucherGetPayload<S extends boolean | null | undefined | VoucherDefaultArgs> = $Result.GetResult<Prisma.$VoucherPayload, S>

  type VoucherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherCountAggregateInputType | true
    }

  export interface VoucherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voucher'], meta: { name: 'Voucher' } }
    /**
     * Find zero or one Voucher that matches the filter.
     * @param {VoucherFindUniqueArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherFindUniqueArgs>(args: SelectSubset<T, VoucherFindUniqueArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voucher that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherFindUniqueOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherFindFirstArgs>(args?: SelectSubset<T, VoucherFindFirstArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voucher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindFirstOrThrowArgs} args - Arguments to find a Voucher
     * @example
     * // Get one Voucher
     * const voucher = await prisma.voucher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vouchers
     * const vouchers = await prisma.voucher.findMany()
     * 
     * // Get first 10 Vouchers
     * const vouchers = await prisma.voucher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherWithIdOnly = await prisma.voucher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherFindManyArgs>(args?: SelectSubset<T, VoucherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voucher.
     * @param {VoucherCreateArgs} args - Arguments to create a Voucher.
     * @example
     * // Create one Voucher
     * const Voucher = await prisma.voucher.create({
     *   data: {
     *     // ... data to create a Voucher
     *   }
     * })
     * 
     */
    create<T extends VoucherCreateArgs>(args: SelectSubset<T, VoucherCreateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vouchers.
     * @param {VoucherCreateManyArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherCreateManyArgs>(args?: SelectSubset<T, VoucherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vouchers and returns the data saved in the database.
     * @param {VoucherCreateManyAndReturnArgs} args - Arguments to create many Vouchers.
     * @example
     * // Create many Vouchers
     * const voucher = await prisma.voucher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voucher.
     * @param {VoucherDeleteArgs} args - Arguments to delete one Voucher.
     * @example
     * // Delete one Voucher
     * const Voucher = await prisma.voucher.delete({
     *   where: {
     *     // ... filter to delete one Voucher
     *   }
     * })
     * 
     */
    delete<T extends VoucherDeleteArgs>(args: SelectSubset<T, VoucherDeleteArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voucher.
     * @param {VoucherUpdateArgs} args - Arguments to update one Voucher.
     * @example
     * // Update one Voucher
     * const voucher = await prisma.voucher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUpdateArgs>(args: SelectSubset<T, VoucherUpdateArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vouchers.
     * @param {VoucherDeleteManyArgs} args - Arguments to filter Vouchers to delete.
     * @example
     * // Delete a few Vouchers
     * const { count } = await prisma.voucher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherDeleteManyArgs>(args?: SelectSubset<T, VoucherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUpdateManyArgs>(args: SelectSubset<T, VoucherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vouchers and returns the data updated in the database.
     * @param {VoucherUpdateManyAndReturnArgs} args - Arguments to update many Vouchers.
     * @example
     * // Update many Vouchers
     * const voucher = await prisma.voucher.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vouchers and only return the `id`
     * const voucherWithIdOnly = await prisma.voucher.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voucher.
     * @param {VoucherUpsertArgs} args - Arguments to update or create a Voucher.
     * @example
     * // Update or create a Voucher
     * const voucher = await prisma.voucher.upsert({
     *   create: {
     *     // ... data to create a Voucher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voucher we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUpsertArgs>(args: SelectSubset<T, VoucherUpsertArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherCountArgs} args - Arguments to filter Vouchers to count.
     * @example
     * // Count the number of Vouchers
     * const count = await prisma.voucher.count({
     *   where: {
     *     // ... the filter for the Vouchers we want to count
     *   }
     * })
    **/
    count<T extends VoucherCountArgs>(
      args?: Subset<T, VoucherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherAggregateArgs>(args: Subset<T, VoucherAggregateArgs>): Prisma.PrismaPromise<GetVoucherAggregateType<T>>

    /**
     * Group by Voucher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherGroupByArgs['orderBy'] }
        : { orderBy?: VoucherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voucher model
   */
  readonly fields: VoucherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voucher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends Voucher$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voucherUsage<T extends Voucher$voucherUsageArgs<ExtArgs> = {}>(args?: Subset<T, Voucher$voucherUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voucher model
   */
  interface VoucherFieldRefs {
    readonly id: FieldRef<"Voucher", 'String'>
    readonly code: FieldRef<"Voucher", 'String'>
    readonly name: FieldRef<"Voucher", 'String'>
    readonly description: FieldRef<"Voucher", 'String'>
    readonly type: FieldRef<"Voucher", 'String'>
    readonly discountType: FieldRef<"Voucher", 'String'>
    readonly value: FieldRef<"Voucher", 'Decimal'>
    readonly minAmount: FieldRef<"Voucher", 'Decimal'>
    readonly maxDiscount: FieldRef<"Voucher", 'Decimal'>
    readonly maxUses: FieldRef<"Voucher", 'Int'>
    readonly usedCount: FieldRef<"Voucher", 'Int'>
    readonly allowMultipleUsePerUser: FieldRef<"Voucher", 'Boolean'>
    readonly isActive: FieldRef<"Voucher", 'Boolean'>
    readonly startDate: FieldRef<"Voucher", 'DateTime'>
    readonly endDate: FieldRef<"Voucher", 'DateTime'>
    readonly createdAt: FieldRef<"Voucher", 'DateTime'>
    readonly updatedAt: FieldRef<"Voucher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Voucher findUnique
   */
  export type VoucherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findUniqueOrThrow
   */
  export type VoucherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher findFirst
   */
  export type VoucherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findFirstOrThrow
   */
  export type VoucherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Voucher to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vouchers.
     */
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher findMany
   */
  export type VoucherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter, which Vouchers to fetch.
     */
    where?: VoucherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vouchers to fetch.
     */
    orderBy?: VoucherOrderByWithRelationInput | VoucherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vouchers.
     */
    cursor?: VoucherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vouchers.
     */
    skip?: number
    distinct?: VoucherScalarFieldEnum | VoucherScalarFieldEnum[]
  }

  /**
   * Voucher create
   */
  export type VoucherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to create a Voucher.
     */
    data: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
  }

  /**
   * Voucher createMany
   */
  export type VoucherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher createManyAndReturn
   */
  export type VoucherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to create many Vouchers.
     */
    data: VoucherCreateManyInput | VoucherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voucher update
   */
  export type VoucherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The data needed to update a Voucher.
     */
    data: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
    /**
     * Choose, which Voucher to update.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher updateMany
   */
  export type VoucherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher updateManyAndReturn
   */
  export type VoucherUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * The data used to update Vouchers.
     */
    data: XOR<VoucherUpdateManyMutationInput, VoucherUncheckedUpdateManyInput>
    /**
     * Filter which Vouchers to update
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to update.
     */
    limit?: number
  }

  /**
   * Voucher upsert
   */
  export type VoucherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * The filter to search for the Voucher to update in case it exists.
     */
    where: VoucherWhereUniqueInput
    /**
     * In case the Voucher found by the `where` argument doesn't exist, create a new Voucher with this data.
     */
    create: XOR<VoucherCreateInput, VoucherUncheckedCreateInput>
    /**
     * In case the Voucher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUpdateInput, VoucherUncheckedUpdateInput>
  }

  /**
   * Voucher delete
   */
  export type VoucherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
    /**
     * Filter which Voucher to delete.
     */
    where: VoucherWhereUniqueInput
  }

  /**
   * Voucher deleteMany
   */
  export type VoucherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vouchers to delete
     */
    where?: VoucherWhereInput
    /**
     * Limit how many Vouchers to delete.
     */
    limit?: number
  }

  /**
   * Voucher.transactions
   */
  export type Voucher$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Voucher.voucherUsage
   */
  export type Voucher$voucherUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    cursor?: VoucherUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * Voucher without action
   */
  export type VoucherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voucher
     */
    select?: VoucherSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voucher
     */
    omit?: VoucherOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherInclude<ExtArgs> | null
  }


  /**
   * Model VoucherUsage
   */

  export type AggregateVoucherUsage = {
    _count: VoucherUsageCountAggregateOutputType | null
    _avg: VoucherUsageAvgAggregateOutputType | null
    _sum: VoucherUsageSumAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  export type VoucherUsageAvgAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VoucherUsageSumAggregateOutputType = {
    discountAmount: Decimal | null
  }

  export type VoucherUsageMinAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    transactionId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type VoucherUsageMaxAggregateOutputType = {
    id: string | null
    voucherId: string | null
    userId: string | null
    transactionId: string | null
    usedAt: Date | null
    discountAmount: Decimal | null
  }

  export type VoucherUsageCountAggregateOutputType = {
    id: number
    voucherId: number
    userId: number
    transactionId: number
    usedAt: number
    discountAmount: number
    _all: number
  }


  export type VoucherUsageAvgAggregateInputType = {
    discountAmount?: true
  }

  export type VoucherUsageSumAggregateInputType = {
    discountAmount?: true
  }

  export type VoucherUsageMinAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type VoucherUsageMaxAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
  }

  export type VoucherUsageCountAggregateInputType = {
    id?: true
    voucherId?: true
    userId?: true
    transactionId?: true
    usedAt?: true
    discountAmount?: true
    _all?: true
  }

  export type VoucherUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsage to aggregate.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VoucherUsages
    **/
    _count?: true | VoucherUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoucherUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoucherUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoucherUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type GetVoucherUsageAggregateType<T extends VoucherUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateVoucherUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoucherUsage[P]>
      : GetScalarType<T[P], AggregateVoucherUsage[P]>
  }




  export type VoucherUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoucherUsageWhereInput
    orderBy?: VoucherUsageOrderByWithAggregationInput | VoucherUsageOrderByWithAggregationInput[]
    by: VoucherUsageScalarFieldEnum[] | VoucherUsageScalarFieldEnum
    having?: VoucherUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoucherUsageCountAggregateInputType | true
    _avg?: VoucherUsageAvgAggregateInputType
    _sum?: VoucherUsageSumAggregateInputType
    _min?: VoucherUsageMinAggregateInputType
    _max?: VoucherUsageMaxAggregateInputType
  }

  export type VoucherUsageGroupByOutputType = {
    id: string
    voucherId: string
    userId: string
    transactionId: string | null
    usedAt: Date
    discountAmount: Decimal
    _count: VoucherUsageCountAggregateOutputType | null
    _avg: VoucherUsageAvgAggregateOutputType | null
    _sum: VoucherUsageSumAggregateOutputType | null
    _min: VoucherUsageMinAggregateOutputType | null
    _max: VoucherUsageMaxAggregateOutputType | null
  }

  type GetVoucherUsageGroupByPayload<T extends VoucherUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoucherUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoucherUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
            : GetScalarType<T[P], VoucherUsageGroupByOutputType[P]>
        }
      >
    >


  export type VoucherUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voucherUsage"]>

  export type VoucherUsageSelectScalar = {
    id?: boolean
    voucherId?: boolean
    userId?: boolean
    transactionId?: boolean
    usedAt?: boolean
    discountAmount?: boolean
  }

  export type VoucherUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "voucherId" | "userId" | "transactionId" | "usedAt" | "discountAmount", ExtArgs["result"]["voucherUsage"]>
  export type VoucherUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }
  export type VoucherUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | VoucherUsage$transactionArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    voucher?: boolean | VoucherDefaultArgs<ExtArgs>
  }

  export type $VoucherUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VoucherUsage"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      voucher: Prisma.$VoucherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      voucherId: string
      userId: string
      transactionId: string | null
      usedAt: Date
      discountAmount: Prisma.Decimal
    }, ExtArgs["result"]["voucherUsage"]>
    composites: {}
  }

  type VoucherUsageGetPayload<S extends boolean | null | undefined | VoucherUsageDefaultArgs> = $Result.GetResult<Prisma.$VoucherUsagePayload, S>

  type VoucherUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoucherUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoucherUsageCountAggregateInputType | true
    }

  export interface VoucherUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VoucherUsage'], meta: { name: 'VoucherUsage' } }
    /**
     * Find zero or one VoucherUsage that matches the filter.
     * @param {VoucherUsageFindUniqueArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoucherUsageFindUniqueArgs>(args: SelectSubset<T, VoucherUsageFindUniqueArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VoucherUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoucherUsageFindUniqueOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoucherUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, VoucherUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoucherUsageFindFirstArgs>(args?: SelectSubset<T, VoucherUsageFindFirstArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VoucherUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindFirstOrThrowArgs} args - Arguments to find a VoucherUsage
     * @example
     * // Get one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoucherUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, VoucherUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VoucherUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany()
     * 
     * // Get first 10 VoucherUsages
     * const voucherUsages = await prisma.voucherUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoucherUsageFindManyArgs>(args?: SelectSubset<T, VoucherUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VoucherUsage.
     * @param {VoucherUsageCreateArgs} args - Arguments to create a VoucherUsage.
     * @example
     * // Create one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.create({
     *   data: {
     *     // ... data to create a VoucherUsage
     *   }
     * })
     * 
     */
    create<T extends VoucherUsageCreateArgs>(args: SelectSubset<T, VoucherUsageCreateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VoucherUsages.
     * @param {VoucherUsageCreateManyArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoucherUsageCreateManyArgs>(args?: SelectSubset<T, VoucherUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VoucherUsages and returns the data saved in the database.
     * @param {VoucherUsageCreateManyAndReturnArgs} args - Arguments to create many VoucherUsages.
     * @example
     * // Create many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoucherUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, VoucherUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VoucherUsage.
     * @param {VoucherUsageDeleteArgs} args - Arguments to delete one VoucherUsage.
     * @example
     * // Delete one VoucherUsage
     * const VoucherUsage = await prisma.voucherUsage.delete({
     *   where: {
     *     // ... filter to delete one VoucherUsage
     *   }
     * })
     * 
     */
    delete<T extends VoucherUsageDeleteArgs>(args: SelectSubset<T, VoucherUsageDeleteArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VoucherUsage.
     * @param {VoucherUsageUpdateArgs} args - Arguments to update one VoucherUsage.
     * @example
     * // Update one VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoucherUsageUpdateArgs>(args: SelectSubset<T, VoucherUsageUpdateArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VoucherUsages.
     * @param {VoucherUsageDeleteManyArgs} args - Arguments to filter VoucherUsages to delete.
     * @example
     * // Delete a few VoucherUsages
     * const { count } = await prisma.voucherUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoucherUsageDeleteManyArgs>(args?: SelectSubset<T, VoucherUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoucherUsageUpdateManyArgs>(args: SelectSubset<T, VoucherUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VoucherUsages and returns the data updated in the database.
     * @param {VoucherUsageUpdateManyAndReturnArgs} args - Arguments to update many VoucherUsages.
     * @example
     * // Update many VoucherUsages
     * const voucherUsage = await prisma.voucherUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VoucherUsages and only return the `id`
     * const voucherUsageWithIdOnly = await prisma.voucherUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoucherUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, VoucherUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VoucherUsage.
     * @param {VoucherUsageUpsertArgs} args - Arguments to update or create a VoucherUsage.
     * @example
     * // Update or create a VoucherUsage
     * const voucherUsage = await prisma.voucherUsage.upsert({
     *   create: {
     *     // ... data to create a VoucherUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VoucherUsage we want to update
     *   }
     * })
     */
    upsert<T extends VoucherUsageUpsertArgs>(args: SelectSubset<T, VoucherUsageUpsertArgs<ExtArgs>>): Prisma__VoucherUsageClient<$Result.GetResult<Prisma.$VoucherUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VoucherUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageCountArgs} args - Arguments to filter VoucherUsages to count.
     * @example
     * // Count the number of VoucherUsages
     * const count = await prisma.voucherUsage.count({
     *   where: {
     *     // ... the filter for the VoucherUsages we want to count
     *   }
     * })
    **/
    count<T extends VoucherUsageCountArgs>(
      args?: Subset<T, VoucherUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoucherUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoucherUsageAggregateArgs>(args: Subset<T, VoucherUsageAggregateArgs>): Prisma.PrismaPromise<GetVoucherUsageAggregateType<T>>

    /**
     * Group by VoucherUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoucherUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoucherUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoucherUsageGroupByArgs['orderBy'] }
        : { orderBy?: VoucherUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoucherUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoucherUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VoucherUsage model
   */
  readonly fields: VoucherUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VoucherUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoucherUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends VoucherUsage$transactionArgs<ExtArgs> = {}>(args?: Subset<T, VoucherUsage$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    voucher<T extends VoucherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VoucherDefaultArgs<ExtArgs>>): Prisma__VoucherClient<$Result.GetResult<Prisma.$VoucherPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VoucherUsage model
   */
  interface VoucherUsageFieldRefs {
    readonly id: FieldRef<"VoucherUsage", 'String'>
    readonly voucherId: FieldRef<"VoucherUsage", 'String'>
    readonly userId: FieldRef<"VoucherUsage", 'String'>
    readonly transactionId: FieldRef<"VoucherUsage", 'String'>
    readonly usedAt: FieldRef<"VoucherUsage", 'DateTime'>
    readonly discountAmount: FieldRef<"VoucherUsage", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * VoucherUsage findUnique
   */
  export type VoucherUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findUniqueOrThrow
   */
  export type VoucherUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage findFirst
   */
  export type VoucherUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findFirstOrThrow
   */
  export type VoucherUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsage to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VoucherUsages.
     */
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage findMany
   */
  export type VoucherUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter, which VoucherUsages to fetch.
     */
    where?: VoucherUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VoucherUsages to fetch.
     */
    orderBy?: VoucherUsageOrderByWithRelationInput | VoucherUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VoucherUsages.
     */
    cursor?: VoucherUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VoucherUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VoucherUsages.
     */
    skip?: number
    distinct?: VoucherUsageScalarFieldEnum | VoucherUsageScalarFieldEnum[]
  }

  /**
   * VoucherUsage create
   */
  export type VoucherUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a VoucherUsage.
     */
    data: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
  }

  /**
   * VoucherUsage createMany
   */
  export type VoucherUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VoucherUsage createManyAndReturn
   */
  export type VoucherUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to create many VoucherUsages.
     */
    data: VoucherUsageCreateManyInput | VoucherUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage update
   */
  export type VoucherUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a VoucherUsage.
     */
    data: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
    /**
     * Choose, which VoucherUsage to update.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage updateMany
   */
  export type VoucherUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
  }

  /**
   * VoucherUsage updateManyAndReturn
   */
  export type VoucherUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * The data used to update VoucherUsages.
     */
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyInput>
    /**
     * Filter which VoucherUsages to update
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VoucherUsage upsert
   */
  export type VoucherUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the VoucherUsage to update in case it exists.
     */
    where: VoucherUsageWhereUniqueInput
    /**
     * In case the VoucherUsage found by the `where` argument doesn't exist, create a new VoucherUsage with this data.
     */
    create: XOR<VoucherUsageCreateInput, VoucherUsageUncheckedCreateInput>
    /**
     * In case the VoucherUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoucherUsageUpdateInput, VoucherUsageUncheckedUpdateInput>
  }

  /**
   * VoucherUsage delete
   */
  export type VoucherUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
    /**
     * Filter which VoucherUsage to delete.
     */
    where: VoucherUsageWhereUniqueInput
  }

  /**
   * VoucherUsage deleteMany
   */
  export type VoucherUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VoucherUsages to delete
     */
    where?: VoucherUsageWhereInput
    /**
     * Limit how many VoucherUsages to delete.
     */
    limit?: number
  }

  /**
   * VoucherUsage.transaction
   */
  export type VoucherUsage$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * VoucherUsage without action
   */
  export type VoucherUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VoucherUsage
     */
    select?: VoucherUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VoucherUsage
     */
    omit?: VoucherUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoucherUsageInclude<ExtArgs> | null
  }


  /**
   * Model ServicesProductCustomers
   */

  export type AggregateServicesProductCustomers = {
    _count: ServicesProductCustomersCountAggregateOutputType | null
    _avg: ServicesProductCustomersAvgAggregateOutputType | null
    _sum: ServicesProductCustomersSumAggregateOutputType | null
    _min: ServicesProductCustomersMinAggregateOutputType | null
    _max: ServicesProductCustomersMaxAggregateOutputType | null
  }

  export type ServicesProductCustomersAvgAggregateOutputType = {
    quantity: number | null
  }

  export type ServicesProductCustomersSumAggregateOutputType = {
    quantity: number | null
  }

  export type ServicesProductCustomersMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    packageId: string | null
    quantity: number | null
    websiteUrl: string | null
    driveUrl: string | null
    textDescription: string | null
    domainName: string | null
    domainExpiredAt: Date | null
    fileAssets: string | null
    status: string | null
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesProductCustomersMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    packageId: string | null
    quantity: number | null
    websiteUrl: string | null
    driveUrl: string | null
    textDescription: string | null
    domainName: string | null
    domainExpiredAt: Date | null
    fileAssets: string | null
    status: string | null
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesProductCustomersCountAggregateOutputType = {
    id: number
    transactionId: number
    customerId: number
    packageId: number
    quantity: number
    websiteUrl: number
    driveUrl: number
    textDescription: number
    domainName: number
    domainExpiredAt: number
    fileAssets: number
    status: number
    deliveredAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesProductCustomersAvgAggregateInputType = {
    quantity?: true
  }

  export type ServicesProductCustomersSumAggregateInputType = {
    quantity?: true
  }

  export type ServicesProductCustomersMinAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    quantity?: true
    websiteUrl?: true
    driveUrl?: true
    textDescription?: true
    domainName?: true
    domainExpiredAt?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesProductCustomersMaxAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    quantity?: true
    websiteUrl?: true
    driveUrl?: true
    textDescription?: true
    domainName?: true
    domainExpiredAt?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesProductCustomersCountAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    packageId?: true
    quantity?: true
    websiteUrl?: true
    driveUrl?: true
    textDescription?: true
    domainName?: true
    domainExpiredAt?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesProductCustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesProductCustomers to aggregate.
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesProductCustomers to fetch.
     */
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesProductCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesProductCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesProductCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicesProductCustomers
    **/
    _count?: true | ServicesProductCustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicesProductCustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicesProductCustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesProductCustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesProductCustomersMaxAggregateInputType
  }

  export type GetServicesProductCustomersAggregateType<T extends ServicesProductCustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesProductCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesProductCustomers[P]>
      : GetScalarType<T[P], AggregateServicesProductCustomers[P]>
  }




  export type ServicesProductCustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesProductCustomersWhereInput
    orderBy?: ServicesProductCustomersOrderByWithAggregationInput | ServicesProductCustomersOrderByWithAggregationInput[]
    by: ServicesProductCustomersScalarFieldEnum[] | ServicesProductCustomersScalarFieldEnum
    having?: ServicesProductCustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesProductCustomersCountAggregateInputType | true
    _avg?: ServicesProductCustomersAvgAggregateInputType
    _sum?: ServicesProductCustomersSumAggregateInputType
    _min?: ServicesProductCustomersMinAggregateInputType
    _max?: ServicesProductCustomersMaxAggregateInputType
  }

  export type ServicesProductCustomersGroupByOutputType = {
    id: string
    transactionId: string
    customerId: string
    packageId: string | null
    quantity: number
    websiteUrl: string | null
    driveUrl: string | null
    textDescription: string | null
    domainName: string | null
    domainExpiredAt: Date | null
    fileAssets: string | null
    status: string
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesProductCustomersCountAggregateOutputType | null
    _avg: ServicesProductCustomersAvgAggregateOutputType | null
    _sum: ServicesProductCustomersSumAggregateOutputType | null
    _min: ServicesProductCustomersMinAggregateOutputType | null
    _max: ServicesProductCustomersMaxAggregateOutputType | null
  }

  type GetServicesProductCustomersGroupByPayload<T extends ServicesProductCustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesProductCustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesProductCustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesProductCustomersGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesProductCustomersGroupByOutputType[P]>
        }
      >
    >


  export type ServicesProductCustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    quantity?: boolean
    websiteUrl?: boolean
    driveUrl?: boolean
    textDescription?: boolean
    domainName?: boolean
    domainExpiredAt?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }, ExtArgs["result"]["servicesProductCustomers"]>

  export type ServicesProductCustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    quantity?: boolean
    websiteUrl?: boolean
    driveUrl?: boolean
    textDescription?: boolean
    domainName?: boolean
    domainExpiredAt?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }, ExtArgs["result"]["servicesProductCustomers"]>

  export type ServicesProductCustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    quantity?: boolean
    websiteUrl?: boolean
    driveUrl?: boolean
    textDescription?: boolean
    domainName?: boolean
    domainExpiredAt?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }, ExtArgs["result"]["servicesProductCustomers"]>

  export type ServicesProductCustomersSelectScalar = {
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    packageId?: boolean
    quantity?: boolean
    websiteUrl?: boolean
    driveUrl?: boolean
    textDescription?: boolean
    domainName?: boolean
    domainExpiredAt?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicesProductCustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "customerId" | "packageId" | "quantity" | "websiteUrl" | "driveUrl" | "textDescription" | "domainName" | "domainExpiredAt" | "fileAssets" | "status" | "deliveredAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["servicesProductCustomers"]>
  export type ServicesProductCustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }
  export type ServicesProductCustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }
  export type ServicesProductCustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
    package?: boolean | ServicesProductCustomers$packageArgs<ExtArgs>
  }

  export type $ServicesProductCustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicesProductCustomers"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
      package: Prisma.$PackagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      customerId: string
      packageId: string | null
      quantity: number
      websiteUrl: string | null
      driveUrl: string | null
      textDescription: string | null
      domainName: string | null
      domainExpiredAt: Date | null
      fileAssets: string | null
      status: string
      deliveredAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicesProductCustomers"]>
    composites: {}
  }

  type ServicesProductCustomersGetPayload<S extends boolean | null | undefined | ServicesProductCustomersDefaultArgs> = $Result.GetResult<Prisma.$ServicesProductCustomersPayload, S>

  type ServicesProductCustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesProductCustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesProductCustomersCountAggregateInputType | true
    }

  export interface ServicesProductCustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicesProductCustomers'], meta: { name: 'ServicesProductCustomers' } }
    /**
     * Find zero or one ServicesProductCustomers that matches the filter.
     * @param {ServicesProductCustomersFindUniqueArgs} args - Arguments to find a ServicesProductCustomers
     * @example
     * // Get one ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesProductCustomersFindUniqueArgs>(args: SelectSubset<T, ServicesProductCustomersFindUniqueArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicesProductCustomers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesProductCustomersFindUniqueOrThrowArgs} args - Arguments to find a ServicesProductCustomers
     * @example
     * // Get one ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesProductCustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesProductCustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesProductCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersFindFirstArgs} args - Arguments to find a ServicesProductCustomers
     * @example
     * // Get one ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesProductCustomersFindFirstArgs>(args?: SelectSubset<T, ServicesProductCustomersFindFirstArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesProductCustomers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersFindFirstOrThrowArgs} args - Arguments to find a ServicesProductCustomers
     * @example
     * // Get one ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesProductCustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesProductCustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicesProductCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findMany()
     * 
     * // Get first 10 ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesProductCustomersWithIdOnly = await prisma.servicesProductCustomers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesProductCustomersFindManyArgs>(args?: SelectSubset<T, ServicesProductCustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicesProductCustomers.
     * @param {ServicesProductCustomersCreateArgs} args - Arguments to create a ServicesProductCustomers.
     * @example
     * // Create one ServicesProductCustomers
     * const ServicesProductCustomers = await prisma.servicesProductCustomers.create({
     *   data: {
     *     // ... data to create a ServicesProductCustomers
     *   }
     * })
     * 
     */
    create<T extends ServicesProductCustomersCreateArgs>(args: SelectSubset<T, ServicesProductCustomersCreateArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicesProductCustomers.
     * @param {ServicesProductCustomersCreateManyArgs} args - Arguments to create many ServicesProductCustomers.
     * @example
     * // Create many ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesProductCustomersCreateManyArgs>(args?: SelectSubset<T, ServicesProductCustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicesProductCustomers and returns the data saved in the database.
     * @param {ServicesProductCustomersCreateManyAndReturnArgs} args - Arguments to create many ServicesProductCustomers.
     * @example
     * // Create many ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicesProductCustomers and only return the `id`
     * const servicesProductCustomersWithIdOnly = await prisma.servicesProductCustomers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesProductCustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesProductCustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicesProductCustomers.
     * @param {ServicesProductCustomersDeleteArgs} args - Arguments to delete one ServicesProductCustomers.
     * @example
     * // Delete one ServicesProductCustomers
     * const ServicesProductCustomers = await prisma.servicesProductCustomers.delete({
     *   where: {
     *     // ... filter to delete one ServicesProductCustomers
     *   }
     * })
     * 
     */
    delete<T extends ServicesProductCustomersDeleteArgs>(args: SelectSubset<T, ServicesProductCustomersDeleteArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicesProductCustomers.
     * @param {ServicesProductCustomersUpdateArgs} args - Arguments to update one ServicesProductCustomers.
     * @example
     * // Update one ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesProductCustomersUpdateArgs>(args: SelectSubset<T, ServicesProductCustomersUpdateArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicesProductCustomers.
     * @param {ServicesProductCustomersDeleteManyArgs} args - Arguments to filter ServicesProductCustomers to delete.
     * @example
     * // Delete a few ServicesProductCustomers
     * const { count } = await prisma.servicesProductCustomers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesProductCustomersDeleteManyArgs>(args?: SelectSubset<T, ServicesProductCustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesProductCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesProductCustomersUpdateManyArgs>(args: SelectSubset<T, ServicesProductCustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesProductCustomers and returns the data updated in the database.
     * @param {ServicesProductCustomersUpdateManyAndReturnArgs} args - Arguments to update many ServicesProductCustomers.
     * @example
     * // Update many ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicesProductCustomers and only return the `id`
     * const servicesProductCustomersWithIdOnly = await prisma.servicesProductCustomers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesProductCustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesProductCustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicesProductCustomers.
     * @param {ServicesProductCustomersUpsertArgs} args - Arguments to update or create a ServicesProductCustomers.
     * @example
     * // Update or create a ServicesProductCustomers
     * const servicesProductCustomers = await prisma.servicesProductCustomers.upsert({
     *   create: {
     *     // ... data to create a ServicesProductCustomers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicesProductCustomers we want to update
     *   }
     * })
     */
    upsert<T extends ServicesProductCustomersUpsertArgs>(args: SelectSubset<T, ServicesProductCustomersUpsertArgs<ExtArgs>>): Prisma__ServicesProductCustomersClient<$Result.GetResult<Prisma.$ServicesProductCustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicesProductCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersCountArgs} args - Arguments to filter ServicesProductCustomers to count.
     * @example
     * // Count the number of ServicesProductCustomers
     * const count = await prisma.servicesProductCustomers.count({
     *   where: {
     *     // ... the filter for the ServicesProductCustomers we want to count
     *   }
     * })
    **/
    count<T extends ServicesProductCustomersCountArgs>(
      args?: Subset<T, ServicesProductCustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesProductCustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicesProductCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesProductCustomersAggregateArgs>(args: Subset<T, ServicesProductCustomersAggregateArgs>): Prisma.PrismaPromise<GetServicesProductCustomersAggregateType<T>>

    /**
     * Group by ServicesProductCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesProductCustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesProductCustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesProductCustomersGroupByArgs['orderBy'] }
        : { orderBy?: ServicesProductCustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesProductCustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesProductCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicesProductCustomers model
   */
  readonly fields: ServicesProductCustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicesProductCustomers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesProductCustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    package<T extends ServicesProductCustomers$packageArgs<ExtArgs> = {}>(args?: Subset<T, ServicesProductCustomers$packageArgs<ExtArgs>>): Prisma__PackageClient<$Result.GetResult<Prisma.$PackagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicesProductCustomers model
   */
  interface ServicesProductCustomersFieldRefs {
    readonly id: FieldRef<"ServicesProductCustomers", 'String'>
    readonly transactionId: FieldRef<"ServicesProductCustomers", 'String'>
    readonly customerId: FieldRef<"ServicesProductCustomers", 'String'>
    readonly packageId: FieldRef<"ServicesProductCustomers", 'String'>
    readonly quantity: FieldRef<"ServicesProductCustomers", 'Int'>
    readonly websiteUrl: FieldRef<"ServicesProductCustomers", 'String'>
    readonly driveUrl: FieldRef<"ServicesProductCustomers", 'String'>
    readonly textDescription: FieldRef<"ServicesProductCustomers", 'String'>
    readonly domainName: FieldRef<"ServicesProductCustomers", 'String'>
    readonly domainExpiredAt: FieldRef<"ServicesProductCustomers", 'DateTime'>
    readonly fileAssets: FieldRef<"ServicesProductCustomers", 'String'>
    readonly status: FieldRef<"ServicesProductCustomers", 'String'>
    readonly deliveredAt: FieldRef<"ServicesProductCustomers", 'DateTime'>
    readonly notes: FieldRef<"ServicesProductCustomers", 'String'>
    readonly createdAt: FieldRef<"ServicesProductCustomers", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicesProductCustomers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicesProductCustomers findUnique
   */
  export type ServicesProductCustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesProductCustomers to fetch.
     */
    where: ServicesProductCustomersWhereUniqueInput
  }

  /**
   * ServicesProductCustomers findUniqueOrThrow
   */
  export type ServicesProductCustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesProductCustomers to fetch.
     */
    where: ServicesProductCustomersWhereUniqueInput
  }

  /**
   * ServicesProductCustomers findFirst
   */
  export type ServicesProductCustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesProductCustomers to fetch.
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesProductCustomers to fetch.
     */
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesProductCustomers.
     */
    cursor?: ServicesProductCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesProductCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesProductCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesProductCustomers.
     */
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * ServicesProductCustomers findFirstOrThrow
   */
  export type ServicesProductCustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesProductCustomers to fetch.
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesProductCustomers to fetch.
     */
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesProductCustomers.
     */
    cursor?: ServicesProductCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesProductCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesProductCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesProductCustomers.
     */
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * ServicesProductCustomers findMany
   */
  export type ServicesProductCustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesProductCustomers to fetch.
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesProductCustomers to fetch.
     */
    orderBy?: ServicesProductCustomersOrderByWithRelationInput | ServicesProductCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicesProductCustomers.
     */
    cursor?: ServicesProductCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesProductCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesProductCustomers.
     */
    skip?: number
    distinct?: ServicesProductCustomersScalarFieldEnum | ServicesProductCustomersScalarFieldEnum[]
  }

  /**
   * ServicesProductCustomers create
   */
  export type ServicesProductCustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicesProductCustomers.
     */
    data: XOR<ServicesProductCustomersCreateInput, ServicesProductCustomersUncheckedCreateInput>
  }

  /**
   * ServicesProductCustomers createMany
   */
  export type ServicesProductCustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicesProductCustomers.
     */
    data: ServicesProductCustomersCreateManyInput | ServicesProductCustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicesProductCustomers createManyAndReturn
   */
  export type ServicesProductCustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * The data used to create many ServicesProductCustomers.
     */
    data: ServicesProductCustomersCreateManyInput | ServicesProductCustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesProductCustomers update
   */
  export type ServicesProductCustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicesProductCustomers.
     */
    data: XOR<ServicesProductCustomersUpdateInput, ServicesProductCustomersUncheckedUpdateInput>
    /**
     * Choose, which ServicesProductCustomers to update.
     */
    where: ServicesProductCustomersWhereUniqueInput
  }

  /**
   * ServicesProductCustomers updateMany
   */
  export type ServicesProductCustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicesProductCustomers.
     */
    data: XOR<ServicesProductCustomersUpdateManyMutationInput, ServicesProductCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesProductCustomers to update
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * Limit how many ServicesProductCustomers to update.
     */
    limit?: number
  }

  /**
   * ServicesProductCustomers updateManyAndReturn
   */
  export type ServicesProductCustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * The data used to update ServicesProductCustomers.
     */
    data: XOR<ServicesProductCustomersUpdateManyMutationInput, ServicesProductCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesProductCustomers to update
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * Limit how many ServicesProductCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesProductCustomers upsert
   */
  export type ServicesProductCustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicesProductCustomers to update in case it exists.
     */
    where: ServicesProductCustomersWhereUniqueInput
    /**
     * In case the ServicesProductCustomers found by the `where` argument doesn't exist, create a new ServicesProductCustomers with this data.
     */
    create: XOR<ServicesProductCustomersCreateInput, ServicesProductCustomersUncheckedCreateInput>
    /**
     * In case the ServicesProductCustomers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesProductCustomersUpdateInput, ServicesProductCustomersUncheckedUpdateInput>
  }

  /**
   * ServicesProductCustomers delete
   */
  export type ServicesProductCustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
    /**
     * Filter which ServicesProductCustomers to delete.
     */
    where: ServicesProductCustomersWhereUniqueInput
  }

  /**
   * ServicesProductCustomers deleteMany
   */
  export type ServicesProductCustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesProductCustomers to delete
     */
    where?: ServicesProductCustomersWhereInput
    /**
     * Limit how many ServicesProductCustomers to delete.
     */
    limit?: number
  }

  /**
   * ServicesProductCustomers.package
   */
  export type ServicesProductCustomers$packageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Package
     */
    select?: PackageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Package
     */
    omit?: PackageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackageInclude<ExtArgs> | null
    where?: PackageWhereInput
  }

  /**
   * ServicesProductCustomers without action
   */
  export type ServicesProductCustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesProductCustomers
     */
    select?: ServicesProductCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesProductCustomers
     */
    omit?: ServicesProductCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesProductCustomersInclude<ExtArgs> | null
  }


  /**
   * Model ServicesAddonsCustomers
   */

  export type AggregateServicesAddonsCustomers = {
    _count: ServicesAddonsCustomersCountAggregateOutputType | null
    _min: ServicesAddonsCustomersMinAggregateOutputType | null
    _max: ServicesAddonsCustomersMaxAggregateOutputType | null
  }

  export type ServicesAddonsCustomersMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    addonDetails: string | null
    driveUrl: string | null
    fileAssets: string | null
    status: string | null
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesAddonsCustomersMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    customerId: string | null
    addonDetails: string | null
    driveUrl: string | null
    fileAssets: string | null
    status: string | null
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServicesAddonsCustomersCountAggregateOutputType = {
    id: number
    transactionId: number
    customerId: number
    addonDetails: number
    driveUrl: number
    fileAssets: number
    status: number
    deliveredAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServicesAddonsCustomersMinAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    addonDetails?: true
    driveUrl?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesAddonsCustomersMaxAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    addonDetails?: true
    driveUrl?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServicesAddonsCustomersCountAggregateInputType = {
    id?: true
    transactionId?: true
    customerId?: true
    addonDetails?: true
    driveUrl?: true
    fileAssets?: true
    status?: true
    deliveredAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicesAddonsCustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesAddonsCustomers to aggregate.
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesAddonsCustomers to fetch.
     */
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesAddonsCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesAddonsCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicesAddonsCustomers
    **/
    _count?: true | ServicesAddonsCustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicesAddonsCustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicesAddonsCustomersMaxAggregateInputType
  }

  export type GetServicesAddonsCustomersAggregateType<T extends ServicesAddonsCustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateServicesAddonsCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicesAddonsCustomers[P]>
      : GetScalarType<T[P], AggregateServicesAddonsCustomers[P]>
  }




  export type ServicesAddonsCustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicesAddonsCustomersWhereInput
    orderBy?: ServicesAddonsCustomersOrderByWithAggregationInput | ServicesAddonsCustomersOrderByWithAggregationInput[]
    by: ServicesAddonsCustomersScalarFieldEnum[] | ServicesAddonsCustomersScalarFieldEnum
    having?: ServicesAddonsCustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicesAddonsCustomersCountAggregateInputType | true
    _min?: ServicesAddonsCustomersMinAggregateInputType
    _max?: ServicesAddonsCustomersMaxAggregateInputType
  }

  export type ServicesAddonsCustomersGroupByOutputType = {
    id: string
    transactionId: string
    customerId: string
    addonDetails: string
    driveUrl: string | null
    fileAssets: string | null
    status: string
    deliveredAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServicesAddonsCustomersCountAggregateOutputType | null
    _min: ServicesAddonsCustomersMinAggregateOutputType | null
    _max: ServicesAddonsCustomersMaxAggregateOutputType | null
  }

  type GetServicesAddonsCustomersGroupByPayload<T extends ServicesAddonsCustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicesAddonsCustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicesAddonsCustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicesAddonsCustomersGroupByOutputType[P]>
            : GetScalarType<T[P], ServicesAddonsCustomersGroupByOutputType[P]>
        }
      >
    >


  export type ServicesAddonsCustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    addonDetails?: boolean
    driveUrl?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesAddonsCustomers"]>

  export type ServicesAddonsCustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    addonDetails?: boolean
    driveUrl?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesAddonsCustomers"]>

  export type ServicesAddonsCustomersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    addonDetails?: boolean
    driveUrl?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicesAddonsCustomers"]>

  export type ServicesAddonsCustomersSelectScalar = {
    id?: boolean
    transactionId?: boolean
    customerId?: boolean
    addonDetails?: boolean
    driveUrl?: boolean
    fileAssets?: boolean
    status?: boolean
    deliveredAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServicesAddonsCustomersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transactionId" | "customerId" | "addonDetails" | "driveUrl" | "fileAssets" | "status" | "deliveredAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["servicesAddonsCustomers"]>
  export type ServicesAddonsCustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type ServicesAddonsCustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }
  export type ServicesAddonsCustomersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    transaction?: boolean | TransactionDefaultArgs<ExtArgs>
  }

  export type $ServicesAddonsCustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicesAddonsCustomers"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      transaction: Prisma.$TransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      customerId: string
      addonDetails: string
      driveUrl: string | null
      fileAssets: string | null
      status: string
      deliveredAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicesAddonsCustomers"]>
    composites: {}
  }

  type ServicesAddonsCustomersGetPayload<S extends boolean | null | undefined | ServicesAddonsCustomersDefaultArgs> = $Result.GetResult<Prisma.$ServicesAddonsCustomersPayload, S>

  type ServicesAddonsCustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicesAddonsCustomersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicesAddonsCustomersCountAggregateInputType | true
    }

  export interface ServicesAddonsCustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicesAddonsCustomers'], meta: { name: 'ServicesAddonsCustomers' } }
    /**
     * Find zero or one ServicesAddonsCustomers that matches the filter.
     * @param {ServicesAddonsCustomersFindUniqueArgs} args - Arguments to find a ServicesAddonsCustomers
     * @example
     * // Get one ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicesAddonsCustomersFindUniqueArgs>(args: SelectSubset<T, ServicesAddonsCustomersFindUniqueArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicesAddonsCustomers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicesAddonsCustomersFindUniqueOrThrowArgs} args - Arguments to find a ServicesAddonsCustomers
     * @example
     * // Get one ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicesAddonsCustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicesAddonsCustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesAddonsCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersFindFirstArgs} args - Arguments to find a ServicesAddonsCustomers
     * @example
     * // Get one ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicesAddonsCustomersFindFirstArgs>(args?: SelectSubset<T, ServicesAddonsCustomersFindFirstArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicesAddonsCustomers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersFindFirstOrThrowArgs} args - Arguments to find a ServicesAddonsCustomers
     * @example
     * // Get one ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicesAddonsCustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicesAddonsCustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicesAddonsCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findMany()
     * 
     * // Get first 10 ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicesAddonsCustomersWithIdOnly = await prisma.servicesAddonsCustomers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicesAddonsCustomersFindManyArgs>(args?: SelectSubset<T, ServicesAddonsCustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersCreateArgs} args - Arguments to create a ServicesAddonsCustomers.
     * @example
     * // Create one ServicesAddonsCustomers
     * const ServicesAddonsCustomers = await prisma.servicesAddonsCustomers.create({
     *   data: {
     *     // ... data to create a ServicesAddonsCustomers
     *   }
     * })
     * 
     */
    create<T extends ServicesAddonsCustomersCreateArgs>(args: SelectSubset<T, ServicesAddonsCustomersCreateArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersCreateManyArgs} args - Arguments to create many ServicesAddonsCustomers.
     * @example
     * // Create many ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicesAddonsCustomersCreateManyArgs>(args?: SelectSubset<T, ServicesAddonsCustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicesAddonsCustomers and returns the data saved in the database.
     * @param {ServicesAddonsCustomersCreateManyAndReturnArgs} args - Arguments to create many ServicesAddonsCustomers.
     * @example
     * // Create many ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicesAddonsCustomers and only return the `id`
     * const servicesAddonsCustomersWithIdOnly = await prisma.servicesAddonsCustomers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicesAddonsCustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicesAddonsCustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersDeleteArgs} args - Arguments to delete one ServicesAddonsCustomers.
     * @example
     * // Delete one ServicesAddonsCustomers
     * const ServicesAddonsCustomers = await prisma.servicesAddonsCustomers.delete({
     *   where: {
     *     // ... filter to delete one ServicesAddonsCustomers
     *   }
     * })
     * 
     */
    delete<T extends ServicesAddonsCustomersDeleteArgs>(args: SelectSubset<T, ServicesAddonsCustomersDeleteArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersUpdateArgs} args - Arguments to update one ServicesAddonsCustomers.
     * @example
     * // Update one ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicesAddonsCustomersUpdateArgs>(args: SelectSubset<T, ServicesAddonsCustomersUpdateArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersDeleteManyArgs} args - Arguments to filter ServicesAddonsCustomers to delete.
     * @example
     * // Delete a few ServicesAddonsCustomers
     * const { count } = await prisma.servicesAddonsCustomers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicesAddonsCustomersDeleteManyArgs>(args?: SelectSubset<T, ServicesAddonsCustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesAddonsCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicesAddonsCustomersUpdateManyArgs>(args: SelectSubset<T, ServicesAddonsCustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicesAddonsCustomers and returns the data updated in the database.
     * @param {ServicesAddonsCustomersUpdateManyAndReturnArgs} args - Arguments to update many ServicesAddonsCustomers.
     * @example
     * // Update many ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicesAddonsCustomers and only return the `id`
     * const servicesAddonsCustomersWithIdOnly = await prisma.servicesAddonsCustomers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicesAddonsCustomersUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicesAddonsCustomersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicesAddonsCustomers.
     * @param {ServicesAddonsCustomersUpsertArgs} args - Arguments to update or create a ServicesAddonsCustomers.
     * @example
     * // Update or create a ServicesAddonsCustomers
     * const servicesAddonsCustomers = await prisma.servicesAddonsCustomers.upsert({
     *   create: {
     *     // ... data to create a ServicesAddonsCustomers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicesAddonsCustomers we want to update
     *   }
     * })
     */
    upsert<T extends ServicesAddonsCustomersUpsertArgs>(args: SelectSubset<T, ServicesAddonsCustomersUpsertArgs<ExtArgs>>): Prisma__ServicesAddonsCustomersClient<$Result.GetResult<Prisma.$ServicesAddonsCustomersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicesAddonsCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersCountArgs} args - Arguments to filter ServicesAddonsCustomers to count.
     * @example
     * // Count the number of ServicesAddonsCustomers
     * const count = await prisma.servicesAddonsCustomers.count({
     *   where: {
     *     // ... the filter for the ServicesAddonsCustomers we want to count
     *   }
     * })
    **/
    count<T extends ServicesAddonsCustomersCountArgs>(
      args?: Subset<T, ServicesAddonsCustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicesAddonsCustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicesAddonsCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicesAddonsCustomersAggregateArgs>(args: Subset<T, ServicesAddonsCustomersAggregateArgs>): Prisma.PrismaPromise<GetServicesAddonsCustomersAggregateType<T>>

    /**
     * Group by ServicesAddonsCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicesAddonsCustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicesAddonsCustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicesAddonsCustomersGroupByArgs['orderBy'] }
        : { orderBy?: ServicesAddonsCustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicesAddonsCustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicesAddonsCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicesAddonsCustomers model
   */
  readonly fields: ServicesAddonsCustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicesAddonsCustomers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicesAddonsCustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transaction<T extends TransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TransactionDefaultArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicesAddonsCustomers model
   */
  interface ServicesAddonsCustomersFieldRefs {
    readonly id: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly transactionId: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly customerId: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly addonDetails: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly driveUrl: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly fileAssets: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly status: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly deliveredAt: FieldRef<"ServicesAddonsCustomers", 'DateTime'>
    readonly notes: FieldRef<"ServicesAddonsCustomers", 'String'>
    readonly createdAt: FieldRef<"ServicesAddonsCustomers", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicesAddonsCustomers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicesAddonsCustomers findUnique
   */
  export type ServicesAddonsCustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesAddonsCustomers to fetch.
     */
    where: ServicesAddonsCustomersWhereUniqueInput
  }

  /**
   * ServicesAddonsCustomers findUniqueOrThrow
   */
  export type ServicesAddonsCustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesAddonsCustomers to fetch.
     */
    where: ServicesAddonsCustomersWhereUniqueInput
  }

  /**
   * ServicesAddonsCustomers findFirst
   */
  export type ServicesAddonsCustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesAddonsCustomers to fetch.
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesAddonsCustomers to fetch.
     */
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesAddonsCustomers.
     */
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesAddonsCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesAddonsCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesAddonsCustomers.
     */
    distinct?: ServicesAddonsCustomersScalarFieldEnum | ServicesAddonsCustomersScalarFieldEnum[]
  }

  /**
   * ServicesAddonsCustomers findFirstOrThrow
   */
  export type ServicesAddonsCustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesAddonsCustomers to fetch.
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesAddonsCustomers to fetch.
     */
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicesAddonsCustomers.
     */
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesAddonsCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesAddonsCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicesAddonsCustomers.
     */
    distinct?: ServicesAddonsCustomersScalarFieldEnum | ServicesAddonsCustomersScalarFieldEnum[]
  }

  /**
   * ServicesAddonsCustomers findMany
   */
  export type ServicesAddonsCustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter, which ServicesAddonsCustomers to fetch.
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicesAddonsCustomers to fetch.
     */
    orderBy?: ServicesAddonsCustomersOrderByWithRelationInput | ServicesAddonsCustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicesAddonsCustomers.
     */
    cursor?: ServicesAddonsCustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicesAddonsCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicesAddonsCustomers.
     */
    skip?: number
    distinct?: ServicesAddonsCustomersScalarFieldEnum | ServicesAddonsCustomersScalarFieldEnum[]
  }

  /**
   * ServicesAddonsCustomers create
   */
  export type ServicesAddonsCustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicesAddonsCustomers.
     */
    data: XOR<ServicesAddonsCustomersCreateInput, ServicesAddonsCustomersUncheckedCreateInput>
  }

  /**
   * ServicesAddonsCustomers createMany
   */
  export type ServicesAddonsCustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicesAddonsCustomers.
     */
    data: ServicesAddonsCustomersCreateManyInput | ServicesAddonsCustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicesAddonsCustomers createManyAndReturn
   */
  export type ServicesAddonsCustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * The data used to create many ServicesAddonsCustomers.
     */
    data: ServicesAddonsCustomersCreateManyInput | ServicesAddonsCustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesAddonsCustomers update
   */
  export type ServicesAddonsCustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicesAddonsCustomers.
     */
    data: XOR<ServicesAddonsCustomersUpdateInput, ServicesAddonsCustomersUncheckedUpdateInput>
    /**
     * Choose, which ServicesAddonsCustomers to update.
     */
    where: ServicesAddonsCustomersWhereUniqueInput
  }

  /**
   * ServicesAddonsCustomers updateMany
   */
  export type ServicesAddonsCustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicesAddonsCustomers.
     */
    data: XOR<ServicesAddonsCustomersUpdateManyMutationInput, ServicesAddonsCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesAddonsCustomers to update
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * Limit how many ServicesAddonsCustomers to update.
     */
    limit?: number
  }

  /**
   * ServicesAddonsCustomers updateManyAndReturn
   */
  export type ServicesAddonsCustomersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * The data used to update ServicesAddonsCustomers.
     */
    data: XOR<ServicesAddonsCustomersUpdateManyMutationInput, ServicesAddonsCustomersUncheckedUpdateManyInput>
    /**
     * Filter which ServicesAddonsCustomers to update
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * Limit how many ServicesAddonsCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicesAddonsCustomers upsert
   */
  export type ServicesAddonsCustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicesAddonsCustomers to update in case it exists.
     */
    where: ServicesAddonsCustomersWhereUniqueInput
    /**
     * In case the ServicesAddonsCustomers found by the `where` argument doesn't exist, create a new ServicesAddonsCustomers with this data.
     */
    create: XOR<ServicesAddonsCustomersCreateInput, ServicesAddonsCustomersUncheckedCreateInput>
    /**
     * In case the ServicesAddonsCustomers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicesAddonsCustomersUpdateInput, ServicesAddonsCustomersUncheckedUpdateInput>
  }

  /**
   * ServicesAddonsCustomers delete
   */
  export type ServicesAddonsCustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
    /**
     * Filter which ServicesAddonsCustomers to delete.
     */
    where: ServicesAddonsCustomersWhereUniqueInput
  }

  /**
   * ServicesAddonsCustomers deleteMany
   */
  export type ServicesAddonsCustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicesAddonsCustomers to delete
     */
    where?: ServicesAddonsCustomersWhereInput
    /**
     * Limit how many ServicesAddonsCustomers to delete.
     */
    limit?: number
  }

  /**
   * ServicesAddonsCustomers without action
   */
  export type ServicesAddonsCustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicesAddonsCustomers
     */
    select?: ServicesAddonsCustomersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicesAddonsCustomers
     */
    omit?: ServicesAddonsCustomersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicesAddonsCustomersInclude<ExtArgs> | null
  }


  /**
   * Model ServiceFee
   */

  export type AggregateServiceFee = {
    _count: ServiceFeeCountAggregateOutputType | null
    _avg: ServiceFeeAvgAggregateOutputType | null
    _sum: ServiceFeeSumAggregateOutputType | null
    _min: ServiceFeeMinAggregateOutputType | null
    _max: ServiceFeeMaxAggregateOutputType | null
  }

  export type ServiceFeeAvgAggregateOutputType = {
    value: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
  }

  export type ServiceFeeSumAggregateOutputType = {
    value: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
  }

  export type ServiceFeeMinAggregateOutputType = {
    id: string | null
    paymentMethod: string | null
    name: string | null
    type: string | null
    value: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
    isActive: boolean | null
    requiresManualApproval: boolean | null
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
  }

  export type ServiceFeeMaxAggregateOutputType = {
    id: string | null
    paymentMethod: string | null
    name: string | null
    type: string | null
    value: Decimal | null
    minFee: Decimal | null
    maxFee: Decimal | null
    isActive: boolean | null
    requiresManualApproval: boolean | null
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
    currency: string | null
  }

  export type ServiceFeeCountAggregateOutputType = {
    id: number
    paymentMethod: number
    name: number
    type: number
    value: number
    minFee: number
    maxFee: number
    isActive: number
    requiresManualApproval: number
    paymentInstructions: number
    instructionType: number
    instructionImageUrl: number
    createdAt: number
    updatedAt: number
    currency: number
    _all: number
  }


  export type ServiceFeeAvgAggregateInputType = {
    value?: true
    minFee?: true
    maxFee?: true
  }

  export type ServiceFeeSumAggregateInputType = {
    value?: true
    minFee?: true
    maxFee?: true
  }

  export type ServiceFeeMinAggregateInputType = {
    id?: true
    paymentMethod?: true
    name?: true
    type?: true
    value?: true
    minFee?: true
    maxFee?: true
    isActive?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
  }

  export type ServiceFeeMaxAggregateInputType = {
    id?: true
    paymentMethod?: true
    name?: true
    type?: true
    value?: true
    minFee?: true
    maxFee?: true
    isActive?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
  }

  export type ServiceFeeCountAggregateInputType = {
    id?: true
    paymentMethod?: true
    name?: true
    type?: true
    value?: true
    minFee?: true
    maxFee?: true
    isActive?: true
    requiresManualApproval?: true
    paymentInstructions?: true
    instructionType?: true
    instructionImageUrl?: true
    createdAt?: true
    updatedAt?: true
    currency?: true
    _all?: true
  }

  export type ServiceFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceFee to aggregate.
     */
    where?: ServiceFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFees to fetch.
     */
    orderBy?: ServiceFeeOrderByWithRelationInput | ServiceFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceFees
    **/
    _count?: true | ServiceFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceFeeMaxAggregateInputType
  }

  export type GetServiceFeeAggregateType<T extends ServiceFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceFee[P]>
      : GetScalarType<T[P], AggregateServiceFee[P]>
  }




  export type ServiceFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceFeeWhereInput
    orderBy?: ServiceFeeOrderByWithAggregationInput | ServiceFeeOrderByWithAggregationInput[]
    by: ServiceFeeScalarFieldEnum[] | ServiceFeeScalarFieldEnum
    having?: ServiceFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceFeeCountAggregateInputType | true
    _avg?: ServiceFeeAvgAggregateInputType
    _sum?: ServiceFeeSumAggregateInputType
    _min?: ServiceFeeMinAggregateInputType
    _max?: ServiceFeeMaxAggregateInputType
  }

  export type ServiceFeeGroupByOutputType = {
    id: string
    paymentMethod: string
    name: string
    type: string
    value: Decimal
    minFee: Decimal | null
    maxFee: Decimal | null
    isActive: boolean
    requiresManualApproval: boolean
    paymentInstructions: string | null
    instructionType: string | null
    instructionImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    currency: string
    _count: ServiceFeeCountAggregateOutputType | null
    _avg: ServiceFeeAvgAggregateOutputType | null
    _sum: ServiceFeeSumAggregateOutputType | null
    _min: ServiceFeeMinAggregateOutputType | null
    _max: ServiceFeeMaxAggregateOutputType | null
  }

  type GetServiceFeeGroupByPayload<T extends ServiceFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceFeeGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceFeeGroupByOutputType[P]>
        }
      >
    >


  export type ServiceFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minFee?: boolean
    maxFee?: boolean
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
  }, ExtArgs["result"]["serviceFee"]>

  export type ServiceFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minFee?: boolean
    maxFee?: boolean
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
  }, ExtArgs["result"]["serviceFee"]>

  export type ServiceFeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minFee?: boolean
    maxFee?: boolean
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
  }, ExtArgs["result"]["serviceFee"]>

  export type ServiceFeeSelectScalar = {
    id?: boolean
    paymentMethod?: boolean
    name?: boolean
    type?: boolean
    value?: boolean
    minFee?: boolean
    maxFee?: boolean
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: boolean
    instructionType?: boolean
    instructionImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currency?: boolean
  }

  export type ServiceFeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentMethod" | "name" | "type" | "value" | "minFee" | "maxFee" | "isActive" | "requiresManualApproval" | "paymentInstructions" | "instructionType" | "instructionImageUrl" | "createdAt" | "updatedAt" | "currency", ExtArgs["result"]["serviceFee"]>

  export type $ServiceFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceFee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentMethod: string
      name: string
      type: string
      value: Prisma.Decimal
      minFee: Prisma.Decimal | null
      maxFee: Prisma.Decimal | null
      isActive: boolean
      requiresManualApproval: boolean
      paymentInstructions: string | null
      instructionType: string | null
      instructionImageUrl: string | null
      createdAt: Date
      updatedAt: Date
      currency: string
    }, ExtArgs["result"]["serviceFee"]>
    composites: {}
  }

  type ServiceFeeGetPayload<S extends boolean | null | undefined | ServiceFeeDefaultArgs> = $Result.GetResult<Prisma.$ServiceFeePayload, S>

  type ServiceFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceFeeCountAggregateInputType | true
    }

  export interface ServiceFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceFee'], meta: { name: 'ServiceFee' } }
    /**
     * Find zero or one ServiceFee that matches the filter.
     * @param {ServiceFeeFindUniqueArgs} args - Arguments to find a ServiceFee
     * @example
     * // Get one ServiceFee
     * const serviceFee = await prisma.serviceFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFeeFindUniqueArgs>(args: SelectSubset<T, ServiceFeeFindUniqueArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceFee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFeeFindUniqueOrThrowArgs} args - Arguments to find a ServiceFee
     * @example
     * // Get one ServiceFee
     * const serviceFee = await prisma.serviceFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeFindFirstArgs} args - Arguments to find a ServiceFee
     * @example
     * // Get one ServiceFee
     * const serviceFee = await prisma.serviceFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFeeFindFirstArgs>(args?: SelectSubset<T, ServiceFeeFindFirstArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeFindFirstOrThrowArgs} args - Arguments to find a ServiceFee
     * @example
     * // Get one ServiceFee
     * const serviceFee = await prisma.serviceFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceFees
     * const serviceFees = await prisma.serviceFee.findMany()
     * 
     * // Get first 10 ServiceFees
     * const serviceFees = await prisma.serviceFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceFeeWithIdOnly = await prisma.serviceFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFeeFindManyArgs>(args?: SelectSubset<T, ServiceFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceFee.
     * @param {ServiceFeeCreateArgs} args - Arguments to create a ServiceFee.
     * @example
     * // Create one ServiceFee
     * const ServiceFee = await prisma.serviceFee.create({
     *   data: {
     *     // ... data to create a ServiceFee
     *   }
     * })
     * 
     */
    create<T extends ServiceFeeCreateArgs>(args: SelectSubset<T, ServiceFeeCreateArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceFees.
     * @param {ServiceFeeCreateManyArgs} args - Arguments to create many ServiceFees.
     * @example
     * // Create many ServiceFees
     * const serviceFee = await prisma.serviceFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceFeeCreateManyArgs>(args?: SelectSubset<T, ServiceFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceFees and returns the data saved in the database.
     * @param {ServiceFeeCreateManyAndReturnArgs} args - Arguments to create many ServiceFees.
     * @example
     * // Create many ServiceFees
     * const serviceFee = await prisma.serviceFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceFees and only return the `id`
     * const serviceFeeWithIdOnly = await prisma.serviceFee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceFee.
     * @param {ServiceFeeDeleteArgs} args - Arguments to delete one ServiceFee.
     * @example
     * // Delete one ServiceFee
     * const ServiceFee = await prisma.serviceFee.delete({
     *   where: {
     *     // ... filter to delete one ServiceFee
     *   }
     * })
     * 
     */
    delete<T extends ServiceFeeDeleteArgs>(args: SelectSubset<T, ServiceFeeDeleteArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceFee.
     * @param {ServiceFeeUpdateArgs} args - Arguments to update one ServiceFee.
     * @example
     * // Update one ServiceFee
     * const serviceFee = await prisma.serviceFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceFeeUpdateArgs>(args: SelectSubset<T, ServiceFeeUpdateArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceFees.
     * @param {ServiceFeeDeleteManyArgs} args - Arguments to filter ServiceFees to delete.
     * @example
     * // Delete a few ServiceFees
     * const { count } = await prisma.serviceFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceFeeDeleteManyArgs>(args?: SelectSubset<T, ServiceFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceFees
     * const serviceFee = await prisma.serviceFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceFeeUpdateManyArgs>(args: SelectSubset<T, ServiceFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceFees and returns the data updated in the database.
     * @param {ServiceFeeUpdateManyAndReturnArgs} args - Arguments to update many ServiceFees.
     * @example
     * // Update many ServiceFees
     * const serviceFee = await prisma.serviceFee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceFees and only return the `id`
     * const serviceFeeWithIdOnly = await prisma.serviceFee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceFeeUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceFeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceFee.
     * @param {ServiceFeeUpsertArgs} args - Arguments to update or create a ServiceFee.
     * @example
     * // Update or create a ServiceFee
     * const serviceFee = await prisma.serviceFee.upsert({
     *   create: {
     *     // ... data to create a ServiceFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceFee we want to update
     *   }
     * })
     */
    upsert<T extends ServiceFeeUpsertArgs>(args: SelectSubset<T, ServiceFeeUpsertArgs<ExtArgs>>): Prisma__ServiceFeeClient<$Result.GetResult<Prisma.$ServiceFeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeCountArgs} args - Arguments to filter ServiceFees to count.
     * @example
     * // Count the number of ServiceFees
     * const count = await prisma.serviceFee.count({
     *   where: {
     *     // ... the filter for the ServiceFees we want to count
     *   }
     * })
    **/
    count<T extends ServiceFeeCountArgs>(
      args?: Subset<T, ServiceFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceFeeAggregateArgs>(args: Subset<T, ServiceFeeAggregateArgs>): Prisma.PrismaPromise<GetServiceFeeAggregateType<T>>

    /**
     * Group by ServiceFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceFeeGroupByArgs['orderBy'] }
        : { orderBy?: ServiceFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceFee model
   */
  readonly fields: ServiceFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceFee model
   */
  interface ServiceFeeFieldRefs {
    readonly id: FieldRef<"ServiceFee", 'String'>
    readonly paymentMethod: FieldRef<"ServiceFee", 'String'>
    readonly name: FieldRef<"ServiceFee", 'String'>
    readonly type: FieldRef<"ServiceFee", 'String'>
    readonly value: FieldRef<"ServiceFee", 'Decimal'>
    readonly minFee: FieldRef<"ServiceFee", 'Decimal'>
    readonly maxFee: FieldRef<"ServiceFee", 'Decimal'>
    readonly isActive: FieldRef<"ServiceFee", 'Boolean'>
    readonly requiresManualApproval: FieldRef<"ServiceFee", 'Boolean'>
    readonly paymentInstructions: FieldRef<"ServiceFee", 'String'>
    readonly instructionType: FieldRef<"ServiceFee", 'String'>
    readonly instructionImageUrl: FieldRef<"ServiceFee", 'String'>
    readonly createdAt: FieldRef<"ServiceFee", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceFee", 'DateTime'>
    readonly currency: FieldRef<"ServiceFee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceFee findUnique
   */
  export type ServiceFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceFee to fetch.
     */
    where: ServiceFeeWhereUniqueInput
  }

  /**
   * ServiceFee findUniqueOrThrow
   */
  export type ServiceFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceFee to fetch.
     */
    where: ServiceFeeWhereUniqueInput
  }

  /**
   * ServiceFee findFirst
   */
  export type ServiceFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceFee to fetch.
     */
    where?: ServiceFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFees to fetch.
     */
    orderBy?: ServiceFeeOrderByWithRelationInput | ServiceFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceFees.
     */
    cursor?: ServiceFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceFees.
     */
    distinct?: ServiceFeeScalarFieldEnum | ServiceFeeScalarFieldEnum[]
  }

  /**
   * ServiceFee findFirstOrThrow
   */
  export type ServiceFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceFee to fetch.
     */
    where?: ServiceFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFees to fetch.
     */
    orderBy?: ServiceFeeOrderByWithRelationInput | ServiceFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceFees.
     */
    cursor?: ServiceFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceFees.
     */
    distinct?: ServiceFeeScalarFieldEnum | ServiceFeeScalarFieldEnum[]
  }

  /**
   * ServiceFee findMany
   */
  export type ServiceFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceFees to fetch.
     */
    where?: ServiceFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceFees to fetch.
     */
    orderBy?: ServiceFeeOrderByWithRelationInput | ServiceFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceFees.
     */
    cursor?: ServiceFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceFees.
     */
    skip?: number
    distinct?: ServiceFeeScalarFieldEnum | ServiceFeeScalarFieldEnum[]
  }

  /**
   * ServiceFee create
   */
  export type ServiceFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceFee.
     */
    data: XOR<ServiceFeeCreateInput, ServiceFeeUncheckedCreateInput>
  }

  /**
   * ServiceFee createMany
   */
  export type ServiceFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceFees.
     */
    data: ServiceFeeCreateManyInput | ServiceFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceFee createManyAndReturn
   */
  export type ServiceFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceFees.
     */
    data: ServiceFeeCreateManyInput | ServiceFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceFee update
   */
  export type ServiceFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceFee.
     */
    data: XOR<ServiceFeeUpdateInput, ServiceFeeUncheckedUpdateInput>
    /**
     * Choose, which ServiceFee to update.
     */
    where: ServiceFeeWhereUniqueInput
  }

  /**
   * ServiceFee updateMany
   */
  export type ServiceFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceFees.
     */
    data: XOR<ServiceFeeUpdateManyMutationInput, ServiceFeeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceFees to update
     */
    where?: ServiceFeeWhereInput
    /**
     * Limit how many ServiceFees to update.
     */
    limit?: number
  }

  /**
   * ServiceFee updateManyAndReturn
   */
  export type ServiceFeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * The data used to update ServiceFees.
     */
    data: XOR<ServiceFeeUpdateManyMutationInput, ServiceFeeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceFees to update
     */
    where?: ServiceFeeWhereInput
    /**
     * Limit how many ServiceFees to update.
     */
    limit?: number
  }

  /**
   * ServiceFee upsert
   */
  export type ServiceFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceFee to update in case it exists.
     */
    where: ServiceFeeWhereUniqueInput
    /**
     * In case the ServiceFee found by the `where` argument doesn't exist, create a new ServiceFee with this data.
     */
    create: XOR<ServiceFeeCreateInput, ServiceFeeUncheckedCreateInput>
    /**
     * In case the ServiceFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceFeeUpdateInput, ServiceFeeUncheckedUpdateInput>
  }

  /**
   * ServiceFee delete
   */
  export type ServiceFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
    /**
     * Filter which ServiceFee to delete.
     */
    where: ServiceFeeWhereUniqueInput
  }

  /**
   * ServiceFee deleteMany
   */
  export type ServiceFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceFees to delete
     */
    where?: ServiceFeeWhereInput
    /**
     * Limit how many ServiceFees to delete.
     */
    limit?: number
  }

  /**
   * ServiceFee without action
   */
  export type ServiceFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceFee
     */
    select?: ServiceFeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceFee
     */
    omit?: ServiceFeeOmit<ExtArgs> | null
  }


  /**
   * Model BankDetail
   */

  export type AggregateBankDetail = {
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  export type BankDetailMinAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    swiftCode: string | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailMaxAggregateOutputType = {
    id: string | null
    bankName: string | null
    accountNumber: string | null
    accountName: string | null
    swiftCode: string | null
    currency: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankDetailCountAggregateOutputType = {
    id: number
    bankName: number
    accountNumber: number
    accountName: number
    swiftCode: number
    currency: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankDetailMinAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailMaxAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankDetailCountAggregateInputType = {
    id?: true
    bankName?: true
    accountNumber?: true
    accountName?: true
    swiftCode?: true
    currency?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetail to aggregate.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankDetails
    **/
    _count?: true | BankDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankDetailMaxAggregateInputType
  }

  export type GetBankDetailAggregateType<T extends BankDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateBankDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankDetail[P]>
      : GetScalarType<T[P], AggregateBankDetail[P]>
  }




  export type BankDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankDetailWhereInput
    orderBy?: BankDetailOrderByWithAggregationInput | BankDetailOrderByWithAggregationInput[]
    by: BankDetailScalarFieldEnum[] | BankDetailScalarFieldEnum
    having?: BankDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankDetailCountAggregateInputType | true
    _min?: BankDetailMinAggregateInputType
    _max?: BankDetailMaxAggregateInputType
  }

  export type BankDetailGroupByOutputType = {
    id: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode: string | null
    currency: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BankDetailCountAggregateOutputType | null
    _min: BankDetailMinAggregateOutputType | null
    _max: BankDetailMaxAggregateOutputType | null
  }

  type GetBankDetailGroupByPayload<T extends BankDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
            : GetScalarType<T[P], BankDetailGroupByOutputType[P]>
        }
      >
    >


  export type BankDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankDetail"]>

  export type BankDetailSelectScalar = {
    id?: boolean
    bankName?: boolean
    accountNumber?: boolean
    accountName?: boolean
    swiftCode?: boolean
    currency?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bankName" | "accountNumber" | "accountName" | "swiftCode" | "currency" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["bankDetail"]>

  export type $BankDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bankName: string
      accountNumber: string
      accountName: string
      swiftCode: string | null
      currency: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankDetail"]>
    composites: {}
  }

  type BankDetailGetPayload<S extends boolean | null | undefined | BankDetailDefaultArgs> = $Result.GetResult<Prisma.$BankDetailPayload, S>

  type BankDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankDetailCountAggregateInputType | true
    }

  export interface BankDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankDetail'], meta: { name: 'BankDetail' } }
    /**
     * Find zero or one BankDetail that matches the filter.
     * @param {BankDetailFindUniqueArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankDetailFindUniqueArgs>(args: SelectSubset<T, BankDetailFindUniqueArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankDetailFindUniqueOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, BankDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankDetailFindFirstArgs>(args?: SelectSubset<T, BankDetailFindFirstArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindFirstOrThrowArgs} args - Arguments to find a BankDetail
     * @example
     * // Get one BankDetail
     * const bankDetail = await prisma.bankDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, BankDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankDetails
     * const bankDetails = await prisma.bankDetail.findMany()
     * 
     * // Get first 10 BankDetails
     * const bankDetails = await prisma.bankDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankDetailFindManyArgs>(args?: SelectSubset<T, BankDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankDetail.
     * @param {BankDetailCreateArgs} args - Arguments to create a BankDetail.
     * @example
     * // Create one BankDetail
     * const BankDetail = await prisma.bankDetail.create({
     *   data: {
     *     // ... data to create a BankDetail
     *   }
     * })
     * 
     */
    create<T extends BankDetailCreateArgs>(args: SelectSubset<T, BankDetailCreateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankDetails.
     * @param {BankDetailCreateManyArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankDetailCreateManyArgs>(args?: SelectSubset<T, BankDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankDetails and returns the data saved in the database.
     * @param {BankDetailCreateManyAndReturnArgs} args - Arguments to create many BankDetails.
     * @example
     * // Create many BankDetails
     * const bankDetail = await prisma.bankDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, BankDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankDetail.
     * @param {BankDetailDeleteArgs} args - Arguments to delete one BankDetail.
     * @example
     * // Delete one BankDetail
     * const BankDetail = await prisma.bankDetail.delete({
     *   where: {
     *     // ... filter to delete one BankDetail
     *   }
     * })
     * 
     */
    delete<T extends BankDetailDeleteArgs>(args: SelectSubset<T, BankDetailDeleteArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankDetail.
     * @param {BankDetailUpdateArgs} args - Arguments to update one BankDetail.
     * @example
     * // Update one BankDetail
     * const bankDetail = await prisma.bankDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankDetailUpdateArgs>(args: SelectSubset<T, BankDetailUpdateArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankDetails.
     * @param {BankDetailDeleteManyArgs} args - Arguments to filter BankDetails to delete.
     * @example
     * // Delete a few BankDetails
     * const { count } = await prisma.bankDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankDetailDeleteManyArgs>(args?: SelectSubset<T, BankDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankDetailUpdateManyArgs>(args: SelectSubset<T, BankDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankDetails and returns the data updated in the database.
     * @param {BankDetailUpdateManyAndReturnArgs} args - Arguments to update many BankDetails.
     * @example
     * // Update many BankDetails
     * const bankDetail = await prisma.bankDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankDetails and only return the `id`
     * const bankDetailWithIdOnly = await prisma.bankDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, BankDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankDetail.
     * @param {BankDetailUpsertArgs} args - Arguments to update or create a BankDetail.
     * @example
     * // Update or create a BankDetail
     * const bankDetail = await prisma.bankDetail.upsert({
     *   create: {
     *     // ... data to create a BankDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankDetail we want to update
     *   }
     * })
     */
    upsert<T extends BankDetailUpsertArgs>(args: SelectSubset<T, BankDetailUpsertArgs<ExtArgs>>): Prisma__BankDetailClient<$Result.GetResult<Prisma.$BankDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailCountArgs} args - Arguments to filter BankDetails to count.
     * @example
     * // Count the number of BankDetails
     * const count = await prisma.bankDetail.count({
     *   where: {
     *     // ... the filter for the BankDetails we want to count
     *   }
     * })
    **/
    count<T extends BankDetailCountArgs>(
      args?: Subset<T, BankDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankDetailAggregateArgs>(args: Subset<T, BankDetailAggregateArgs>): Prisma.PrismaPromise<GetBankDetailAggregateType<T>>

    /**
     * Group by BankDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankDetailGroupByArgs['orderBy'] }
        : { orderBy?: BankDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankDetail model
   */
  readonly fields: BankDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankDetail model
   */
  interface BankDetailFieldRefs {
    readonly id: FieldRef<"BankDetail", 'String'>
    readonly bankName: FieldRef<"BankDetail", 'String'>
    readonly accountNumber: FieldRef<"BankDetail", 'String'>
    readonly accountName: FieldRef<"BankDetail", 'String'>
    readonly swiftCode: FieldRef<"BankDetail", 'String'>
    readonly currency: FieldRef<"BankDetail", 'String'>
    readonly isActive: FieldRef<"BankDetail", 'Boolean'>
    readonly createdAt: FieldRef<"BankDetail", 'DateTime'>
    readonly updatedAt: FieldRef<"BankDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankDetail findUnique
   */
  export type BankDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findUniqueOrThrow
   */
  export type BankDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail findFirst
   */
  export type BankDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findFirstOrThrow
   */
  export type BankDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter, which BankDetail to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankDetails.
     */
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail findMany
   */
  export type BankDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter, which BankDetails to fetch.
     */
    where?: BankDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankDetails to fetch.
     */
    orderBy?: BankDetailOrderByWithRelationInput | BankDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankDetails.
     */
    cursor?: BankDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankDetails.
     */
    skip?: number
    distinct?: BankDetailScalarFieldEnum | BankDetailScalarFieldEnum[]
  }

  /**
   * BankDetail create
   */
  export type BankDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data needed to create a BankDetail.
     */
    data: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
  }

  /**
   * BankDetail createMany
   */
  export type BankDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail createManyAndReturn
   */
  export type BankDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to create many BankDetails.
     */
    data: BankDetailCreateManyInput | BankDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankDetail update
   */
  export type BankDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data needed to update a BankDetail.
     */
    data: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
    /**
     * Choose, which BankDetail to update.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail updateMany
   */
  export type BankDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail updateManyAndReturn
   */
  export type BankDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The data used to update BankDetails.
     */
    data: XOR<BankDetailUpdateManyMutationInput, BankDetailUncheckedUpdateManyInput>
    /**
     * Filter which BankDetails to update
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to update.
     */
    limit?: number
  }

  /**
   * BankDetail upsert
   */
  export type BankDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * The filter to search for the BankDetail to update in case it exists.
     */
    where: BankDetailWhereUniqueInput
    /**
     * In case the BankDetail found by the `where` argument doesn't exist, create a new BankDetail with this data.
     */
    create: XOR<BankDetailCreateInput, BankDetailUncheckedCreateInput>
    /**
     * In case the BankDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankDetailUpdateInput, BankDetailUncheckedUpdateInput>
  }

  /**
   * BankDetail delete
   */
  export type BankDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
    /**
     * Filter which BankDetail to delete.
     */
    where: BankDetailWhereUniqueInput
  }

  /**
   * BankDetail deleteMany
   */
  export type BankDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankDetails to delete
     */
    where?: BankDetailWhereInput
    /**
     * Limit how many BankDetails to delete.
     */
    limit?: number
  }

  /**
   * BankDetail without action
   */
  export type BankDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankDetail
     */
    select?: BankDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankDetail
     */
    omit?: BankDetailOmit<ExtArgs> | null
  }


  /**
   * Model Server
   */

  export type AggregateServer = {
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  export type ServerAvgAggregateOutputType = {
    memory: number | null
    vcpus: number | null
    disk: number | null
    priceMonthly: Decimal | null
    priceHourly: Decimal | null
  }

  export type ServerSumAggregateOutputType = {
    memory: number | null
    vcpus: number | null
    disk: number | null
    priceMonthly: Decimal | null
    priceHourly: Decimal | null
  }

  export type ServerMinAggregateOutputType = {
    id: string | null
    dropletId: string | null
    name: string | null
    memory: number | null
    vcpus: number | null
    disk: number | null
    status: string | null
    region: string | null
    regionSlug: string | null
    sizeSlug: string | null
    publicIp: string | null
    privateIp: string | null
    priceMonthly: Decimal | null
    priceHourly: Decimal | null
    imageDistribution: string | null
    imageName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServerMaxAggregateOutputType = {
    id: string | null
    dropletId: string | null
    name: string | null
    memory: number | null
    vcpus: number | null
    disk: number | null
    status: string | null
    region: string | null
    regionSlug: string | null
    sizeSlug: string | null
    publicIp: string | null
    privateIp: string | null
    priceMonthly: Decimal | null
    priceHourly: Decimal | null
    imageDistribution: string | null
    imageName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServerCountAggregateOutputType = {
    id: number
    dropletId: number
    name: number
    memory: number
    vcpus: number
    disk: number
    status: number
    region: number
    regionSlug: number
    sizeSlug: number
    publicIp: number
    privateIp: number
    priceMonthly: number
    priceHourly: number
    tags: number
    features: number
    imageDistribution: number
    imageName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServerAvgAggregateInputType = {
    memory?: true
    vcpus?: true
    disk?: true
    priceMonthly?: true
    priceHourly?: true
  }

  export type ServerSumAggregateInputType = {
    memory?: true
    vcpus?: true
    disk?: true
    priceMonthly?: true
    priceHourly?: true
  }

  export type ServerMinAggregateInputType = {
    id?: true
    dropletId?: true
    name?: true
    memory?: true
    vcpus?: true
    disk?: true
    status?: true
    region?: true
    regionSlug?: true
    sizeSlug?: true
    publicIp?: true
    privateIp?: true
    priceMonthly?: true
    priceHourly?: true
    imageDistribution?: true
    imageName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServerMaxAggregateInputType = {
    id?: true
    dropletId?: true
    name?: true
    memory?: true
    vcpus?: true
    disk?: true
    status?: true
    region?: true
    regionSlug?: true
    sizeSlug?: true
    publicIp?: true
    privateIp?: true
    priceMonthly?: true
    priceHourly?: true
    imageDistribution?: true
    imageName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServerCountAggregateInputType = {
    id?: true
    dropletId?: true
    name?: true
    memory?: true
    vcpus?: true
    disk?: true
    status?: true
    region?: true
    regionSlug?: true
    sizeSlug?: true
    publicIp?: true
    privateIp?: true
    priceMonthly?: true
    priceHourly?: true
    tags?: true
    features?: true
    imageDistribution?: true
    imageName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Server to aggregate.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servers
    **/
    _count?: true | ServerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServerMaxAggregateInputType
  }

  export type GetServerAggregateType<T extends ServerAggregateArgs> = {
        [P in keyof T & keyof AggregateServer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServer[P]>
      : GetScalarType<T[P], AggregateServer[P]>
  }




  export type ServerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServerWhereInput
    orderBy?: ServerOrderByWithAggregationInput | ServerOrderByWithAggregationInput[]
    by: ServerScalarFieldEnum[] | ServerScalarFieldEnum
    having?: ServerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServerCountAggregateInputType | true
    _avg?: ServerAvgAggregateInputType
    _sum?: ServerSumAggregateInputType
    _min?: ServerMinAggregateInputType
    _max?: ServerMaxAggregateInputType
  }

  export type ServerGroupByOutputType = {
    id: string
    dropletId: string
    name: string
    memory: number
    vcpus: number
    disk: number
    status: string
    region: string
    regionSlug: string
    sizeSlug: string
    publicIp: string | null
    privateIp: string | null
    priceMonthly: Decimal
    priceHourly: Decimal
    tags: JsonValue | null
    features: JsonValue | null
    imageDistribution: string | null
    imageName: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServerCountAggregateOutputType | null
    _avg: ServerAvgAggregateOutputType | null
    _sum: ServerSumAggregateOutputType | null
    _min: ServerMinAggregateOutputType | null
    _max: ServerMaxAggregateOutputType | null
  }

  type GetServerGroupByPayload<T extends ServerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServerGroupByOutputType[P]>
            : GetScalarType<T[P], ServerGroupByOutputType[P]>
        }
      >
    >


  export type ServerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dropletId?: boolean
    name?: boolean
    memory?: boolean
    vcpus?: boolean
    disk?: boolean
    status?: boolean
    region?: boolean
    regionSlug?: boolean
    sizeSlug?: boolean
    publicIp?: boolean
    privateIp?: boolean
    priceMonthly?: boolean
    priceHourly?: boolean
    tags?: boolean
    features?: boolean
    imageDistribution?: boolean
    imageName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["server"]>

  export type ServerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dropletId?: boolean
    name?: boolean
    memory?: boolean
    vcpus?: boolean
    disk?: boolean
    status?: boolean
    region?: boolean
    regionSlug?: boolean
    sizeSlug?: boolean
    publicIp?: boolean
    privateIp?: boolean
    priceMonthly?: boolean
    priceHourly?: boolean
    tags?: boolean
    features?: boolean
    imageDistribution?: boolean
    imageName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["server"]>

  export type ServerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dropletId?: boolean
    name?: boolean
    memory?: boolean
    vcpus?: boolean
    disk?: boolean
    status?: boolean
    region?: boolean
    regionSlug?: boolean
    sizeSlug?: boolean
    publicIp?: boolean
    privateIp?: boolean
    priceMonthly?: boolean
    priceHourly?: boolean
    tags?: boolean
    features?: boolean
    imageDistribution?: boolean
    imageName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["server"]>

  export type ServerSelectScalar = {
    id?: boolean
    dropletId?: boolean
    name?: boolean
    memory?: boolean
    vcpus?: boolean
    disk?: boolean
    status?: boolean
    region?: boolean
    regionSlug?: boolean
    sizeSlug?: boolean
    publicIp?: boolean
    privateIp?: boolean
    priceMonthly?: boolean
    priceHourly?: boolean
    tags?: boolean
    features?: boolean
    imageDistribution?: boolean
    imageName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dropletId" | "name" | "memory" | "vcpus" | "disk" | "status" | "region" | "regionSlug" | "sizeSlug" | "publicIp" | "privateIp" | "priceMonthly" | "priceHourly" | "tags" | "features" | "imageDistribution" | "imageName" | "createdAt" | "updatedAt", ExtArgs["result"]["server"]>

  export type $ServerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Server"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dropletId: string
      name: string
      memory: number
      vcpus: number
      disk: number
      status: string
      region: string
      regionSlug: string
      sizeSlug: string
      publicIp: string | null
      privateIp: string | null
      priceMonthly: Prisma.Decimal
      priceHourly: Prisma.Decimal
      tags: Prisma.JsonValue | null
      features: Prisma.JsonValue | null
      imageDistribution: string | null
      imageName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["server"]>
    composites: {}
  }

  type ServerGetPayload<S extends boolean | null | undefined | ServerDefaultArgs> = $Result.GetResult<Prisma.$ServerPayload, S>

  type ServerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServerCountAggregateInputType | true
    }

  export interface ServerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Server'], meta: { name: 'Server' } }
    /**
     * Find zero or one Server that matches the filter.
     * @param {ServerFindUniqueArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServerFindUniqueArgs>(args: SelectSubset<T, ServerFindUniqueArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Server that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServerFindUniqueOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServerFindUniqueOrThrowArgs>(args: SelectSubset<T, ServerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Server that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServerFindFirstArgs>(args?: SelectSubset<T, ServerFindFirstArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Server that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindFirstOrThrowArgs} args - Arguments to find a Server
     * @example
     * // Get one Server
     * const server = await prisma.server.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServerFindFirstOrThrowArgs>(args?: SelectSubset<T, ServerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Servers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servers
     * const servers = await prisma.server.findMany()
     * 
     * // Get first 10 Servers
     * const servers = await prisma.server.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serverWithIdOnly = await prisma.server.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServerFindManyArgs>(args?: SelectSubset<T, ServerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Server.
     * @param {ServerCreateArgs} args - Arguments to create a Server.
     * @example
     * // Create one Server
     * const Server = await prisma.server.create({
     *   data: {
     *     // ... data to create a Server
     *   }
     * })
     * 
     */
    create<T extends ServerCreateArgs>(args: SelectSubset<T, ServerCreateArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Servers.
     * @param {ServerCreateManyArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServerCreateManyArgs>(args?: SelectSubset<T, ServerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Servers and returns the data saved in the database.
     * @param {ServerCreateManyAndReturnArgs} args - Arguments to create many Servers.
     * @example
     * // Create many Servers
     * const server = await prisma.server.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Servers and only return the `id`
     * const serverWithIdOnly = await prisma.server.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServerCreateManyAndReturnArgs>(args?: SelectSubset<T, ServerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Server.
     * @param {ServerDeleteArgs} args - Arguments to delete one Server.
     * @example
     * // Delete one Server
     * const Server = await prisma.server.delete({
     *   where: {
     *     // ... filter to delete one Server
     *   }
     * })
     * 
     */
    delete<T extends ServerDeleteArgs>(args: SelectSubset<T, ServerDeleteArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Server.
     * @param {ServerUpdateArgs} args - Arguments to update one Server.
     * @example
     * // Update one Server
     * const server = await prisma.server.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServerUpdateArgs>(args: SelectSubset<T, ServerUpdateArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Servers.
     * @param {ServerDeleteManyArgs} args - Arguments to filter Servers to delete.
     * @example
     * // Delete a few Servers
     * const { count } = await prisma.server.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServerDeleteManyArgs>(args?: SelectSubset<T, ServerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servers
     * const server = await prisma.server.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServerUpdateManyArgs>(args: SelectSubset<T, ServerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servers and returns the data updated in the database.
     * @param {ServerUpdateManyAndReturnArgs} args - Arguments to update many Servers.
     * @example
     * // Update many Servers
     * const server = await prisma.server.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Servers and only return the `id`
     * const serverWithIdOnly = await prisma.server.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServerUpdateManyAndReturnArgs>(args: SelectSubset<T, ServerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Server.
     * @param {ServerUpsertArgs} args - Arguments to update or create a Server.
     * @example
     * // Update or create a Server
     * const server = await prisma.server.upsert({
     *   create: {
     *     // ... data to create a Server
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Server we want to update
     *   }
     * })
     */
    upsert<T extends ServerUpsertArgs>(args: SelectSubset<T, ServerUpsertArgs<ExtArgs>>): Prisma__ServerClient<$Result.GetResult<Prisma.$ServerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Servers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerCountArgs} args - Arguments to filter Servers to count.
     * @example
     * // Count the number of Servers
     * const count = await prisma.server.count({
     *   where: {
     *     // ... the filter for the Servers we want to count
     *   }
     * })
    **/
    count<T extends ServerCountArgs>(
      args?: Subset<T, ServerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServerAggregateArgs>(args: Subset<T, ServerAggregateArgs>): Prisma.PrismaPromise<GetServerAggregateType<T>>

    /**
     * Group by Server.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServerGroupByArgs['orderBy'] }
        : { orderBy?: ServerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Server model
   */
  readonly fields: ServerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Server.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Server model
   */
  interface ServerFieldRefs {
    readonly id: FieldRef<"Server", 'String'>
    readonly dropletId: FieldRef<"Server", 'String'>
    readonly name: FieldRef<"Server", 'String'>
    readonly memory: FieldRef<"Server", 'Int'>
    readonly vcpus: FieldRef<"Server", 'Int'>
    readonly disk: FieldRef<"Server", 'Int'>
    readonly status: FieldRef<"Server", 'String'>
    readonly region: FieldRef<"Server", 'String'>
    readonly regionSlug: FieldRef<"Server", 'String'>
    readonly sizeSlug: FieldRef<"Server", 'String'>
    readonly publicIp: FieldRef<"Server", 'String'>
    readonly privateIp: FieldRef<"Server", 'String'>
    readonly priceMonthly: FieldRef<"Server", 'Decimal'>
    readonly priceHourly: FieldRef<"Server", 'Decimal'>
    readonly tags: FieldRef<"Server", 'Json'>
    readonly features: FieldRef<"Server", 'Json'>
    readonly imageDistribution: FieldRef<"Server", 'String'>
    readonly imageName: FieldRef<"Server", 'String'>
    readonly createdAt: FieldRef<"Server", 'DateTime'>
    readonly updatedAt: FieldRef<"Server", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Server findUnique
   */
  export type ServerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server findUniqueOrThrow
   */
  export type ServerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server findFirst
   */
  export type ServerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server findFirstOrThrow
   */
  export type ServerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter, which Server to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servers.
     */
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server findMany
   */
  export type ServerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter, which Servers to fetch.
     */
    where?: ServerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servers to fetch.
     */
    orderBy?: ServerOrderByWithRelationInput | ServerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servers.
     */
    cursor?: ServerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servers.
     */
    skip?: number
    distinct?: ServerScalarFieldEnum | ServerScalarFieldEnum[]
  }

  /**
   * Server create
   */
  export type ServerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * The data needed to create a Server.
     */
    data: XOR<ServerCreateInput, ServerUncheckedCreateInput>
  }

  /**
   * Server createMany
   */
  export type ServerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Servers.
     */
    data: ServerCreateManyInput | ServerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Server createManyAndReturn
   */
  export type ServerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * The data used to create many Servers.
     */
    data: ServerCreateManyInput | ServerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Server update
   */
  export type ServerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * The data needed to update a Server.
     */
    data: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
    /**
     * Choose, which Server to update.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server updateMany
   */
  export type ServerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Servers.
     */
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyInput>
    /**
     * Filter which Servers to update
     */
    where?: ServerWhereInput
    /**
     * Limit how many Servers to update.
     */
    limit?: number
  }

  /**
   * Server updateManyAndReturn
   */
  export type ServerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * The data used to update Servers.
     */
    data: XOR<ServerUpdateManyMutationInput, ServerUncheckedUpdateManyInput>
    /**
     * Filter which Servers to update
     */
    where?: ServerWhereInput
    /**
     * Limit how many Servers to update.
     */
    limit?: number
  }

  /**
   * Server upsert
   */
  export type ServerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * The filter to search for the Server to update in case it exists.
     */
    where: ServerWhereUniqueInput
    /**
     * In case the Server found by the `where` argument doesn't exist, create a new Server with this data.
     */
    create: XOR<ServerCreateInput, ServerUncheckedCreateInput>
    /**
     * In case the Server was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServerUpdateInput, ServerUncheckedUpdateInput>
  }

  /**
   * Server delete
   */
  export type ServerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
    /**
     * Filter which Server to delete.
     */
    where: ServerWhereUniqueInput
  }

  /**
   * Server deleteMany
   */
  export type ServerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Servers to delete
     */
    where?: ServerWhereInput
    /**
     * Limit how many Servers to delete.
     */
    limit?: number
  }

  /**
   * Server without action
   */
  export type ServerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Server
     */
    select?: ServerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Server
     */
    omit?: ServerOmit<ExtArgs> | null
  }


  /**
   * Model WhatsAppMessageStats
   */

  export type AggregateWhatsAppMessageStats = {
    _count: WhatsAppMessageStatsCountAggregateOutputType | null
    _avg: WhatsAppMessageStatsAvgAggregateOutputType | null
    _sum: WhatsAppMessageStatsSumAggregateOutputType | null
    _min: WhatsAppMessageStatsMinAggregateOutputType | null
    _max: WhatsAppMessageStatsMaxAggregateOutputType | null
  }

  export type WhatsAppMessageStatsAvgAggregateOutputType = {
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
  }

  export type WhatsAppMessageStatsSumAggregateOutputType = {
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
  }

  export type WhatsAppMessageStatsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageStatsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    totalMessagesSent: number | null
    totalMessagesFailed: number | null
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhatsAppMessageStatsCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    totalMessagesSent: number
    totalMessagesFailed: number
    lastMessageSentAt: number
    lastMessageFailedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhatsAppMessageStatsAvgAggregateInputType = {
    totalMessagesSent?: true
    totalMessagesFailed?: true
  }

  export type WhatsAppMessageStatsSumAggregateInputType = {
    totalMessagesSent?: true
    totalMessagesFailed?: true
  }

  export type WhatsAppMessageStatsMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageStatsMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhatsAppMessageStatsCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    totalMessagesSent?: true
    totalMessagesFailed?: true
    lastMessageSentAt?: true
    lastMessageFailedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhatsAppMessageStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessageStats to aggregate.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppMessageStats
    **/
    _count?: true | WhatsAppMessageStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhatsAppMessageStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhatsAppMessageStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppMessageStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppMessageStatsMaxAggregateInputType
  }

  export type GetWhatsAppMessageStatsAggregateType<T extends WhatsAppMessageStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppMessageStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppMessageStats[P]>
      : GetScalarType<T[P], AggregateWhatsAppMessageStats[P]>
  }




  export type WhatsAppMessageStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppMessageStatsWhereInput
    orderBy?: WhatsAppMessageStatsOrderByWithAggregationInput | WhatsAppMessageStatsOrderByWithAggregationInput[]
    by: WhatsAppMessageStatsScalarFieldEnum[] | WhatsAppMessageStatsScalarFieldEnum
    having?: WhatsAppMessageStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppMessageStatsCountAggregateInputType | true
    _avg?: WhatsAppMessageStatsAvgAggregateInputType
    _sum?: WhatsAppMessageStatsSumAggregateInputType
    _min?: WhatsAppMessageStatsMinAggregateInputType
    _max?: WhatsAppMessageStatsMaxAggregateInputType
  }

  export type WhatsAppMessageStatsGroupByOutputType = {
    id: string
    userId: string
    sessionId: string
    totalMessagesSent: number
    totalMessagesFailed: number
    lastMessageSentAt: Date | null
    lastMessageFailedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WhatsAppMessageStatsCountAggregateOutputType | null
    _avg: WhatsAppMessageStatsAvgAggregateOutputType | null
    _sum: WhatsAppMessageStatsSumAggregateOutputType | null
    _min: WhatsAppMessageStatsMinAggregateOutputType | null
    _max: WhatsAppMessageStatsMaxAggregateOutputType | null
  }

  type GetWhatsAppMessageStatsGroupByPayload<T extends WhatsAppMessageStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppMessageStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppMessageStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppMessageStatsGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppMessageStatsGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppMessageStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppMessageStats"]>

  export type WhatsAppMessageStatsSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    totalMessagesSent?: boolean
    totalMessagesFailed?: boolean
    lastMessageSentAt?: boolean
    lastMessageFailedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhatsAppMessageStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "totalMessagesSent" | "totalMessagesFailed" | "lastMessageSentAt" | "lastMessageFailedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["whatsAppMessageStats"]>
  export type WhatsAppMessageStatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type WhatsAppMessageStatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }
  export type WhatsAppMessageStatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    session?: boolean | WhatsAppSessionDefaultArgs<ExtArgs>
  }

  export type $WhatsAppMessageStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppMessageStats"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      session: Prisma.$WhatsAppSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string
      totalMessagesSent: number
      totalMessagesFailed: number
      lastMessageSentAt: Date | null
      lastMessageFailedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whatsAppMessageStats"]>
    composites: {}
  }

  type WhatsAppMessageStatsGetPayload<S extends boolean | null | undefined | WhatsAppMessageStatsDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppMessageStatsPayload, S>

  type WhatsAppMessageStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppMessageStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppMessageStatsCountAggregateInputType | true
    }

  export interface WhatsAppMessageStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppMessageStats'], meta: { name: 'WhatsAppMessageStats' } }
    /**
     * Find zero or one WhatsAppMessageStats that matches the filter.
     * @param {WhatsAppMessageStatsFindUniqueArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppMessageStatsFindUniqueArgs>(args: SelectSubset<T, WhatsAppMessageStatsFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppMessageStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppMessageStatsFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppMessageStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindFirstArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppMessageStatsFindFirstArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindFirstArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppMessageStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindFirstOrThrowArgs} args - Arguments to find a WhatsAppMessageStats
     * @example
     * // Get one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppMessageStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppMessageStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany()
     * 
     * // Get first 10 WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppMessageStatsFindManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsCreateArgs} args - Arguments to create a WhatsAppMessageStats.
     * @example
     * // Create one WhatsAppMessageStats
     * const WhatsAppMessageStats = await prisma.whatsAppMessageStats.create({
     *   data: {
     *     // ... data to create a WhatsAppMessageStats
     *   }
     * })
     * 
     */
    create<T extends WhatsAppMessageStatsCreateArgs>(args: SelectSubset<T, WhatsAppMessageStatsCreateArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsCreateManyArgs} args - Arguments to create many WhatsAppMessageStats.
     * @example
     * // Create many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppMessageStatsCreateManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppMessageStats and returns the data saved in the database.
     * @param {WhatsAppMessageStatsCreateManyAndReturnArgs} args - Arguments to create many WhatsAppMessageStats.
     * @example
     * // Create many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppMessageStats and only return the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppMessageStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsDeleteArgs} args - Arguments to delete one WhatsAppMessageStats.
     * @example
     * // Delete one WhatsAppMessageStats
     * const WhatsAppMessageStats = await prisma.whatsAppMessageStats.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppMessageStats
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppMessageStatsDeleteArgs>(args: SelectSubset<T, WhatsAppMessageStatsDeleteArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsUpdateArgs} args - Arguments to update one WhatsAppMessageStats.
     * @example
     * // Update one WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppMessageStatsUpdateArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsDeleteManyArgs} args - Arguments to filter WhatsAppMessageStats to delete.
     * @example
     * // Delete a few WhatsAppMessageStats
     * const { count } = await prisma.whatsAppMessageStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppMessageStatsDeleteManyArgs>(args?: SelectSubset<T, WhatsAppMessageStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppMessageStatsUpdateManyArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppMessageStats and returns the data updated in the database.
     * @param {WhatsAppMessageStatsUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppMessageStats.
     * @example
     * // Update many WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppMessageStats and only return the `id`
     * const whatsAppMessageStatsWithIdOnly = await prisma.whatsAppMessageStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppMessageStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppMessageStats.
     * @param {WhatsAppMessageStatsUpsertArgs} args - Arguments to update or create a WhatsAppMessageStats.
     * @example
     * // Update or create a WhatsAppMessageStats
     * const whatsAppMessageStats = await prisma.whatsAppMessageStats.upsert({
     *   create: {
     *     // ... data to create a WhatsAppMessageStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppMessageStats we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppMessageStatsUpsertArgs>(args: SelectSubset<T, WhatsAppMessageStatsUpsertArgs<ExtArgs>>): Prisma__WhatsAppMessageStatsClient<$Result.GetResult<Prisma.$WhatsAppMessageStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsCountArgs} args - Arguments to filter WhatsAppMessageStats to count.
     * @example
     * // Count the number of WhatsAppMessageStats
     * const count = await prisma.whatsAppMessageStats.count({
     *   where: {
     *     // ... the filter for the WhatsAppMessageStats we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppMessageStatsCountArgs>(
      args?: Subset<T, WhatsAppMessageStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppMessageStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppMessageStatsAggregateArgs>(args: Subset<T, WhatsAppMessageStatsAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppMessageStatsAggregateType<T>>

    /**
     * Group by WhatsAppMessageStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppMessageStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppMessageStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppMessageStatsGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppMessageStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppMessageStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppMessageStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppMessageStats model
   */
  readonly fields: WhatsAppMessageStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppMessageStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppMessageStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    session<T extends WhatsAppSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WhatsAppSessionDefaultArgs<ExtArgs>>): Prisma__WhatsAppSessionClient<$Result.GetResult<Prisma.$WhatsAppSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppMessageStats model
   */
  interface WhatsAppMessageStatsFieldRefs {
    readonly id: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly userId: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly sessionId: FieldRef<"WhatsAppMessageStats", 'String'>
    readonly totalMessagesSent: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly totalMessagesFailed: FieldRef<"WhatsAppMessageStats", 'Int'>
    readonly lastMessageSentAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly lastMessageFailedAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly createdAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppMessageStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppMessageStats findUnique
   */
  export type WhatsAppMessageStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats findUniqueOrThrow
   */
  export type WhatsAppMessageStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats findFirst
   */
  export type WhatsAppMessageStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessageStats.
     */
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats findFirstOrThrow
   */
  export type WhatsAppMessageStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppMessageStats.
     */
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats findMany
   */
  export type WhatsAppMessageStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppMessageStats to fetch.
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppMessageStats to fetch.
     */
    orderBy?: WhatsAppMessageStatsOrderByWithRelationInput | WhatsAppMessageStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppMessageStats.
     */
    cursor?: WhatsAppMessageStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppMessageStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppMessageStats.
     */
    skip?: number
    distinct?: WhatsAppMessageStatsScalarFieldEnum | WhatsAppMessageStatsScalarFieldEnum[]
  }

  /**
   * WhatsAppMessageStats create
   */
  export type WhatsAppMessageStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsCreateInput, WhatsAppMessageStatsUncheckedCreateInput>
  }

  /**
   * WhatsAppMessageStats createMany
   */
  export type WhatsAppMessageStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppMessageStats.
     */
    data: WhatsAppMessageStatsCreateManyInput | WhatsAppMessageStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppMessageStats createManyAndReturn
   */
  export type WhatsAppMessageStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppMessageStats.
     */
    data: WhatsAppMessageStatsCreateManyInput | WhatsAppMessageStatsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessageStats update
   */
  export type WhatsAppMessageStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateInput, WhatsAppMessageStatsUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppMessageStats to update.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats updateMany
   */
  export type WhatsAppMessageStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessageStats to update
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to update.
     */
    limit?: number
  }

  /**
   * WhatsAppMessageStats updateManyAndReturn
   */
  export type WhatsAppMessageStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppMessageStats.
     */
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppMessageStats to update
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppMessageStats upsert
   */
  export type WhatsAppMessageStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppMessageStats to update in case it exists.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
    /**
     * In case the WhatsAppMessageStats found by the `where` argument doesn't exist, create a new WhatsAppMessageStats with this data.
     */
    create: XOR<WhatsAppMessageStatsCreateInput, WhatsAppMessageStatsUncheckedCreateInput>
    /**
     * In case the WhatsAppMessageStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppMessageStatsUpdateInput, WhatsAppMessageStatsUncheckedUpdateInput>
  }

  /**
   * WhatsAppMessageStats delete
   */
  export type WhatsAppMessageStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppMessageStats to delete.
     */
    where: WhatsAppMessageStatsWhereUniqueInput
  }

  /**
   * WhatsAppMessageStats deleteMany
   */
  export type WhatsAppMessageStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppMessageStats to delete
     */
    where?: WhatsAppMessageStatsWhereInput
    /**
     * Limit how many WhatsAppMessageStats to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppMessageStats without action
   */
  export type WhatsAppMessageStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppMessageStats
     */
    select?: WhatsAppMessageStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppMessageStats
     */
    omit?: WhatsAppMessageStatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppMessageStatsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    otp: 'otp',
    otpExpires: 'otpExpires',
    otpVerificationDeadline: 'otpVerificationDeadline',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    image: 'image',
    emailVerificationToken: 'emailVerificationToken',
    emailVerificationTokenExpires: 'emailVerificationTokenExpires',
    role: 'role',
    apiKey: 'apiKey',
    updatedAt: 'updatedAt',
    emailOtp: 'emailOtp',
    emailOtpExpires: 'emailOtpExpires',
    resetPasswordOtp: 'resetPasswordOtp',
    resetPasswordOtpExpires: 'resetPasswordOtpExpires',
    resetPasswordLastRequestAt: 'resetPasswordLastRequestAt',
    ssoOtp: 'ssoOtp',
    ssoOtpExpires: 'ssoOtpExpires',
    ssoLastRequestAt: 'ssoLastRequestAt',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_id: 'name_id',
    included: 'included',
    packageId: 'packageId'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const SubcategoryScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_id: 'name_id',
    categoryId: 'categoryId'
  };

  export type SubcategoryScalarFieldEnum = (typeof SubcategoryScalarFieldEnum)[keyof typeof SubcategoryScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_id: 'name_id',
    icon: 'icon'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const AddonScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_id: 'name_id',
    description_en: 'description_en',
    description_id: 'description_id',
    price_idr: 'price_idr',
    price_usd: 'price_usd',
    image: 'image',
    categoryId: 'categoryId'
  };

  export type AddonScalarFieldEnum = (typeof AddonScalarFieldEnum)[keyof typeof AddonScalarFieldEnum]


  export const PackageScalarFieldEnum: {
    id: 'id',
    name_en: 'name_en',
    name_id: 'name_id',
    description_en: 'description_en',
    description_id: 'description_id',
    price_idr: 'price_idr',
    price_usd: 'price_usd',
    image: 'image',
    categoryId: 'categoryId',
    subcategoryId: 'subcategoryId',
    popular: 'popular'
  };

  export type PackageScalarFieldEnum = (typeof PackageScalarFieldEnum)[keyof typeof PackageScalarFieldEnum]


  export const WhatsAppSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    status: 'status',
    qr: 'qr',
    isNotification: 'isNotification',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    aiConfig: 'aiConfig',
    message: 'message',
    sessionName: 'sessionName',
    isTerminated: 'isTerminated'
  };

  export type WhatsAppSessionScalarFieldEnum = (typeof WhatsAppSessionScalarFieldEnum)[keyof typeof WhatsAppSessionScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    transactionDate: 'transactionDate',
    status: 'status',
    amount: 'amount',
    createdAt: 'createdAt',
    type: 'type',
    updatedAt: 'updatedAt',
    discountAmount: 'discountAmount',
    originalAmount: 'originalAmount',
    voucherId: 'voucherId',
    notes: 'notes',
    currency: 'currency',
    finalAmount: 'finalAmount',
    serviceFeeAmount: 'serviceFeeAmount',
    totalAfterDiscount: 'totalAfterDiscount',
    expiresAt: 'expiresAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const TransactionProductScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    packageId: 'packageId',
    quantity: 'quantity',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    referenceLink: 'referenceLink'
  };

  export type TransactionProductScalarFieldEnum = (typeof TransactionProductScalarFieldEnum)[keyof typeof TransactionProductScalarFieldEnum]


  export const TransactionAddonsScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    addonId: 'addonId',
    quantity: 'quantity',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type TransactionAddonsScalarFieldEnum = (typeof TransactionAddonsScalarFieldEnum)[keyof typeof TransactionAddonsScalarFieldEnum]


  export const TransactionWhatsappServiceScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    whatsappPackageId: 'whatsappPackageId',
    duration: 'duration',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type TransactionWhatsappServiceScalarFieldEnum = (typeof TransactionWhatsappServiceScalarFieldEnum)[keyof typeof TransactionWhatsappServiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    amount: 'amount',
    method: 'method',
    status: 'status',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expiresAt: 'expiresAt',
    externalId: 'externalId',
    paymentUrl: 'paymentUrl',
    serviceFee: 'serviceFee',
    adminNotes: 'adminNotes',
    adminAction: 'adminAction',
    adminUserId: 'adminUserId',
    actionDate: 'actionDate'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const WhatsappApiPackageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    priceMonth: 'priceMonth',
    priceYear: 'priceYear',
    maxSession: 'maxSession',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsappApiPackageScalarFieldEnum = (typeof WhatsappApiPackageScalarFieldEnum)[keyof typeof WhatsappApiPackageScalarFieldEnum]


  export const ServicesWhatsappCustomersScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    customerId: 'customerId',
    packageId: 'packageId',
    sessionId: 'sessionId',
    qrCode: 'qrCode',
    status: 'status',
    expiredAt: 'expiredAt',
    activatedAt: 'activatedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesWhatsappCustomersScalarFieldEnum = (typeof ServicesWhatsappCustomersScalarFieldEnum)[keyof typeof ServicesWhatsappCustomersScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isActive: 'isActive',
    lastUsed: 'lastUsed',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const VoucherScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    discountType: 'discountType',
    value: 'value',
    minAmount: 'minAmount',
    maxDiscount: 'maxDiscount',
    maxUses: 'maxUses',
    usedCount: 'usedCount',
    allowMultipleUsePerUser: 'allowMultipleUsePerUser',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VoucherScalarFieldEnum = (typeof VoucherScalarFieldEnum)[keyof typeof VoucherScalarFieldEnum]


  export const VoucherUsageScalarFieldEnum: {
    id: 'id',
    voucherId: 'voucherId',
    userId: 'userId',
    transactionId: 'transactionId',
    usedAt: 'usedAt',
    discountAmount: 'discountAmount'
  };

  export type VoucherUsageScalarFieldEnum = (typeof VoucherUsageScalarFieldEnum)[keyof typeof VoucherUsageScalarFieldEnum]


  export const ServicesProductCustomersScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    customerId: 'customerId',
    packageId: 'packageId',
    quantity: 'quantity',
    websiteUrl: 'websiteUrl',
    driveUrl: 'driveUrl',
    textDescription: 'textDescription',
    domainName: 'domainName',
    domainExpiredAt: 'domainExpiredAt',
    fileAssets: 'fileAssets',
    status: 'status',
    deliveredAt: 'deliveredAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesProductCustomersScalarFieldEnum = (typeof ServicesProductCustomersScalarFieldEnum)[keyof typeof ServicesProductCustomersScalarFieldEnum]


  export const ServicesAddonsCustomersScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    customerId: 'customerId',
    addonDetails: 'addonDetails',
    driveUrl: 'driveUrl',
    fileAssets: 'fileAssets',
    status: 'status',
    deliveredAt: 'deliveredAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServicesAddonsCustomersScalarFieldEnum = (typeof ServicesAddonsCustomersScalarFieldEnum)[keyof typeof ServicesAddonsCustomersScalarFieldEnum]


  export const ServiceFeeScalarFieldEnum: {
    id: 'id',
    paymentMethod: 'paymentMethod',
    name: 'name',
    type: 'type',
    value: 'value',
    minFee: 'minFee',
    maxFee: 'maxFee',
    isActive: 'isActive',
    requiresManualApproval: 'requiresManualApproval',
    paymentInstructions: 'paymentInstructions',
    instructionType: 'instructionType',
    instructionImageUrl: 'instructionImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    currency: 'currency'
  };

  export type ServiceFeeScalarFieldEnum = (typeof ServiceFeeScalarFieldEnum)[keyof typeof ServiceFeeScalarFieldEnum]


  export const BankDetailScalarFieldEnum: {
    id: 'id',
    bankName: 'bankName',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    swiftCode: 'swiftCode',
    currency: 'currency',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankDetailScalarFieldEnum = (typeof BankDetailScalarFieldEnum)[keyof typeof BankDetailScalarFieldEnum]


  export const ServerScalarFieldEnum: {
    id: 'id',
    dropletId: 'dropletId',
    name: 'name',
    memory: 'memory',
    vcpus: 'vcpus',
    disk: 'disk',
    status: 'status',
    region: 'region',
    regionSlug: 'regionSlug',
    sizeSlug: 'sizeSlug',
    publicIp: 'publicIp',
    privateIp: 'privateIp',
    priceMonthly: 'priceMonthly',
    priceHourly: 'priceHourly',
    tags: 'tags',
    features: 'features',
    imageDistribution: 'imageDistribution',
    imageName: 'imageName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServerScalarFieldEnum = (typeof ServerScalarFieldEnum)[keyof typeof ServerScalarFieldEnum]


  export const WhatsAppMessageStatsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    totalMessagesSent: 'totalMessagesSent',
    totalMessagesFailed: 'totalMessagesFailed',
    lastMessageSentAt: 'lastMessageSentAt',
    lastMessageFailedAt: 'lastMessageFailedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhatsAppMessageStatsScalarFieldEnum = (typeof WhatsAppMessageStatsScalarFieldEnum)[keyof typeof WhatsAppMessageStatsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    apiKey?: StringNullableFilter<"User"> | string | null
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailOtp?: StringNullableFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    transactions?: TransactionListRelationFilter
    userSessions?: UserSessionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
    whatsAppSessions?: WhatsAppSessionListRelationFilter
    productCustomers?: ServicesProductCustomersListRelationFilter
    addonCustomers?: ServicesAddonsCustomersListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    whatsappMessageStats?: WhatsAppMessageStatsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    otpVerificationDeadline?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationTokenExpires?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    resetPasswordOtp?: SortOrderInput | SortOrder
    resetPasswordOtpExpires?: SortOrderInput | SortOrder
    resetPasswordLastRequestAt?: SortOrderInput | SortOrder
    ssoOtp?: SortOrderInput | SortOrder
    ssoOtpExpires?: SortOrderInput | SortOrder
    ssoLastRequestAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
    whatsAppSessions?: WhatsAppSessionOrderByRelationAggregateInput
    productCustomers?: ServicesProductCustomersOrderByRelationAggregateInput
    addonCustomers?: ServicesAddonsCustomersOrderByRelationAggregateInput
    whatsappCustomers?: ServicesWhatsappCustomersOrderByRelationAggregateInput
    whatsappMessageStats?: WhatsAppMessageStatsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    emailVerificationToken?: string
    apiKey?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    otp?: StringNullableFilter<"User"> | string | null
    otpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    emailOtp?: StringNullableFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    transactions?: TransactionListRelationFilter
    userSessions?: UserSessionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
    whatsAppSessions?: WhatsAppSessionListRelationFilter
    productCustomers?: ServicesProductCustomersListRelationFilter
    addonCustomers?: ServicesAddonsCustomersListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    whatsappMessageStats?: WhatsAppMessageStatsListRelationFilter
  }, "id" | "email" | "phone" | "emailVerificationToken" | "apiKey">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    otp?: SortOrderInput | SortOrder
    otpExpires?: SortOrderInput | SortOrder
    otpVerificationDeadline?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    emailVerificationTokenExpires?: SortOrderInput | SortOrder
    role?: SortOrder
    apiKey?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrderInput | SortOrder
    emailOtpExpires?: SortOrderInput | SortOrder
    resetPasswordOtp?: SortOrderInput | SortOrder
    resetPasswordOtpExpires?: SortOrderInput | SortOrder
    resetPasswordLastRequestAt?: SortOrderInput | SortOrder
    ssoOtp?: SortOrderInput | SortOrder
    ssoOtpExpires?: SortOrderInput | SortOrder
    ssoLastRequestAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    otp?: StringNullableWithAggregatesFilter<"User"> | string | null
    otpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    otpVerificationDeadline?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerificationTokenExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    apiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetPasswordOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetPasswordLastRequestAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoOtp?: StringNullableWithAggregatesFilter<"User"> | string | null
    ssoOtpExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    ssoLastRequestAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: StringFilter<"Feature"> | string
    name_en?: StringFilter<"Feature"> | string
    name_id?: StringFilter<"Feature"> | string
    included?: BoolFilter<"Feature"> | boolean
    packageId?: StringFilter<"Feature"> | string
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    included?: SortOrder
    packageId?: SortOrder
    package?: PackageOrderByWithRelationInput
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    name_en?: StringFilter<"Feature"> | string
    name_id?: StringFilter<"Feature"> | string
    included?: BoolFilter<"Feature"> | boolean
    packageId?: StringFilter<"Feature"> | string
    package?: XOR<PackageScalarRelationFilter, PackageWhereInput>
  }, "id">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    included?: SortOrder
    packageId?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feature"> | string
    name_en?: StringWithAggregatesFilter<"Feature"> | string
    name_id?: StringWithAggregatesFilter<"Feature"> | string
    included?: BoolWithAggregatesFilter<"Feature"> | boolean
    packageId?: StringWithAggregatesFilter<"Feature"> | string
  }

  export type SubcategoryWhereInput = {
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name_en?: StringFilter<"Subcategory"> | string
    name_id?: StringFilter<"Subcategory"> | string
    categoryId?: StringFilter<"Subcategory"> | string
    packages?: PackageListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }

  export type SubcategoryOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    categoryId?: SortOrder
    packages?: PackageOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
  }

  export type SubcategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_name_en?: SubcategoryCategoryIdName_enCompoundUniqueInput
    categoryId_name_id?: SubcategoryCategoryIdName_idCompoundUniqueInput
    AND?: SubcategoryWhereInput | SubcategoryWhereInput[]
    OR?: SubcategoryWhereInput[]
    NOT?: SubcategoryWhereInput | SubcategoryWhereInput[]
    name_en?: StringFilter<"Subcategory"> | string
    name_id?: StringFilter<"Subcategory"> | string
    categoryId?: StringFilter<"Subcategory"> | string
    packages?: PackageListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
  }, "id" | "categoryId_name_en" | "categoryId_name_id">

  export type SubcategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    categoryId?: SortOrder
    _count?: SubcategoryCountOrderByAggregateInput
    _max?: SubcategoryMaxOrderByAggregateInput
    _min?: SubcategoryMinOrderByAggregateInput
  }

  export type SubcategoryScalarWhereWithAggregatesInput = {
    AND?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    OR?: SubcategoryScalarWhereWithAggregatesInput[]
    NOT?: SubcategoryScalarWhereWithAggregatesInput | SubcategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subcategory"> | string
    name_en?: StringWithAggregatesFilter<"Subcategory"> | string
    name_id?: StringWithAggregatesFilter<"Subcategory"> | string
    categoryId?: StringWithAggregatesFilter<"Subcategory"> | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name_en?: StringFilter<"Category"> | string
    name_id?: StringFilter<"Category"> | string
    icon?: StringFilter<"Category"> | string
    addons?: AddonListRelationFilter
    packages?: PackageListRelationFilter
    subcategories?: SubcategoryListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    icon?: SortOrder
    addons?: AddonOrderByRelationAggregateInput
    packages?: PackageOrderByRelationAggregateInput
    subcategories?: SubcategoryOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name_en?: StringFilter<"Category"> | string
    name_id?: StringFilter<"Category"> | string
    icon?: StringFilter<"Category"> | string
    addons?: AddonListRelationFilter
    packages?: PackageListRelationFilter
    subcategories?: SubcategoryListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    icon?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name_en?: StringWithAggregatesFilter<"Category"> | string
    name_id?: StringWithAggregatesFilter<"Category"> | string
    icon?: StringWithAggregatesFilter<"Category"> | string
  }

  export type AddonWhereInput = {
    AND?: AddonWhereInput | AddonWhereInput[]
    OR?: AddonWhereInput[]
    NOT?: AddonWhereInput | AddonWhereInput[]
    id?: StringFilter<"Addon"> | string
    name_en?: StringFilter<"Addon"> | string
    name_id?: StringFilter<"Addon"> | string
    description_en?: StringNullableFilter<"Addon"> | string | null
    description_id?: StringNullableFilter<"Addon"> | string | null
    price_idr?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableFilter<"Addon"> | string | null
    categoryId?: StringFilter<"Addon"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    addonTransactions?: TransactionAddonsListRelationFilter
  }

  export type AddonOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrderInput | SortOrder
    description_id?: SortOrderInput | SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    addonTransactions?: TransactionAddonsOrderByRelationAggregateInput
  }

  export type AddonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    categoryId_name_en?: AddonCategoryIdName_enCompoundUniqueInput
    categoryId_name_id?: AddonCategoryIdName_idCompoundUniqueInput
    AND?: AddonWhereInput | AddonWhereInput[]
    OR?: AddonWhereInput[]
    NOT?: AddonWhereInput | AddonWhereInput[]
    name_en?: StringFilter<"Addon"> | string
    name_id?: StringFilter<"Addon"> | string
    description_en?: StringNullableFilter<"Addon"> | string | null
    description_id?: StringNullableFilter<"Addon"> | string | null
    price_idr?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableFilter<"Addon"> | string | null
    categoryId?: StringFilter<"Addon"> | string
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    addonTransactions?: TransactionAddonsListRelationFilter
  }, "id" | "categoryId_name_en" | "categoryId_name_id">

  export type AddonOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrderInput | SortOrder
    description_id?: SortOrderInput | SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: AddonCountOrderByAggregateInput
    _avg?: AddonAvgOrderByAggregateInput
    _max?: AddonMaxOrderByAggregateInput
    _min?: AddonMinOrderByAggregateInput
    _sum?: AddonSumOrderByAggregateInput
  }

  export type AddonScalarWhereWithAggregatesInput = {
    AND?: AddonScalarWhereWithAggregatesInput | AddonScalarWhereWithAggregatesInput[]
    OR?: AddonScalarWhereWithAggregatesInput[]
    NOT?: AddonScalarWhereWithAggregatesInput | AddonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Addon"> | string
    name_en?: StringWithAggregatesFilter<"Addon"> | string
    name_id?: StringWithAggregatesFilter<"Addon"> | string
    description_en?: StringNullableWithAggregatesFilter<"Addon"> | string | null
    description_id?: StringNullableWithAggregatesFilter<"Addon"> | string | null
    price_idr?: DecimalWithAggregatesFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalWithAggregatesFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableWithAggregatesFilter<"Addon"> | string | null
    categoryId?: StringWithAggregatesFilter<"Addon"> | string
  }

  export type PackageWhereInput = {
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    id?: StringFilter<"Package"> | string
    name_en?: StringFilter<"Package"> | string
    name_id?: StringFilter<"Package"> | string
    description_en?: StringFilter<"Package"> | string
    description_id?: StringFilter<"Package"> | string
    price_idr?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    image?: StringFilter<"Package"> | string
    categoryId?: StringFilter<"Package"> | string
    subcategoryId?: StringFilter<"Package"> | string
    popular?: BoolNullableFilter<"Package"> | boolean | null
    features?: FeatureListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryScalarRelationFilter, SubcategoryWhereInput>
    productTransactions?: TransactionProductListRelationFilter
    productCustomers?: ServicesProductCustomersListRelationFilter
  }

  export type PackageOrderByWithRelationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    popular?: SortOrderInput | SortOrder
    features?: FeatureOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    subcategory?: SubcategoryOrderByWithRelationInput
    productTransactions?: TransactionProductOrderByRelationAggregateInput
    productCustomers?: ServicesProductCustomersOrderByRelationAggregateInput
  }

  export type PackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PackageWhereInput | PackageWhereInput[]
    OR?: PackageWhereInput[]
    NOT?: PackageWhereInput | PackageWhereInput[]
    name_en?: StringFilter<"Package"> | string
    name_id?: StringFilter<"Package"> | string
    description_en?: StringFilter<"Package"> | string
    description_id?: StringFilter<"Package"> | string
    price_idr?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    image?: StringFilter<"Package"> | string
    categoryId?: StringFilter<"Package"> | string
    subcategoryId?: StringFilter<"Package"> | string
    popular?: BoolNullableFilter<"Package"> | boolean | null
    features?: FeatureListRelationFilter
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    subcategory?: XOR<SubcategoryScalarRelationFilter, SubcategoryWhereInput>
    productTransactions?: TransactionProductListRelationFilter
    productCustomers?: ServicesProductCustomersListRelationFilter
  }, "id">

  export type PackageOrderByWithAggregationInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    popular?: SortOrderInput | SortOrder
    _count?: PackageCountOrderByAggregateInput
    _avg?: PackageAvgOrderByAggregateInput
    _max?: PackageMaxOrderByAggregateInput
    _min?: PackageMinOrderByAggregateInput
    _sum?: PackageSumOrderByAggregateInput
  }

  export type PackageScalarWhereWithAggregatesInput = {
    AND?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    OR?: PackageScalarWhereWithAggregatesInput[]
    NOT?: PackageScalarWhereWithAggregatesInput | PackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Package"> | string
    name_en?: StringWithAggregatesFilter<"Package"> | string
    name_id?: StringWithAggregatesFilter<"Package"> | string
    description_en?: StringWithAggregatesFilter<"Package"> | string
    description_id?: StringWithAggregatesFilter<"Package"> | string
    price_idr?: DecimalWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalWithAggregatesFilter<"Package"> | Decimal | DecimalJsLike | number | string
    image?: StringWithAggregatesFilter<"Package"> | string
    categoryId?: StringWithAggregatesFilter<"Package"> | string
    subcategoryId?: StringWithAggregatesFilter<"Package"> | string
    popular?: BoolNullableWithAggregatesFilter<"Package"> | boolean | null
  }

  export type WhatsAppSessionWhereInput = {
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    sessionId?: StringFilter<"WhatsAppSession"> | string
    userId?: StringFilter<"WhatsAppSession"> | string
    status?: StringFilter<"WhatsAppSession"> | string
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    isNotification?: BoolFilter<"WhatsAppSession"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    aiConfig?: StringNullableFilter<"WhatsAppSession"> | string | null
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringNullableFilter<"WhatsAppSession"> | string | null
    isTerminated?: BoolFilter<"WhatsAppSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    whatsappMessageStats?: WhatsAppMessageStatsListRelationFilter
  }

  export type WhatsAppSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    qr?: SortOrderInput | SortOrder
    isNotification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiConfig?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    sessionName?: SortOrderInput | SortOrder
    isTerminated?: SortOrder
    user?: UserOrderByWithRelationInput
    whatsappMessageStats?: WhatsAppMessageStatsOrderByRelationAggregateInput
  }

  export type WhatsAppSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    OR?: WhatsAppSessionWhereInput[]
    NOT?: WhatsAppSessionWhereInput | WhatsAppSessionWhereInput[]
    userId?: StringFilter<"WhatsAppSession"> | string
    status?: StringFilter<"WhatsAppSession"> | string
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    isNotification?: BoolFilter<"WhatsAppSession"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    aiConfig?: StringNullableFilter<"WhatsAppSession"> | string | null
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringNullableFilter<"WhatsAppSession"> | string | null
    isTerminated?: BoolFilter<"WhatsAppSession"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    whatsappMessageStats?: WhatsAppMessageStatsListRelationFilter
  }, "id" | "sessionId">

  export type WhatsAppSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    qr?: SortOrderInput | SortOrder
    isNotification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiConfig?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    sessionName?: SortOrderInput | SortOrder
    isTerminated?: SortOrder
    _count?: WhatsAppSessionCountOrderByAggregateInput
    _max?: WhatsAppSessionMaxOrderByAggregateInput
    _min?: WhatsAppSessionMinOrderByAggregateInput
  }

  export type WhatsAppSessionScalarWhereWithAggregatesInput = {
    AND?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    OR?: WhatsAppSessionScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppSessionScalarWhereWithAggregatesInput | WhatsAppSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    sessionId?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    userId?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    status?: StringWithAggregatesFilter<"WhatsAppSession"> | string
    qr?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    isNotification?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppSession"> | Date | string
    aiConfig?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    message?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    sessionName?: StringNullableWithAggregatesFilter<"WhatsAppSession"> | string | null
    isTerminated?: BoolWithAggregatesFilter<"WhatsAppSession"> | boolean
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    productTransactions?: TransactionProductListRelationFilter
    addonTransactions?: TransactionAddonsListRelationFilter
    whatsappTransaction?: XOR<TransactionWhatsappServiceNullableScalarRelationFilter, TransactionWhatsappServiceWhereInput> | null
    productCustomers?: ServicesProductCustomersListRelationFilter
    addonCustomers?: ServicesAddonsCustomersListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currency?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    serviceFeeAmount?: SortOrderInput | SortOrder
    totalAfterDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    payment?: PaymentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
    productTransactions?: TransactionProductOrderByRelationAggregateInput
    addonTransactions?: TransactionAddonsOrderByRelationAggregateInput
    whatsappTransaction?: TransactionWhatsappServiceOrderByWithRelationInput
    productCustomers?: ServicesProductCustomersOrderByRelationAggregateInput
    addonCustomers?: ServicesAddonsCustomersOrderByRelationAggregateInput
    whatsappCustomers?: ServicesWhatsappCustomersOrderByRelationAggregateInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherNullableScalarRelationFilter, VoucherWhereInput> | null
    productTransactions?: TransactionProductListRelationFilter
    addonTransactions?: TransactionAddonsListRelationFilter
    whatsappTransaction?: XOR<TransactionWhatsappServiceNullableScalarRelationFilter, TransactionWhatsappServiceWhereInput> | null
    productCustomers?: ServicesProductCustomersListRelationFilter
    addonCustomers?: ServicesAddonsCustomersListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrderInput | SortOrder
    originalAmount?: SortOrderInput | SortOrder
    voucherId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    currency?: SortOrder
    finalAmount?: SortOrderInput | SortOrder
    serviceFeeAmount?: SortOrderInput | SortOrder
    totalAfterDiscount?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    transactionDate?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    type?: StringWithAggregatesFilter<"Transaction"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    finalAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
  }

  export type TransactionProductWhereInput = {
    AND?: TransactionProductWhereInput | TransactionProductWhereInput[]
    OR?: TransactionProductWhereInput[]
    NOT?: TransactionProductWhereInput | TransactionProductWhereInput[]
    id?: StringFilter<"TransactionProduct"> | string
    transactionId?: StringFilter<"TransactionProduct"> | string
    packageId?: StringNullableFilter<"TransactionProduct"> | string | null
    quantity?: IntFilter<"TransactionProduct"> | number
    status?: StringFilter<"TransactionProduct"> | string
    startDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    referenceLink?: StringNullableFilter<"TransactionProduct"> | string | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionProductOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    referenceLink?: SortOrderInput | SortOrder
    package?: PackageOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionProductWhereInput | TransactionProductWhereInput[]
    OR?: TransactionProductWhereInput[]
    NOT?: TransactionProductWhereInput | TransactionProductWhereInput[]
    transactionId?: StringFilter<"TransactionProduct"> | string
    packageId?: StringNullableFilter<"TransactionProduct"> | string | null
    quantity?: IntFilter<"TransactionProduct"> | number
    status?: StringFilter<"TransactionProduct"> | string
    startDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    referenceLink?: StringNullableFilter<"TransactionProduct"> | string | null
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type TransactionProductOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    referenceLink?: SortOrderInput | SortOrder
    _count?: TransactionProductCountOrderByAggregateInput
    _avg?: TransactionProductAvgOrderByAggregateInput
    _max?: TransactionProductMaxOrderByAggregateInput
    _min?: TransactionProductMinOrderByAggregateInput
    _sum?: TransactionProductSumOrderByAggregateInput
  }

  export type TransactionProductScalarWhereWithAggregatesInput = {
    AND?: TransactionProductScalarWhereWithAggregatesInput | TransactionProductScalarWhereWithAggregatesInput[]
    OR?: TransactionProductScalarWhereWithAggregatesInput[]
    NOT?: TransactionProductScalarWhereWithAggregatesInput | TransactionProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionProduct"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionProduct"> | string
    packageId?: StringNullableWithAggregatesFilter<"TransactionProduct"> | string | null
    quantity?: IntWithAggregatesFilter<"TransactionProduct"> | number
    status?: StringWithAggregatesFilter<"TransactionProduct"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"TransactionProduct"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"TransactionProduct"> | Date | string | null
    referenceLink?: StringNullableWithAggregatesFilter<"TransactionProduct"> | string | null
  }

  export type TransactionAddonsWhereInput = {
    AND?: TransactionAddonsWhereInput | TransactionAddonsWhereInput[]
    OR?: TransactionAddonsWhereInput[]
    NOT?: TransactionAddonsWhereInput | TransactionAddonsWhereInput[]
    id?: StringFilter<"TransactionAddons"> | string
    transactionId?: StringFilter<"TransactionAddons"> | string
    addonId?: StringFilter<"TransactionAddons"> | string
    quantity?: IntFilter<"TransactionAddons"> | number
    status?: StringFilter<"TransactionAddons"> | string
    startDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
    addon?: XOR<AddonScalarRelationFilter, AddonWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type TransactionAddonsOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    addonId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    addon?: AddonOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type TransactionAddonsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionAddonsWhereInput | TransactionAddonsWhereInput[]
    OR?: TransactionAddonsWhereInput[]
    NOT?: TransactionAddonsWhereInput | TransactionAddonsWhereInput[]
    transactionId?: StringFilter<"TransactionAddons"> | string
    addonId?: StringFilter<"TransactionAddons"> | string
    quantity?: IntFilter<"TransactionAddons"> | number
    status?: StringFilter<"TransactionAddons"> | string
    startDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
    addon?: XOR<AddonScalarRelationFilter, AddonWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type TransactionAddonsOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    addonId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: TransactionAddonsCountOrderByAggregateInput
    _avg?: TransactionAddonsAvgOrderByAggregateInput
    _max?: TransactionAddonsMaxOrderByAggregateInput
    _min?: TransactionAddonsMinOrderByAggregateInput
    _sum?: TransactionAddonsSumOrderByAggregateInput
  }

  export type TransactionAddonsScalarWhereWithAggregatesInput = {
    AND?: TransactionAddonsScalarWhereWithAggregatesInput | TransactionAddonsScalarWhereWithAggregatesInput[]
    OR?: TransactionAddonsScalarWhereWithAggregatesInput[]
    NOT?: TransactionAddonsScalarWhereWithAggregatesInput | TransactionAddonsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionAddons"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionAddons"> | string
    addonId?: StringWithAggregatesFilter<"TransactionAddons"> | string
    quantity?: IntWithAggregatesFilter<"TransactionAddons"> | number
    status?: StringWithAggregatesFilter<"TransactionAddons"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"TransactionAddons"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"TransactionAddons"> | Date | string | null
  }

  export type TransactionWhatsappServiceWhereInput = {
    AND?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    OR?: TransactionWhatsappServiceWhereInput[]
    NOT?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    id?: StringFilter<"TransactionWhatsappService"> | string
    transactionId?: StringFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    whatsappPackage?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }

  export type TransactionWhatsappServiceOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
    whatsappPackage?: WhatsappApiPackageOrderByWithRelationInput
  }

  export type TransactionWhatsappServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    OR?: TransactionWhatsappServiceWhereInput[]
    NOT?: TransactionWhatsappServiceWhereInput | TransactionWhatsappServiceWhereInput[]
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    whatsappPackage?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }, "id" | "transactionId">

  export type TransactionWhatsappServiceOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: TransactionWhatsappServiceCountOrderByAggregateInput
    _max?: TransactionWhatsappServiceMaxOrderByAggregateInput
    _min?: TransactionWhatsappServiceMinOrderByAggregateInput
  }

  export type TransactionWhatsappServiceScalarWhereWithAggregatesInput = {
    AND?: TransactionWhatsappServiceScalarWhereWithAggregatesInput | TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    OR?: TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    NOT?: TransactionWhatsappServiceScalarWhereWithAggregatesInput | TransactionWhatsappServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    duration?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    status?: StringWithAggregatesFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"TransactionWhatsappService"> | Date | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    transactionId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentUrl?: StringNullableFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableFilter<"Payment"> | string | null
    adminAction?: StringNullableFilter<"Payment"> | string | null
    adminUserId?: StringNullableFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    adminAction?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    actionDate?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentUrl?: StringNullableFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableFilter<"Payment"> | string | null
    adminAction?: StringNullableFilter<"Payment"> | string | null
    adminUserId?: StringNullableFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableFilter<"Payment"> | Date | string | null
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id" | "transactionId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentUrl?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    adminAction?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    actionDate?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    externalId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    serviceFee?: DecimalNullableWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    adminAction?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    adminUserId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    actionDate?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
  }

  export type WhatsappApiPackageWhereInput = {
    AND?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    OR?: WhatsappApiPackageWhereInput[]
    NOT?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    id?: StringFilter<"WhatsappApiPackage"> | string
    name?: StringFilter<"WhatsappApiPackage"> | string
    description?: StringNullableFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntFilter<"WhatsappApiPackage"> | number
    priceYear?: IntFilter<"WhatsappApiPackage"> | number
    maxSession?: IntFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    whatsappTransactions?: TransactionWhatsappServiceListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
  }

  export type WhatsappApiPackageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    whatsappTransactions?: TransactionWhatsappServiceOrderByRelationAggregateInput
    whatsappCustomers?: ServicesWhatsappCustomersOrderByRelationAggregateInput
  }

  export type WhatsappApiPackageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    OR?: WhatsappApiPackageWhereInput[]
    NOT?: WhatsappApiPackageWhereInput | WhatsappApiPackageWhereInput[]
    name?: StringFilter<"WhatsappApiPackage"> | string
    description?: StringNullableFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntFilter<"WhatsappApiPackage"> | number
    priceYear?: IntFilter<"WhatsappApiPackage"> | number
    maxSession?: IntFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsappApiPackage"> | Date | string
    whatsappTransactions?: TransactionWhatsappServiceListRelationFilter
    whatsappCustomers?: ServicesWhatsappCustomersListRelationFilter
  }, "id">

  export type WhatsappApiPackageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsappApiPackageCountOrderByAggregateInput
    _avg?: WhatsappApiPackageAvgOrderByAggregateInput
    _max?: WhatsappApiPackageMaxOrderByAggregateInput
    _min?: WhatsappApiPackageMinOrderByAggregateInput
    _sum?: WhatsappApiPackageSumOrderByAggregateInput
  }

  export type WhatsappApiPackageScalarWhereWithAggregatesInput = {
    AND?: WhatsappApiPackageScalarWhereWithAggregatesInput | WhatsappApiPackageScalarWhereWithAggregatesInput[]
    OR?: WhatsappApiPackageScalarWhereWithAggregatesInput[]
    NOT?: WhatsappApiPackageScalarWhereWithAggregatesInput | WhatsappApiPackageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsappApiPackage"> | string
    name?: StringWithAggregatesFilter<"WhatsappApiPackage"> | string
    description?: StringNullableWithAggregatesFilter<"WhatsappApiPackage"> | string | null
    priceMonth?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    priceYear?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    maxSession?: IntWithAggregatesFilter<"WhatsappApiPackage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"WhatsappApiPackage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsappApiPackage"> | Date | string
  }

  export type ServicesWhatsappCustomersWhereInput = {
    AND?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    OR?: ServicesWhatsappCustomersWhereInput[]
    NOT?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    id?: StringFilter<"ServicesWhatsappCustomers"> | string
    transactionId?: StringFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    sessionId?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    qrCode?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ServicesWhatsappCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    package?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }

  export type ServicesWhatsappCustomersOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    package?: WhatsappApiPackageOrderByWithRelationInput
  }

  export type ServicesWhatsappCustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customerId_packageId?: ServicesWhatsappCustomersCustomerIdPackageIdCompoundUniqueInput
    AND?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    OR?: ServicesWhatsappCustomersWhereInput[]
    NOT?: ServicesWhatsappCustomersWhereInput | ServicesWhatsappCustomersWhereInput[]
    transactionId?: StringFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    sessionId?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    qrCode?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ServicesWhatsappCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    package?: XOR<WhatsappApiPackageScalarRelationFilter, WhatsappApiPackageWhereInput>
  }, "id" | "customerId_packageId">

  export type ServicesWhatsappCustomersOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicesWhatsappCustomersCountOrderByAggregateInput
    _max?: ServicesWhatsappCustomersMaxOrderByAggregateInput
    _min?: ServicesWhatsappCustomersMinOrderByAggregateInput
  }

  export type ServicesWhatsappCustomersScalarWhereWithAggregatesInput = {
    AND?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput | ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    OR?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    NOT?: ServicesWhatsappCustomersScalarWhereWithAggregatesInput | ServicesWhatsappCustomersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    transactionId?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    sessionId?: StringNullableWithAggregatesFilter<"ServicesWhatsappCustomers"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"ServicesWhatsappCustomers"> | string | null
    status?: StringWithAggregatesFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeNullableWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ServicesWhatsappCustomers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicesWhatsappCustomers"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    id?: StringFilter<"UserSession"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    id?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    lastUsed?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    id?: StringWithAggregatesFilter<"UserSession"> | string
  }

  export type VoucherWhereInput = {
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    id?: StringFilter<"Voucher"> | string
    code?: StringFilter<"Voucher"> | string
    name?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: StringFilter<"Voucher"> | string
    discountType?: StringFilter<"Voucher"> | string
    value?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolFilter<"Voucher"> | boolean
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    transactions?: TransactionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }

  export type VoucherOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    voucherUsage?: VoucherUsageOrderByRelationAggregateInput
  }

  export type VoucherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: VoucherWhereInput | VoucherWhereInput[]
    OR?: VoucherWhereInput[]
    NOT?: VoucherWhereInput | VoucherWhereInput[]
    name?: StringFilter<"Voucher"> | string
    description?: StringNullableFilter<"Voucher"> | string | null
    type?: StringFilter<"Voucher"> | string
    discountType?: StringFilter<"Voucher"> | string
    value?: DecimalFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableFilter<"Voucher"> | number | null
    usedCount?: IntFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolFilter<"Voucher"> | boolean
    isActive?: BoolFilter<"Voucher"> | boolean
    startDate?: DateTimeFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeFilter<"Voucher"> | Date | string
    transactions?: TransactionListRelationFilter
    voucherUsage?: VoucherUsageListRelationFilter
  }, "id" | "code">

  export type VoucherOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrderInput | SortOrder
    maxDiscount?: SortOrderInput | SortOrder
    maxUses?: SortOrderInput | SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VoucherCountOrderByAggregateInput
    _avg?: VoucherAvgOrderByAggregateInput
    _max?: VoucherMaxOrderByAggregateInput
    _min?: VoucherMinOrderByAggregateInput
    _sum?: VoucherSumOrderByAggregateInput
  }

  export type VoucherScalarWhereWithAggregatesInput = {
    AND?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    OR?: VoucherScalarWhereWithAggregatesInput[]
    NOT?: VoucherScalarWhereWithAggregatesInput | VoucherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Voucher"> | string
    code?: StringWithAggregatesFilter<"Voucher"> | string
    name?: StringWithAggregatesFilter<"Voucher"> | string
    description?: StringNullableWithAggregatesFilter<"Voucher"> | string | null
    type?: StringWithAggregatesFilter<"Voucher"> | string
    discountType?: StringWithAggregatesFilter<"Voucher"> | string
    value?: DecimalWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string
    minAmount?: DecimalNullableWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: DecimalNullableWithAggregatesFilter<"Voucher"> | Decimal | DecimalJsLike | number | string | null
    maxUses?: IntNullableWithAggregatesFilter<"Voucher"> | number | null
    usedCount?: IntWithAggregatesFilter<"Voucher"> | number
    allowMultipleUsePerUser?: BoolWithAggregatesFilter<"Voucher"> | boolean
    isActive?: BoolWithAggregatesFilter<"Voucher"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Voucher"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Voucher"> | Date | string
  }

  export type VoucherUsageWhereInput = {
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }

  export type VoucherUsageOrderByWithRelationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    transaction?: TransactionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    voucher?: VoucherOrderByWithRelationInput
  }

  export type VoucherUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    OR?: VoucherUsageWhereInput[]
    NOT?: VoucherUsageWhereInput | VoucherUsageWhereInput[]
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
    transaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    voucher?: XOR<VoucherScalarRelationFilter, VoucherWhereInput>
  }, "id">

  export type VoucherUsageOrderByWithAggregationInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
    _count?: VoucherUsageCountOrderByAggregateInput
    _avg?: VoucherUsageAvgOrderByAggregateInput
    _max?: VoucherUsageMaxOrderByAggregateInput
    _min?: VoucherUsageMinOrderByAggregateInput
    _sum?: VoucherUsageSumOrderByAggregateInput
  }

  export type VoucherUsageScalarWhereWithAggregatesInput = {
    AND?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    OR?: VoucherUsageScalarWhereWithAggregatesInput[]
    NOT?: VoucherUsageScalarWhereWithAggregatesInput | VoucherUsageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VoucherUsage"> | string
    voucherId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    userId?: StringWithAggregatesFilter<"VoucherUsage"> | string
    transactionId?: StringNullableWithAggregatesFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeWithAggregatesFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalWithAggregatesFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
  }

  export type ServicesProductCustomersWhereInput = {
    AND?: ServicesProductCustomersWhereInput | ServicesProductCustomersWhereInput[]
    OR?: ServicesProductCustomersWhereInput[]
    NOT?: ServicesProductCustomersWhereInput | ServicesProductCustomersWhereInput[]
    id?: StringFilter<"ServicesProductCustomers"> | string
    transactionId?: StringFilter<"ServicesProductCustomers"> | string
    customerId?: StringFilter<"ServicesProductCustomers"> | string
    packageId?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    quantity?: IntFilter<"ServicesProductCustomers"> | number
    websiteUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    driveUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    textDescription?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainName?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainExpiredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    fileAssets?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    status?: StringFilter<"ServicesProductCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
  }

  export type ServicesProductCustomersOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    driveUrl?: SortOrderInput | SortOrder
    textDescription?: SortOrderInput | SortOrder
    domainName?: SortOrderInput | SortOrder
    domainExpiredAt?: SortOrderInput | SortOrder
    fileAssets?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
    package?: PackageOrderByWithRelationInput
  }

  export type ServicesProductCustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicesProductCustomersWhereInput | ServicesProductCustomersWhereInput[]
    OR?: ServicesProductCustomersWhereInput[]
    NOT?: ServicesProductCustomersWhereInput | ServicesProductCustomersWhereInput[]
    transactionId?: StringFilter<"ServicesProductCustomers"> | string
    customerId?: StringFilter<"ServicesProductCustomers"> | string
    packageId?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    quantity?: IntFilter<"ServicesProductCustomers"> | number
    websiteUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    driveUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    textDescription?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainName?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainExpiredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    fileAssets?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    status?: StringFilter<"ServicesProductCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
    package?: XOR<PackageNullableScalarRelationFilter, PackageWhereInput> | null
  }, "id">

  export type ServicesProductCustomersOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    driveUrl?: SortOrderInput | SortOrder
    textDescription?: SortOrderInput | SortOrder
    domainName?: SortOrderInput | SortOrder
    domainExpiredAt?: SortOrderInput | SortOrder
    fileAssets?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicesProductCustomersCountOrderByAggregateInput
    _avg?: ServicesProductCustomersAvgOrderByAggregateInput
    _max?: ServicesProductCustomersMaxOrderByAggregateInput
    _min?: ServicesProductCustomersMinOrderByAggregateInput
    _sum?: ServicesProductCustomersSumOrderByAggregateInput
  }

  export type ServicesProductCustomersScalarWhereWithAggregatesInput = {
    AND?: ServicesProductCustomersScalarWhereWithAggregatesInput | ServicesProductCustomersScalarWhereWithAggregatesInput[]
    OR?: ServicesProductCustomersScalarWhereWithAggregatesInput[]
    NOT?: ServicesProductCustomersScalarWhereWithAggregatesInput | ServicesProductCustomersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicesProductCustomers"> | string
    transactionId?: StringWithAggregatesFilter<"ServicesProductCustomers"> | string
    customerId?: StringWithAggregatesFilter<"ServicesProductCustomers"> | string
    packageId?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    quantity?: IntWithAggregatesFilter<"ServicesProductCustomers"> | number
    websiteUrl?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    driveUrl?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    textDescription?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    domainName?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    domainExpiredAt?: DateTimeNullableWithAggregatesFilter<"ServicesProductCustomers"> | Date | string | null
    fileAssets?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    status?: StringWithAggregatesFilter<"ServicesProductCustomers"> | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"ServicesProductCustomers"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ServicesProductCustomers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicesProductCustomers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicesProductCustomers"> | Date | string
  }

  export type ServicesAddonsCustomersWhereInput = {
    AND?: ServicesAddonsCustomersWhereInput | ServicesAddonsCustomersWhereInput[]
    OR?: ServicesAddonsCustomersWhereInput[]
    NOT?: ServicesAddonsCustomersWhereInput | ServicesAddonsCustomersWhereInput[]
    id?: StringFilter<"ServicesAddonsCustomers"> | string
    transactionId?: StringFilter<"ServicesAddonsCustomers"> | string
    customerId?: StringFilter<"ServicesAddonsCustomers"> | string
    addonDetails?: StringFilter<"ServicesAddonsCustomers"> | string
    driveUrl?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    fileAssets?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    status?: StringFilter<"ServicesAddonsCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesAddonsCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }

  export type ServicesAddonsCustomersOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    addonDetails?: SortOrder
    driveUrl?: SortOrderInput | SortOrder
    fileAssets?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    transaction?: TransactionOrderByWithRelationInput
  }

  export type ServicesAddonsCustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicesAddonsCustomersWhereInput | ServicesAddonsCustomersWhereInput[]
    OR?: ServicesAddonsCustomersWhereInput[]
    NOT?: ServicesAddonsCustomersWhereInput | ServicesAddonsCustomersWhereInput[]
    transactionId?: StringFilter<"ServicesAddonsCustomers"> | string
    customerId?: StringFilter<"ServicesAddonsCustomers"> | string
    addonDetails?: StringFilter<"ServicesAddonsCustomers"> | string
    driveUrl?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    fileAssets?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    status?: StringFilter<"ServicesAddonsCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesAddonsCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>
    transaction?: XOR<TransactionScalarRelationFilter, TransactionWhereInput>
  }, "id">

  export type ServicesAddonsCustomersOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    addonDetails?: SortOrder
    driveUrl?: SortOrderInput | SortOrder
    fileAssets?: SortOrderInput | SortOrder
    status?: SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicesAddonsCustomersCountOrderByAggregateInput
    _max?: ServicesAddonsCustomersMaxOrderByAggregateInput
    _min?: ServicesAddonsCustomersMinOrderByAggregateInput
  }

  export type ServicesAddonsCustomersScalarWhereWithAggregatesInput = {
    AND?: ServicesAddonsCustomersScalarWhereWithAggregatesInput | ServicesAddonsCustomersScalarWhereWithAggregatesInput[]
    OR?: ServicesAddonsCustomersScalarWhereWithAggregatesInput[]
    NOT?: ServicesAddonsCustomersScalarWhereWithAggregatesInput | ServicesAddonsCustomersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicesAddonsCustomers"> | string
    transactionId?: StringWithAggregatesFilter<"ServicesAddonsCustomers"> | string
    customerId?: StringWithAggregatesFilter<"ServicesAddonsCustomers"> | string
    addonDetails?: StringWithAggregatesFilter<"ServicesAddonsCustomers"> | string
    driveUrl?: StringNullableWithAggregatesFilter<"ServicesAddonsCustomers"> | string | null
    fileAssets?: StringNullableWithAggregatesFilter<"ServicesAddonsCustomers"> | string | null
    status?: StringWithAggregatesFilter<"ServicesAddonsCustomers"> | string
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"ServicesAddonsCustomers"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ServicesAddonsCustomers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicesAddonsCustomers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicesAddonsCustomers"> | Date | string
  }

  export type ServiceFeeWhereInput = {
    AND?: ServiceFeeWhereInput | ServiceFeeWhereInput[]
    OR?: ServiceFeeWhereInput[]
    NOT?: ServiceFeeWhereInput | ServiceFeeWhereInput[]
    id?: StringFilter<"ServiceFee"> | string
    paymentMethod?: StringFilter<"ServiceFee"> | string
    name?: StringFilter<"ServiceFee"> | string
    type?: StringFilter<"ServiceFee"> | string
    value?: DecimalFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string
    minFee?: DecimalNullableFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ServiceFee"> | boolean
    requiresManualApproval?: BoolFilter<"ServiceFee"> | boolean
    paymentInstructions?: StringNullableFilter<"ServiceFee"> | string | null
    instructionType?: StringNullableFilter<"ServiceFee"> | string | null
    instructionImageUrl?: StringNullableFilter<"ServiceFee"> | string | null
    createdAt?: DateTimeFilter<"ServiceFee"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceFee"> | Date | string
    currency?: StringFilter<"ServiceFee"> | string
  }

  export type ServiceFeeOrderByWithRelationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minFee?: SortOrderInput | SortOrder
    maxFee?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrderInput | SortOrder
    instructionType?: SortOrderInput | SortOrder
    instructionImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type ServiceFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentMethod_currency?: ServiceFeePaymentMethodCurrencyCompoundUniqueInput
    AND?: ServiceFeeWhereInput | ServiceFeeWhereInput[]
    OR?: ServiceFeeWhereInput[]
    NOT?: ServiceFeeWhereInput | ServiceFeeWhereInput[]
    paymentMethod?: StringFilter<"ServiceFee"> | string
    name?: StringFilter<"ServiceFee"> | string
    type?: StringFilter<"ServiceFee"> | string
    value?: DecimalFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string
    minFee?: DecimalNullableFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"ServiceFee"> | boolean
    requiresManualApproval?: BoolFilter<"ServiceFee"> | boolean
    paymentInstructions?: StringNullableFilter<"ServiceFee"> | string | null
    instructionType?: StringNullableFilter<"ServiceFee"> | string | null
    instructionImageUrl?: StringNullableFilter<"ServiceFee"> | string | null
    createdAt?: DateTimeFilter<"ServiceFee"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceFee"> | Date | string
    currency?: StringFilter<"ServiceFee"> | string
  }, "id" | "paymentMethod_currency">

  export type ServiceFeeOrderByWithAggregationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minFee?: SortOrderInput | SortOrder
    maxFee?: SortOrderInput | SortOrder
    isActive?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrderInput | SortOrder
    instructionType?: SortOrderInput | SortOrder
    instructionImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
    _count?: ServiceFeeCountOrderByAggregateInput
    _avg?: ServiceFeeAvgOrderByAggregateInput
    _max?: ServiceFeeMaxOrderByAggregateInput
    _min?: ServiceFeeMinOrderByAggregateInput
    _sum?: ServiceFeeSumOrderByAggregateInput
  }

  export type ServiceFeeScalarWhereWithAggregatesInput = {
    AND?: ServiceFeeScalarWhereWithAggregatesInput | ServiceFeeScalarWhereWithAggregatesInput[]
    OR?: ServiceFeeScalarWhereWithAggregatesInput[]
    NOT?: ServiceFeeScalarWhereWithAggregatesInput | ServiceFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceFee"> | string
    paymentMethod?: StringWithAggregatesFilter<"ServiceFee"> | string
    name?: StringWithAggregatesFilter<"ServiceFee"> | string
    type?: StringWithAggregatesFilter<"ServiceFee"> | string
    value?: DecimalWithAggregatesFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string
    minFee?: DecimalNullableWithAggregatesFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    maxFee?: DecimalNullableWithAggregatesFilter<"ServiceFee"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceFee"> | boolean
    requiresManualApproval?: BoolWithAggregatesFilter<"ServiceFee"> | boolean
    paymentInstructions?: StringNullableWithAggregatesFilter<"ServiceFee"> | string | null
    instructionType?: StringNullableWithAggregatesFilter<"ServiceFee"> | string | null
    instructionImageUrl?: StringNullableWithAggregatesFilter<"ServiceFee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceFee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceFee"> | Date | string
    currency?: StringWithAggregatesFilter<"ServiceFee"> | string
  }

  export type BankDetailWhereInput = {
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    id?: StringFilter<"BankDetail"> | string
    bankName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    swiftCode?: StringNullableFilter<"BankDetail"> | string | null
    currency?: StringFilter<"BankDetail"> | string
    isActive?: BoolFilter<"BankDetail"> | boolean
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
  }

  export type BankDetailOrderByWithRelationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrderInput | SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankDetailWhereInput | BankDetailWhereInput[]
    OR?: BankDetailWhereInput[]
    NOT?: BankDetailWhereInput | BankDetailWhereInput[]
    bankName?: StringFilter<"BankDetail"> | string
    accountNumber?: StringFilter<"BankDetail"> | string
    accountName?: StringFilter<"BankDetail"> | string
    swiftCode?: StringNullableFilter<"BankDetail"> | string | null
    currency?: StringFilter<"BankDetail"> | string
    isActive?: BoolFilter<"BankDetail"> | boolean
    createdAt?: DateTimeFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeFilter<"BankDetail"> | Date | string
  }, "id">

  export type BankDetailOrderByWithAggregationInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrderInput | SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankDetailCountOrderByAggregateInput
    _max?: BankDetailMaxOrderByAggregateInput
    _min?: BankDetailMinOrderByAggregateInput
  }

  export type BankDetailScalarWhereWithAggregatesInput = {
    AND?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    OR?: BankDetailScalarWhereWithAggregatesInput[]
    NOT?: BankDetailScalarWhereWithAggregatesInput | BankDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankDetail"> | string
    bankName?: StringWithAggregatesFilter<"BankDetail"> | string
    accountNumber?: StringWithAggregatesFilter<"BankDetail"> | string
    accountName?: StringWithAggregatesFilter<"BankDetail"> | string
    swiftCode?: StringNullableWithAggregatesFilter<"BankDetail"> | string | null
    currency?: StringWithAggregatesFilter<"BankDetail"> | string
    isActive?: BoolWithAggregatesFilter<"BankDetail"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankDetail"> | Date | string
  }

  export type ServerWhereInput = {
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    id?: StringFilter<"Server"> | string
    dropletId?: StringFilter<"Server"> | string
    name?: StringFilter<"Server"> | string
    memory?: IntFilter<"Server"> | number
    vcpus?: IntFilter<"Server"> | number
    disk?: IntFilter<"Server"> | number
    status?: StringFilter<"Server"> | string
    region?: StringFilter<"Server"> | string
    regionSlug?: StringFilter<"Server"> | string
    sizeSlug?: StringFilter<"Server"> | string
    publicIp?: StringNullableFilter<"Server"> | string | null
    privateIp?: StringNullableFilter<"Server"> | string | null
    priceMonthly?: DecimalFilter<"Server"> | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFilter<"Server"> | Decimal | DecimalJsLike | number | string
    tags?: JsonNullableFilter<"Server">
    features?: JsonNullableFilter<"Server">
    imageDistribution?: StringNullableFilter<"Server"> | string | null
    imageName?: StringNullableFilter<"Server"> | string | null
    createdAt?: DateTimeFilter<"Server"> | Date | string
    updatedAt?: DateTimeFilter<"Server"> | Date | string
  }

  export type ServerOrderByWithRelationInput = {
    id?: SortOrder
    dropletId?: SortOrder
    name?: SortOrder
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    status?: SortOrder
    region?: SortOrder
    regionSlug?: SortOrder
    sizeSlug?: SortOrder
    publicIp?: SortOrderInput | SortOrder
    privateIp?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
    tags?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    imageDistribution?: SortOrderInput | SortOrder
    imageName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dropletId?: string
    AND?: ServerWhereInput | ServerWhereInput[]
    OR?: ServerWhereInput[]
    NOT?: ServerWhereInput | ServerWhereInput[]
    name?: StringFilter<"Server"> | string
    memory?: IntFilter<"Server"> | number
    vcpus?: IntFilter<"Server"> | number
    disk?: IntFilter<"Server"> | number
    status?: StringFilter<"Server"> | string
    region?: StringFilter<"Server"> | string
    regionSlug?: StringFilter<"Server"> | string
    sizeSlug?: StringFilter<"Server"> | string
    publicIp?: StringNullableFilter<"Server"> | string | null
    privateIp?: StringNullableFilter<"Server"> | string | null
    priceMonthly?: DecimalFilter<"Server"> | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFilter<"Server"> | Decimal | DecimalJsLike | number | string
    tags?: JsonNullableFilter<"Server">
    features?: JsonNullableFilter<"Server">
    imageDistribution?: StringNullableFilter<"Server"> | string | null
    imageName?: StringNullableFilter<"Server"> | string | null
    createdAt?: DateTimeFilter<"Server"> | Date | string
    updatedAt?: DateTimeFilter<"Server"> | Date | string
  }, "id" | "dropletId">

  export type ServerOrderByWithAggregationInput = {
    id?: SortOrder
    dropletId?: SortOrder
    name?: SortOrder
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    status?: SortOrder
    region?: SortOrder
    regionSlug?: SortOrder
    sizeSlug?: SortOrder
    publicIp?: SortOrderInput | SortOrder
    privateIp?: SortOrderInput | SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
    tags?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    imageDistribution?: SortOrderInput | SortOrder
    imageName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServerCountOrderByAggregateInput
    _avg?: ServerAvgOrderByAggregateInput
    _max?: ServerMaxOrderByAggregateInput
    _min?: ServerMinOrderByAggregateInput
    _sum?: ServerSumOrderByAggregateInput
  }

  export type ServerScalarWhereWithAggregatesInput = {
    AND?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    OR?: ServerScalarWhereWithAggregatesInput[]
    NOT?: ServerScalarWhereWithAggregatesInput | ServerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Server"> | string
    dropletId?: StringWithAggregatesFilter<"Server"> | string
    name?: StringWithAggregatesFilter<"Server"> | string
    memory?: IntWithAggregatesFilter<"Server"> | number
    vcpus?: IntWithAggregatesFilter<"Server"> | number
    disk?: IntWithAggregatesFilter<"Server"> | number
    status?: StringWithAggregatesFilter<"Server"> | string
    region?: StringWithAggregatesFilter<"Server"> | string
    regionSlug?: StringWithAggregatesFilter<"Server"> | string
    sizeSlug?: StringWithAggregatesFilter<"Server"> | string
    publicIp?: StringNullableWithAggregatesFilter<"Server"> | string | null
    privateIp?: StringNullableWithAggregatesFilter<"Server"> | string | null
    priceMonthly?: DecimalWithAggregatesFilter<"Server"> | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalWithAggregatesFilter<"Server"> | Decimal | DecimalJsLike | number | string
    tags?: JsonNullableWithAggregatesFilter<"Server">
    features?: JsonNullableWithAggregatesFilter<"Server">
    imageDistribution?: StringNullableWithAggregatesFilter<"Server"> | string | null
    imageName?: StringNullableWithAggregatesFilter<"Server"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Server"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Server"> | Date | string
  }

  export type WhatsAppMessageStatsWhereInput = {
    AND?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    OR?: WhatsAppMessageStatsWhereInput[]
    NOT?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    id?: StringFilter<"WhatsAppMessageStats"> | string
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }

  export type WhatsAppMessageStatsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrderInput | SortOrder
    lastMessageFailedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    session?: WhatsAppSessionOrderByWithRelationInput
  }

  export type WhatsAppMessageStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_sessionId?: WhatsAppMessageStatsUserIdSessionIdCompoundUniqueInput
    AND?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    OR?: WhatsAppMessageStatsWhereInput[]
    NOT?: WhatsAppMessageStatsWhereInput | WhatsAppMessageStatsWhereInput[]
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    session?: XOR<WhatsAppSessionScalarRelationFilter, WhatsAppSessionWhereInput>
  }, "id" | "userId_sessionId">

  export type WhatsAppMessageStatsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrderInput | SortOrder
    lastMessageFailedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhatsAppMessageStatsCountOrderByAggregateInput
    _avg?: WhatsAppMessageStatsAvgOrderByAggregateInput
    _max?: WhatsAppMessageStatsMaxOrderByAggregateInput
    _min?: WhatsAppMessageStatsMinOrderByAggregateInput
    _sum?: WhatsAppMessageStatsSumOrderByAggregateInput
  }

  export type WhatsAppMessageStatsScalarWhereWithAggregatesInput = {
    AND?: WhatsAppMessageStatsScalarWhereWithAggregatesInput | WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    OR?: WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppMessageStatsScalarWhereWithAggregatesInput | WhatsAppMessageStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    userId?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringWithAggregatesFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntWithAggregatesFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppMessageStats"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
    package: PackageCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
    packageId: string
  }

  export type FeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
    package?: PackageUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type FeatureCreateManyInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
    packageId: string
  }

  export type FeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
    packageId?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryCreateInput = {
    id?: string
    name_en: string
    name_id: string
    packages?: PackageCreateNestedManyWithoutSubcategoryInput
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateInput = {
    id?: string
    name_en: string
    name_id: string
    categoryId: string
    packages?: PackageUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    packages?: PackageUpdateManyWithoutSubcategoryNestedInput
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    packages?: PackageUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryCreateManyInput = {
    id?: string
    name_en: string
    name_id: string
    categoryId: string
  }

  export type SubcategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
  }

  export type SubcategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonCreateNestedManyWithoutCategoryInput
    packages?: PackageCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonUncheckedCreateNestedManyWithoutCategoryInput
    packages?: PackageUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUpdateManyWithoutCategoryNestedInput
    packages?: PackageUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUncheckedUpdateManyWithoutCategoryNestedInput
    packages?: PackageUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
  }

  export type AddonCreateInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    category: CategoryCreateNestedOneWithoutAddonsInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutAddonInput
  }

  export type AddonUncheckedCreateInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    categoryId: string
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutAddonInput
  }

  export type AddonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneRequiredWithoutAddonsNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutAddonNestedInput
  }

  export type AddonCreateManyInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    categoryId: string
  }

  export type AddonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type PackageCreateInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    features?: FeatureCreateNestedManyWithoutPackageInput
    category: CategoryCreateNestedOneWithoutPackagesInput
    subcategory: SubcategoryCreateNestedOneWithoutPackagesInput
    productTransactions?: TransactionProductCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    subcategoryId: string
    popular?: boolean | null
    features?: FeatureUncheckedCreateNestedManyWithoutPackageInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUpdateManyWithoutPackageNestedInput
    category?: CategoryUpdateOneRequiredWithoutPackagesNestedInput
    subcategory?: SubcategoryUpdateOneRequiredWithoutPackagesNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUncheckedUpdateManyWithoutPackageNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageCreateManyInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    subcategoryId: string
    popular?: boolean | null
  }

  export type PackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type WhatsAppSessionCreateInput = {
    id?: string
    sessionId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
    user: UserCreateNestedOneWithoutWhatsAppSessionsInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWhatsAppSessionsNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
  }

  export type WhatsAppSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WhatsAppSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionProductCreateInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
    package?: PackageCreateNestedOneWithoutProductTransactionsInput
    transaction: TransactionCreateNestedOneWithoutProductTransactionsInput
  }

  export type TransactionProductUncheckedCreateInput = {
    id?: string
    transactionId: string
    packageId?: string | null
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type TransactionProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
    package?: PackageUpdateOneWithoutProductTransactionsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutProductTransactionsNestedInput
  }

  export type TransactionProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionProductCreateManyInput = {
    id?: string
    transactionId: string
    packageId?: string | null
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type TransactionProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionAddonsCreateInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    addon: AddonCreateNestedOneWithoutAddonTransactionsInput
    transaction: TransactionCreateNestedOneWithoutAddonTransactionsInput
  }

  export type TransactionAddonsUncheckedCreateInput = {
    id?: string
    transactionId: string
    addonId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionAddonsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addon?: AddonUpdateOneRequiredWithoutAddonTransactionsNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutAddonTransactionsNestedInput
  }

  export type TransactionAddonsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionAddonsCreateManyInput = {
    id?: string
    transactionId: string
    addonId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionAddonsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionAddonsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceCreateInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    transaction: TransactionCreateNestedOneWithoutWhatsappTransactionInput
    whatsappPackage: WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput
  }

  export type TransactionWhatsappServiceUncheckedCreateInput = {
    id?: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput
    whatsappPackage?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceCreateManyInput = {
    id?: string
    transactionId: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
    transaction?: TransactionCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    transactionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentCreateManyInput = {
    id?: string
    transactionId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhatsappApiPackageCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type WhatsappApiPackageCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsappApiPackageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsappApiPackageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersCreateInput = {
    id?: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutWhatsappCustomersInput
    transaction: TransactionCreateNestedOneWithoutWhatsappCustomersInput
    package: WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateInput = {
    id?: string
    transactionId: string
    customerId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    package?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersCreateManyInput = {
    id?: string
    transactionId: string
    customerId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    user: UserCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionCreateManyInput = {
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutVoucherInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutVoucherInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutVoucherNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutVoucherNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageCreateInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    user: UserCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateInput = {
    id?: string
    voucherId: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateManyInput = {
    id?: string
    voucherId: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type ServicesProductCustomersCreateInput = {
    id?: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProductCustomersInput
    transaction: TransactionCreateNestedOneWithoutProductCustomersInput
    package?: PackageCreateNestedOneWithoutProductCustomersInput
  }

  export type ServicesProductCustomersUncheckedCreateInput = {
    id?: string
    transactionId: string
    customerId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesProductCustomersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProductCustomersNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutProductCustomersNestedInput
    package?: PackageUpdateOneWithoutProductCustomersNestedInput
  }

  export type ServicesProductCustomersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesProductCustomersCreateManyInput = {
    id?: string
    transactionId: string
    customerId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesProductCustomersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesProductCustomersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersCreateInput = {
    id?: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutAddonCustomersInput
    transaction: TransactionCreateNestedOneWithoutAddonCustomersInput
  }

  export type ServicesAddonsCustomersUncheckedCreateInput = {
    id?: string
    transactionId: string
    customerId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutAddonCustomersNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutAddonCustomersNestedInput
  }

  export type ServicesAddonsCustomersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersCreateManyInput = {
    id?: string
    transactionId: string
    customerId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceFeeCreateInput = {
    id?: string
    paymentMethod: string
    name: string
    type: string
    value: Decimal | DecimalJsLike | number | string
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency: string
  }

  export type ServiceFeeUncheckedCreateInput = {
    id?: string
    paymentMethod: string
    name: string
    type: string
    value: Decimal | DecimalJsLike | number | string
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency: string
  }

  export type ServiceFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceFeeCreateManyInput = {
    id?: string
    paymentMethod: string
    name: string
    type: string
    value: Decimal | DecimalJsLike | number | string
    minFee?: Decimal | DecimalJsLike | number | string | null
    maxFee?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    requiresManualApproval?: boolean
    paymentInstructions?: string | null
    instructionType?: string | null
    instructionImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currency: string
  }

  export type ServiceFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    requiresManualApproval?: BoolFieldUpdateOperationsInput | boolean
    paymentInstructions?: NullableStringFieldUpdateOperationsInput | string | null
    instructionType?: NullableStringFieldUpdateOperationsInput | string | null
    instructionImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: StringFieldUpdateOperationsInput | string
  }

  export type BankDetailCreateInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    currency: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUncheckedCreateInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    currency: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailCreateManyInput = {
    id?: string
    bankName: string
    accountNumber: string
    accountName: string
    swiftCode?: string | null
    currency: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bankName?: StringFieldUpdateOperationsInput | string
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    swiftCode?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerCreateInput = {
    id?: string
    dropletId: string
    name: string
    memory: number
    vcpus: number
    disk: number
    status: string
    region: string
    regionSlug: string
    sizeSlug: string
    publicIp?: string | null
    privateIp?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceHourly: Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: string | null
    imageName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServerUncheckedCreateInput = {
    id?: string
    dropletId: string
    name: string
    memory: number
    vcpus: number
    disk: number
    status: string
    region: string
    regionSlug: string
    sizeSlug: string
    publicIp?: string | null
    privateIp?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceHourly: Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: string | null
    imageName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dropletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    vcpus?: IntFieldUpdateOperationsInput | number
    disk?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    regionSlug?: StringFieldUpdateOperationsInput | string
    sizeSlug?: StringFieldUpdateOperationsInput | string
    publicIp?: NullableStringFieldUpdateOperationsInput | string | null
    privateIp?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dropletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    vcpus?: IntFieldUpdateOperationsInput | number
    disk?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    regionSlug?: StringFieldUpdateOperationsInput | string
    sizeSlug?: StringFieldUpdateOperationsInput | string
    publicIp?: NullableStringFieldUpdateOperationsInput | string | null
    privateIp?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerCreateManyInput = {
    id?: string
    dropletId: string
    name: string
    memory: number
    vcpus: number
    disk: number
    status: string
    region: string
    regionSlug: string
    sizeSlug: string
    publicIp?: string | null
    privateIp?: string | null
    priceMonthly: Decimal | DecimalJsLike | number | string
    priceHourly: Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: string | null
    imageName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dropletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    vcpus?: IntFieldUpdateOperationsInput | number
    disk?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    regionSlug?: StringFieldUpdateOperationsInput | string
    sizeSlug?: StringFieldUpdateOperationsInput | string
    publicIp?: NullableStringFieldUpdateOperationsInput | string | null
    privateIp?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dropletId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    memory?: IntFieldUpdateOperationsInput | number
    vcpus?: IntFieldUpdateOperationsInput | number
    disk?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    regionSlug?: StringFieldUpdateOperationsInput | string
    sizeSlug?: StringFieldUpdateOperationsInput | string
    publicIp?: NullableStringFieldUpdateOperationsInput | string | null
    privateIp?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonthly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    priceHourly?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    imageDistribution?: NullableStringFieldUpdateOperationsInput | string | null
    imageName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsCreateInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsappMessageStatsInput
    session: WhatsAppSessionCreateNestedOneWithoutWhatsappMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput
    session?: WhatsAppSessionUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsCreateManyInput = {
    id?: string
    userId: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type VoucherUsageListRelationFilter = {
    every?: VoucherUsageWhereInput
    some?: VoucherUsageWhereInput
    none?: VoucherUsageWhereInput
  }

  export type WhatsAppSessionListRelationFilter = {
    every?: WhatsAppSessionWhereInput
    some?: WhatsAppSessionWhereInput
    none?: WhatsAppSessionWhereInput
  }

  export type ServicesProductCustomersListRelationFilter = {
    every?: ServicesProductCustomersWhereInput
    some?: ServicesProductCustomersWhereInput
    none?: ServicesProductCustomersWhereInput
  }

  export type ServicesAddonsCustomersListRelationFilter = {
    every?: ServicesAddonsCustomersWhereInput
    some?: ServicesAddonsCustomersWhereInput
    none?: ServicesAddonsCustomersWhereInput
  }

  export type ServicesWhatsappCustomersListRelationFilter = {
    every?: ServicesWhatsappCustomersWhereInput
    some?: ServicesWhatsappCustomersWhereInput
    none?: ServicesWhatsappCustomersWhereInput
  }

  export type WhatsAppMessageStatsListRelationFilter = {
    every?: WhatsAppMessageStatsWhereInput
    some?: WhatsAppMessageStatsWhereInput
    none?: WhatsAppMessageStatsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoucherUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicesProductCustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicesAddonsCustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicesWhatsappCustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppMessageStatsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    otp?: SortOrder
    otpExpires?: SortOrder
    otpVerificationDeadline?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    image?: SortOrder
    emailVerificationToken?: SortOrder
    emailVerificationTokenExpires?: SortOrder
    role?: SortOrder
    apiKey?: SortOrder
    updatedAt?: SortOrder
    emailOtp?: SortOrder
    emailOtpExpires?: SortOrder
    resetPasswordOtp?: SortOrder
    resetPasswordOtpExpires?: SortOrder
    resetPasswordLastRequestAt?: SortOrder
    ssoOtp?: SortOrder
    ssoOtpExpires?: SortOrder
    ssoLastRequestAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type PackageScalarRelationFilter = {
    is?: PackageWhereInput
    isNot?: PackageWhereInput
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    included?: SortOrder
    packageId?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    included?: SortOrder
    packageId?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    included?: SortOrder
    packageId?: SortOrder
  }

  export type PackageListRelationFilter = {
    every?: PackageWhereInput
    some?: PackageWhereInput
    none?: PackageWhereInput
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type PackageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcategoryCategoryIdName_enCompoundUniqueInput = {
    categoryId: string
    name_en: string
  }

  export type SubcategoryCategoryIdName_idCompoundUniqueInput = {
    categoryId: string
    name_id: string
  }

  export type SubcategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    categoryId?: SortOrder
  }

  export type SubcategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    categoryId?: SortOrder
  }

  export type AddonListRelationFilter = {
    every?: AddonWhereInput
    some?: AddonWhereInput
    none?: AddonWhereInput
  }

  export type SubcategoryListRelationFilter = {
    every?: SubcategoryWhereInput
    some?: SubcategoryWhereInput
    none?: SubcategoryWhereInput
  }

  export type AddonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubcategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    icon?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    icon?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    icon?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type TransactionAddonsListRelationFilter = {
    every?: TransactionAddonsWhereInput
    some?: TransactionAddonsWhereInput
    none?: TransactionAddonsWhereInput
  }

  export type TransactionAddonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddonCategoryIdName_enCompoundUniqueInput = {
    categoryId: string
    name_en: string
  }

  export type AddonCategoryIdName_idCompoundUniqueInput = {
    categoryId: string
    name_id: string
  }

  export type AddonCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
  }

  export type AddonAvgOrderByAggregateInput = {
    price_idr?: SortOrder
    price_usd?: SortOrder
  }

  export type AddonMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
  }

  export type AddonMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
  }

  export type AddonSumOrderByAggregateInput = {
    price_idr?: SortOrder
    price_usd?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FeatureListRelationFilter = {
    every?: FeatureWhereInput
    some?: FeatureWhereInput
    none?: FeatureWhereInput
  }

  export type SubcategoryScalarRelationFilter = {
    is?: SubcategoryWhereInput
    isNot?: SubcategoryWhereInput
  }

  export type TransactionProductListRelationFilter = {
    every?: TransactionProductWhereInput
    some?: TransactionProductWhereInput
    none?: TransactionProductWhereInput
  }

  export type FeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackageCountOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    popular?: SortOrder
  }

  export type PackageAvgOrderByAggregateInput = {
    price_idr?: SortOrder
    price_usd?: SortOrder
  }

  export type PackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    popular?: SortOrder
  }

  export type PackageMinOrderByAggregateInput = {
    id?: SortOrder
    name_en?: SortOrder
    name_id?: SortOrder
    description_en?: SortOrder
    description_id?: SortOrder
    price_idr?: SortOrder
    price_usd?: SortOrder
    image?: SortOrder
    categoryId?: SortOrder
    subcategoryId?: SortOrder
    popular?: SortOrder
  }

  export type PackageSumOrderByAggregateInput = {
    price_idr?: SortOrder
    price_usd?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type WhatsAppSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    qr?: SortOrder
    isNotification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiConfig?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    isTerminated?: SortOrder
  }

  export type WhatsAppSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    qr?: SortOrder
    isNotification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiConfig?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    isTerminated?: SortOrder
  }

  export type WhatsAppSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    qr?: SortOrder
    isNotification?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    aiConfig?: SortOrder
    message?: SortOrder
    sessionName?: SortOrder
    isTerminated?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type VoucherNullableScalarRelationFilter = {
    is?: VoucherWhereInput | null
    isNot?: VoucherWhereInput | null
  }

  export type TransactionWhatsappServiceNullableScalarRelationFilter = {
    is?: TransactionWhatsappServiceWhereInput | null
    isNot?: TransactionWhatsappServiceWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    transactionDate?: SortOrder
    status?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    updatedAt?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    voucherId?: SortOrder
    notes?: SortOrder
    currency?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
    expiresAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    discountAmount?: SortOrder
    originalAmount?: SortOrder
    finalAmount?: SortOrder
    serviceFeeAmount?: SortOrder
    totalAfterDiscount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PackageNullableScalarRelationFilter = {
    is?: PackageWhereInput | null
    isNot?: PackageWhereInput | null
  }

  export type TransactionScalarRelationFilter = {
    is?: TransactionWhereInput
    isNot?: TransactionWhereInput
  }

  export type TransactionProductCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceLink?: SortOrder
  }

  export type TransactionProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TransactionProductMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceLink?: SortOrder
  }

  export type TransactionProductMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    referenceLink?: SortOrder
  }

  export type TransactionProductSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AddonScalarRelationFilter = {
    is?: AddonWhereInput
    isNot?: AddonWhereInput
  }

  export type TransactionAddonsCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    addonId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionAddonsAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TransactionAddonsMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    addonId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionAddonsMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    addonId?: SortOrder
    quantity?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionAddonsSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WhatsappApiPackageScalarRelationFilter = {
    is?: WhatsappApiPackageWhereInput
    isNot?: WhatsappApiPackageWhereInput
  }

  export type TransactionWhatsappServiceCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionWhatsappServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionWhatsappServiceMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    whatsappPackageId?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    serviceFee?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expiresAt?: SortOrder
    externalId?: SortOrder
    paymentUrl?: SortOrder
    serviceFee?: SortOrder
    adminNotes?: SortOrder
    adminAction?: SortOrder
    adminUserId?: SortOrder
    actionDate?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    serviceFee?: SortOrder
  }

  export type TransactionWhatsappServiceListRelationFilter = {
    every?: TransactionWhatsappServiceWhereInput
    some?: TransactionWhatsappServiceWhereInput
    none?: TransactionWhatsappServiceWhereInput
  }

  export type TransactionWhatsappServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsappApiPackageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageAvgOrderByAggregateInput = {
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
  }

  export type WhatsappApiPackageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsappApiPackageSumOrderByAggregateInput = {
    priceMonth?: SortOrder
    priceYear?: SortOrder
    maxSession?: SortOrder
  }

  export type ServicesWhatsappCustomersCustomerIdPackageIdCompoundUniqueInput = {
    customerId: string
    packageId: string
  }

  export type ServicesWhatsappCustomersCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    sessionId?: SortOrder
    qrCode?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesWhatsappCustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    sessionId?: SortOrder
    qrCode?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesWhatsappCustomersMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    sessionId?: SortOrder
    qrCode?: SortOrder
    status?: SortOrder
    expiredAt?: SortOrder
    activatedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    lastUsed?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VoucherCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherAvgOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type VoucherMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    discountType?: SortOrder
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
    allowMultipleUsePerUser?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VoucherSumOrderByAggregateInput = {
    value?: SortOrder
    minAmount?: SortOrder
    maxDiscount?: SortOrder
    maxUses?: SortOrder
    usedCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type VoucherScalarRelationFilter = {
    is?: VoucherWhereInput
    isNot?: VoucherWhereInput
  }

  export type VoucherUsageCountOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageAvgOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type VoucherUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageMinOrderByAggregateInput = {
    id?: SortOrder
    voucherId?: SortOrder
    userId?: SortOrder
    transactionId?: SortOrder
    usedAt?: SortOrder
    discountAmount?: SortOrder
  }

  export type VoucherUsageSumOrderByAggregateInput = {
    discountAmount?: SortOrder
  }

  export type ServicesProductCustomersCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    websiteUrl?: SortOrder
    driveUrl?: SortOrder
    textDescription?: SortOrder
    domainName?: SortOrder
    domainExpiredAt?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesProductCustomersAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ServicesProductCustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    websiteUrl?: SortOrder
    driveUrl?: SortOrder
    textDescription?: SortOrder
    domainName?: SortOrder
    domainExpiredAt?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesProductCustomersMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    packageId?: SortOrder
    quantity?: SortOrder
    websiteUrl?: SortOrder
    driveUrl?: SortOrder
    textDescription?: SortOrder
    domainName?: SortOrder
    domainExpiredAt?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesProductCustomersSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ServicesAddonsCustomersCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    addonDetails?: SortOrder
    driveUrl?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesAddonsCustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    addonDetails?: SortOrder
    driveUrl?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicesAddonsCustomersMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    customerId?: SortOrder
    addonDetails?: SortOrder
    driveUrl?: SortOrder
    fileAssets?: SortOrder
    status?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceFeePaymentMethodCurrencyCompoundUniqueInput = {
    paymentMethod: string
    currency: string
  }

  export type ServiceFeeCountOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    isActive?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type ServiceFeeAvgOrderByAggregateInput = {
    value?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
  }

  export type ServiceFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    isActive?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type ServiceFeeMinOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    name?: SortOrder
    type?: SortOrder
    value?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
    isActive?: SortOrder
    requiresManualApproval?: SortOrder
    paymentInstructions?: SortOrder
    instructionType?: SortOrder
    instructionImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currency?: SortOrder
  }

  export type ServiceFeeSumOrderByAggregateInput = {
    value?: SortOrder
    minFee?: SortOrder
    maxFee?: SortOrder
  }

  export type BankDetailCountOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankDetailMinOrderByAggregateInput = {
    id?: SortOrder
    bankName?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    swiftCode?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ServerCountOrderByAggregateInput = {
    id?: SortOrder
    dropletId?: SortOrder
    name?: SortOrder
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    status?: SortOrder
    region?: SortOrder
    regionSlug?: SortOrder
    sizeSlug?: SortOrder
    publicIp?: SortOrder
    privateIp?: SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
    tags?: SortOrder
    features?: SortOrder
    imageDistribution?: SortOrder
    imageName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServerAvgOrderByAggregateInput = {
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
  }

  export type ServerMaxOrderByAggregateInput = {
    id?: SortOrder
    dropletId?: SortOrder
    name?: SortOrder
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    status?: SortOrder
    region?: SortOrder
    regionSlug?: SortOrder
    sizeSlug?: SortOrder
    publicIp?: SortOrder
    privateIp?: SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
    imageDistribution?: SortOrder
    imageName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServerMinOrderByAggregateInput = {
    id?: SortOrder
    dropletId?: SortOrder
    name?: SortOrder
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    status?: SortOrder
    region?: SortOrder
    regionSlug?: SortOrder
    sizeSlug?: SortOrder
    publicIp?: SortOrder
    privateIp?: SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
    imageDistribution?: SortOrder
    imageName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServerSumOrderByAggregateInput = {
    memory?: SortOrder
    vcpus?: SortOrder
    disk?: SortOrder
    priceMonthly?: SortOrder
    priceHourly?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type WhatsAppSessionScalarRelationFilter = {
    is?: WhatsAppSessionWhereInput
    isNot?: WhatsAppSessionWhereInput
  }

  export type WhatsAppMessageStatsUserIdSessionIdCompoundUniqueInput = {
    userId: string
    sessionId: string
  }

  export type WhatsAppMessageStatsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsAvgOrderByAggregateInput = {
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
  }

  export type WhatsAppMessageStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
    lastMessageSentAt?: SortOrder
    lastMessageFailedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhatsAppMessageStatsSumOrderByAggregateInput = {
    totalMessagesSent?: SortOrder
    totalMessagesFailed?: SortOrder
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type WhatsAppSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type ServicesProductCustomersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput> | ServicesProductCustomersCreateWithoutCustomerInput[] | ServicesProductCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutCustomerInput | ServicesProductCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesProductCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput> | ServicesAddonsCustomersCreateWithoutCustomerInput[] | ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput | ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesAddonsCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
  }

  export type ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput> | ServicesProductCustomersCreateWithoutCustomerInput[] | ServicesProductCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutCustomerInput | ServicesProductCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesProductCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput> | ServicesAddonsCustomersCreateWithoutCustomerInput[] | ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput | ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesAddonsCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type WhatsAppSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput | WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput | WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutUserInput | WhatsAppSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type ServicesProductCustomersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput> | ServicesProductCustomersCreateWithoutCustomerInput[] | ServicesProductCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutCustomerInput | ServicesProductCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesProductCustomersCreateManyCustomerInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesProductCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput> | ServicesAddonsCustomersCreateWithoutCustomerInput[] | ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput | ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesAddonsCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesAddonsCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesAddonsCustomersCreateManyCustomerInputEnvelope
    set?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    disconnect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    delete?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    update?: ServicesAddonsCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesAddonsCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesAddonsCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesAddonsCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput> | VoucherUsageCreateWithoutUserInput[] | VoucherUsageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutUserInput | VoucherUsageCreateOrConnectWithoutUserInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutUserInput | VoucherUsageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoucherUsageCreateManyUserInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutUserInput | VoucherUsageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutUserInput | VoucherUsageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput> | WhatsAppSessionCreateWithoutUserInput[] | WhatsAppSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutUserInput | WhatsAppSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput | WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppSessionCreateManyUserInputEnvelope
    set?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    disconnect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    delete?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    connect?: WhatsAppSessionWhereUniqueInput | WhatsAppSessionWhereUniqueInput[]
    update?: WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput | WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppSessionUpdateManyWithWhereWithoutUserInput | WhatsAppSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput> | ServicesProductCustomersCreateWithoutCustomerInput[] | ServicesProductCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutCustomerInput | ServicesProductCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesProductCustomersCreateManyCustomerInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesProductCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput> | ServicesAddonsCustomersCreateWithoutCustomerInput[] | ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput | ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesAddonsCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesAddonsCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesAddonsCustomersCreateManyCustomerInputEnvelope
    set?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    disconnect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    delete?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    update?: ServicesAddonsCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesAddonsCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesAddonsCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesAddonsCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput> | ServicesWhatsappCustomersCreateWithoutCustomerInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput | ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServicesWhatsappCustomersCreateManyCustomerInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput> | WhatsAppMessageStatsCreateWithoutUserInput[] | WhatsAppMessageStatsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutUserInput | WhatsAppMessageStatsCreateOrConnectWithoutUserInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhatsAppMessageStatsCreateManyUserInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type PackageCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<PackageCreateWithoutFeaturesInput, PackageUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutFeaturesInput
    connect?: PackageWhereUniqueInput
  }

  export type PackageUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<PackageCreateWithoutFeaturesInput, PackageUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: PackageCreateOrConnectWithoutFeaturesInput
    upsert?: PackageUpsertWithoutFeaturesInput
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutFeaturesInput, PackageUpdateWithoutFeaturesInput>, PackageUncheckedUpdateWithoutFeaturesInput>
  }

  export type PackageCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput> | PackageCreateWithoutSubcategoryInput[] | PackageUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutSubcategoryInput | PackageCreateOrConnectWithoutSubcategoryInput[]
    createMany?: PackageCreateManySubcategoryInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutSubcategoriesInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
  }

  export type PackageUncheckedCreateNestedManyWithoutSubcategoryInput = {
    create?: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput> | PackageCreateWithoutSubcategoryInput[] | PackageUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutSubcategoryInput | PackageCreateOrConnectWithoutSubcategoryInput[]
    createMany?: PackageCreateManySubcategoryInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type PackageUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput> | PackageCreateWithoutSubcategoryInput[] | PackageUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutSubcategoryInput | PackageCreateOrConnectWithoutSubcategoryInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutSubcategoryInput | PackageUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: PackageCreateManySubcategoryInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutSubcategoryInput | PackageUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutSubcategoryInput | PackageUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput = {
    create?: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutSubcategoriesInput
    upsert?: CategoryUpsertWithoutSubcategoriesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutSubcategoriesInput, CategoryUpdateWithoutSubcategoriesInput>, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type PackageUncheckedUpdateManyWithoutSubcategoryNestedInput = {
    create?: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput> | PackageCreateWithoutSubcategoryInput[] | PackageUncheckedCreateWithoutSubcategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutSubcategoryInput | PackageCreateOrConnectWithoutSubcategoryInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutSubcategoryInput | PackageUpsertWithWhereUniqueWithoutSubcategoryInput[]
    createMany?: PackageCreateManySubcategoryInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutSubcategoryInput | PackageUpdateWithWhereUniqueWithoutSubcategoryInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutSubcategoryInput | PackageUpdateManyWithWhereWithoutSubcategoryInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type AddonCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type PackageCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput> | PackageCreateWithoutCategoryInput[] | PackageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCategoryInput | PackageCreateOrConnectWithoutCategoryInput[]
    createMany?: PackageCreateManyCategoryInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type SubcategoryCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type AddonUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
  }

  export type PackageUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput> | PackageCreateWithoutCategoryInput[] | PackageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCategoryInput | PackageCreateOrConnectWithoutCategoryInput[]
    createMany?: PackageCreateManyCategoryInputEnvelope
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
  }

  export type SubcategoryUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
  }

  export type AddonUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutCategoryInput | AddonUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutCategoryInput | AddonUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutCategoryInput | AddonUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type PackageUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput> | PackageCreateWithoutCategoryInput[] | PackageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCategoryInput | PackageCreateOrConnectWithoutCategoryInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutCategoryInput | PackageUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PackageCreateManyCategoryInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutCategoryInput | PackageUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutCategoryInput | PackageUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type SubcategoryUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type AddonUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput> | AddonCreateWithoutCategoryInput[] | AddonUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: AddonCreateOrConnectWithoutCategoryInput | AddonCreateOrConnectWithoutCategoryInput[]
    upsert?: AddonUpsertWithWhereUniqueWithoutCategoryInput | AddonUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: AddonCreateManyCategoryInputEnvelope
    set?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    disconnect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    delete?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    connect?: AddonWhereUniqueInput | AddonWhereUniqueInput[]
    update?: AddonUpdateWithWhereUniqueWithoutCategoryInput | AddonUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: AddonUpdateManyWithWhereWithoutCategoryInput | AddonUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: AddonScalarWhereInput | AddonScalarWhereInput[]
  }

  export type PackageUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput> | PackageCreateWithoutCategoryInput[] | PackageUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PackageCreateOrConnectWithoutCategoryInput | PackageCreateOrConnectWithoutCategoryInput[]
    upsert?: PackageUpsertWithWhereUniqueWithoutCategoryInput | PackageUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PackageCreateManyCategoryInputEnvelope
    set?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    disconnect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    delete?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    connect?: PackageWhereUniqueInput | PackageWhereUniqueInput[]
    update?: PackageUpdateWithWhereUniqueWithoutCategoryInput | PackageUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PackageUpdateManyWithWhereWithoutCategoryInput | PackageUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PackageScalarWhereInput | PackageScalarWhereInput[]
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput> | SubcategoryCreateWithoutCategoryInput[] | SubcategoryUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: SubcategoryCreateOrConnectWithoutCategoryInput | SubcategoryCreateOrConnectWithoutCategoryInput[]
    upsert?: SubcategoryUpsertWithWhereUniqueWithoutCategoryInput | SubcategoryUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: SubcategoryCreateManyCategoryInputEnvelope
    set?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    disconnect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    delete?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    connect?: SubcategoryWhereUniqueInput | SubcategoryWhereUniqueInput[]
    update?: SubcategoryUpdateWithWhereUniqueWithoutCategoryInput | SubcategoryUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: SubcategoryUpdateManyWithWhereWithoutCategoryInput | SubcategoryUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutAddonsInput = {
    create?: XOR<CategoryCreateWithoutAddonsInput, CategoryUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAddonsInput
    connect?: CategoryWhereUniqueInput
  }

  export type TransactionAddonsCreateNestedManyWithoutAddonInput = {
    create?: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput> | TransactionAddonsCreateWithoutAddonInput[] | TransactionAddonsUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutAddonInput | TransactionAddonsCreateOrConnectWithoutAddonInput[]
    createMany?: TransactionAddonsCreateManyAddonInputEnvelope
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
  }

  export type TransactionAddonsUncheckedCreateNestedManyWithoutAddonInput = {
    create?: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput> | TransactionAddonsCreateWithoutAddonInput[] | TransactionAddonsUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutAddonInput | TransactionAddonsCreateOrConnectWithoutAddonInput[]
    createMany?: TransactionAddonsCreateManyAddonInputEnvelope
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type CategoryUpdateOneRequiredWithoutAddonsNestedInput = {
    create?: XOR<CategoryCreateWithoutAddonsInput, CategoryUncheckedCreateWithoutAddonsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutAddonsInput
    upsert?: CategoryUpsertWithoutAddonsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutAddonsInput, CategoryUpdateWithoutAddonsInput>, CategoryUncheckedUpdateWithoutAddonsInput>
  }

  export type TransactionAddonsUpdateManyWithoutAddonNestedInput = {
    create?: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput> | TransactionAddonsCreateWithoutAddonInput[] | TransactionAddonsUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutAddonInput | TransactionAddonsCreateOrConnectWithoutAddonInput[]
    upsert?: TransactionAddonsUpsertWithWhereUniqueWithoutAddonInput | TransactionAddonsUpsertWithWhereUniqueWithoutAddonInput[]
    createMany?: TransactionAddonsCreateManyAddonInputEnvelope
    set?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    disconnect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    delete?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    update?: TransactionAddonsUpdateWithWhereUniqueWithoutAddonInput | TransactionAddonsUpdateWithWhereUniqueWithoutAddonInput[]
    updateMany?: TransactionAddonsUpdateManyWithWhereWithoutAddonInput | TransactionAddonsUpdateManyWithWhereWithoutAddonInput[]
    deleteMany?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
  }

  export type TransactionAddonsUncheckedUpdateManyWithoutAddonNestedInput = {
    create?: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput> | TransactionAddonsCreateWithoutAddonInput[] | TransactionAddonsUncheckedCreateWithoutAddonInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutAddonInput | TransactionAddonsCreateOrConnectWithoutAddonInput[]
    upsert?: TransactionAddonsUpsertWithWhereUniqueWithoutAddonInput | TransactionAddonsUpsertWithWhereUniqueWithoutAddonInput[]
    createMany?: TransactionAddonsCreateManyAddonInputEnvelope
    set?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    disconnect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    delete?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    update?: TransactionAddonsUpdateWithWhereUniqueWithoutAddonInput | TransactionAddonsUpdateWithWhereUniqueWithoutAddonInput[]
    updateMany?: TransactionAddonsUpdateManyWithWhereWithoutAddonInput | TransactionAddonsUpdateManyWithWhereWithoutAddonInput[]
    deleteMany?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
  }

  export type FeatureCreateNestedManyWithoutPackageInput = {
    create?: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput> | FeatureCreateWithoutPackageInput[] | FeatureUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutPackageInput | FeatureCreateOrConnectWithoutPackageInput[]
    createMany?: FeatureCreateManyPackageInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutPackagesInput = {
    create?: XOR<CategoryCreateWithoutPackagesInput, CategoryUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPackagesInput
    connect?: CategoryWhereUniqueInput
  }

  export type SubcategoryCreateNestedOneWithoutPackagesInput = {
    create?: XOR<SubcategoryCreateWithoutPackagesInput, SubcategoryUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutPackagesInput
    connect?: SubcategoryWhereUniqueInput
  }

  export type TransactionProductCreateNestedManyWithoutPackageInput = {
    create?: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput> | TransactionProductCreateWithoutPackageInput[] | TransactionProductUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutPackageInput | TransactionProductCreateOrConnectWithoutPackageInput[]
    createMany?: TransactionProductCreateManyPackageInputEnvelope
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
  }

  export type ServicesProductCustomersCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput> | ServicesProductCustomersCreateWithoutPackageInput[] | ServicesProductCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutPackageInput | ServicesProductCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesProductCustomersCreateManyPackageInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type FeatureUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput> | FeatureCreateWithoutPackageInput[] | FeatureUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutPackageInput | FeatureCreateOrConnectWithoutPackageInput[]
    createMany?: FeatureCreateManyPackageInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type TransactionProductUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput> | TransactionProductCreateWithoutPackageInput[] | TransactionProductUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutPackageInput | TransactionProductCreateOrConnectWithoutPackageInput[]
    createMany?: TransactionProductCreateManyPackageInputEnvelope
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
  }

  export type ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput> | ServicesProductCustomersCreateWithoutPackageInput[] | ServicesProductCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutPackageInput | ServicesProductCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesProductCustomersCreateManyPackageInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type FeatureUpdateManyWithoutPackageNestedInput = {
    create?: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput> | FeatureCreateWithoutPackageInput[] | FeatureUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutPackageInput | FeatureCreateOrConnectWithoutPackageInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutPackageInput | FeatureUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: FeatureCreateManyPackageInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutPackageInput | FeatureUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutPackageInput | FeatureUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<CategoryCreateWithoutPackagesInput, CategoryUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPackagesInput
    upsert?: CategoryUpsertWithoutPackagesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPackagesInput, CategoryUpdateWithoutPackagesInput>, CategoryUncheckedUpdateWithoutPackagesInput>
  }

  export type SubcategoryUpdateOneRequiredWithoutPackagesNestedInput = {
    create?: XOR<SubcategoryCreateWithoutPackagesInput, SubcategoryUncheckedCreateWithoutPackagesInput>
    connectOrCreate?: SubcategoryCreateOrConnectWithoutPackagesInput
    upsert?: SubcategoryUpsertWithoutPackagesInput
    connect?: SubcategoryWhereUniqueInput
    update?: XOR<XOR<SubcategoryUpdateToOneWithWhereWithoutPackagesInput, SubcategoryUpdateWithoutPackagesInput>, SubcategoryUncheckedUpdateWithoutPackagesInput>
  }

  export type TransactionProductUpdateManyWithoutPackageNestedInput = {
    create?: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput> | TransactionProductCreateWithoutPackageInput[] | TransactionProductUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutPackageInput | TransactionProductCreateOrConnectWithoutPackageInput[]
    upsert?: TransactionProductUpsertWithWhereUniqueWithoutPackageInput | TransactionProductUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: TransactionProductCreateManyPackageInputEnvelope
    set?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    disconnect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    delete?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    update?: TransactionProductUpdateWithWhereUniqueWithoutPackageInput | TransactionProductUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: TransactionProductUpdateManyWithWhereWithoutPackageInput | TransactionProductUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
  }

  export type ServicesProductCustomersUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput> | ServicesProductCustomersCreateWithoutPackageInput[] | ServicesProductCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutPackageInput | ServicesProductCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesProductCustomersCreateManyPackageInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutPackageInput | ServicesProductCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type FeatureUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput> | FeatureCreateWithoutPackageInput[] | FeatureUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutPackageInput | FeatureCreateOrConnectWithoutPackageInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutPackageInput | FeatureUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: FeatureCreateManyPackageInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutPackageInput | FeatureUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutPackageInput | FeatureUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type TransactionProductUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput> | TransactionProductCreateWithoutPackageInput[] | TransactionProductUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutPackageInput | TransactionProductCreateOrConnectWithoutPackageInput[]
    upsert?: TransactionProductUpsertWithWhereUniqueWithoutPackageInput | TransactionProductUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: TransactionProductCreateManyPackageInputEnvelope
    set?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    disconnect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    delete?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    update?: TransactionProductUpdateWithWhereUniqueWithoutPackageInput | TransactionProductUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: TransactionProductUpdateManyWithWhereWithoutPackageInput | TransactionProductUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput> | ServicesProductCustomersCreateWithoutPackageInput[] | ServicesProductCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutPackageInput | ServicesProductCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesProductCustomersCreateManyPackageInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutPackageInput | ServicesProductCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWhatsAppSessionsInput = {
    create?: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppMessageStatsCreateNestedManyWithoutSessionInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWhatsAppSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsAppSessionsInput
    upsert?: UserUpsertWithoutWhatsAppSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsAppSessionsInput, UserUpdateWithoutWhatsAppSessionsInput>, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput> | WhatsAppMessageStatsCreateWithoutSessionInput[] | WhatsAppMessageStatsUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: WhatsAppMessageStatsCreateOrConnectWithoutSessionInput | WhatsAppMessageStatsCreateOrConnectWithoutSessionInput[]
    upsert?: WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: WhatsAppMessageStatsCreateManySessionInputEnvelope
    set?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    disconnect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    delete?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    connect?: WhatsAppMessageStatsWhereUniqueInput | WhatsAppMessageStatsWhereUniqueInput[]
    update?: WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput | WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput | WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionsInput
    connect?: VoucherWhereUniqueInput
  }

  export type TransactionProductCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput> | TransactionProductCreateWithoutTransactionInput[] | TransactionProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutTransactionInput | TransactionProductCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionProductCreateManyTransactionInputEnvelope
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
  }

  export type TransactionAddonsCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput> | TransactionAddonsCreateWithoutTransactionInput[] | TransactionAddonsUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutTransactionInput | TransactionAddonsCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionAddonsCreateManyTransactionInputEnvelope
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    connect?: TransactionWhatsappServiceWhereUniqueInput
  }

  export type ServicesProductCustomersCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput> | ServicesProductCustomersCreateWithoutTransactionInput[] | ServicesProductCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutTransactionInput | ServicesProductCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesProductCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput> | ServicesAddonsCustomersCreateWithoutTransactionInput[] | ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput | ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesAddonsCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput> | ServicesWhatsappCustomersCreateWithoutTransactionInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput | ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesWhatsappCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutTransactionInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    connect?: PaymentWhereUniqueInput
  }

  export type TransactionProductUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput> | TransactionProductCreateWithoutTransactionInput[] | TransactionProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutTransactionInput | TransactionProductCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionProductCreateManyTransactionInputEnvelope
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
  }

  export type TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput> | TransactionAddonsCreateWithoutTransactionInput[] | TransactionAddonsUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutTransactionInput | TransactionAddonsCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionAddonsCreateManyTransactionInputEnvelope
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    connect?: TransactionWhatsappServiceWhereUniqueInput
  }

  export type ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput> | ServicesProductCustomersCreateWithoutTransactionInput[] | ServicesProductCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutTransactionInput | ServicesProductCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesProductCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
  }

  export type ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput> | ServicesAddonsCustomersCreateWithoutTransactionInput[] | ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput | ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesAddonsCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput> | ServicesWhatsappCustomersCreateWithoutTransactionInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput | ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput[]
    createMany?: ServicesWhatsappCustomersCreateManyTransactionInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PaymentUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type VoucherUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutTransactionsInput
    upsert?: VoucherUpsertWithoutTransactionsInput
    disconnect?: VoucherWhereInput | boolean
    delete?: VoucherWhereInput | boolean
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutTransactionsInput, VoucherUpdateWithoutTransactionsInput>, VoucherUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionProductUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput> | TransactionProductCreateWithoutTransactionInput[] | TransactionProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutTransactionInput | TransactionProductCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionProductUpsertWithWhereUniqueWithoutTransactionInput | TransactionProductUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionProductCreateManyTransactionInputEnvelope
    set?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    disconnect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    delete?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    update?: TransactionProductUpdateWithWhereUniqueWithoutTransactionInput | TransactionProductUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionProductUpdateManyWithWhereWithoutTransactionInput | TransactionProductUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
  }

  export type TransactionAddonsUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput> | TransactionAddonsCreateWithoutTransactionInput[] | TransactionAddonsUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutTransactionInput | TransactionAddonsCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionAddonsUpsertWithWhereUniqueWithoutTransactionInput | TransactionAddonsUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionAddonsCreateManyTransactionInputEnvelope
    set?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    disconnect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    delete?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    update?: TransactionAddonsUpdateWithWhereUniqueWithoutTransactionInput | TransactionAddonsUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionAddonsUpdateManyWithWhereWithoutTransactionInput | TransactionAddonsUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
  }

  export type TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    upsert?: TransactionWhatsappServiceUpsertWithoutTransactionInput
    disconnect?: TransactionWhatsappServiceWhereInput | boolean
    delete?: TransactionWhatsappServiceWhereInput | boolean
    connect?: TransactionWhatsappServiceWhereUniqueInput
    update?: XOR<XOR<TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput, TransactionWhatsappServiceUpdateWithoutTransactionInput>, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type ServicesProductCustomersUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput> | ServicesProductCustomersCreateWithoutTransactionInput[] | ServicesProductCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutTransactionInput | ServicesProductCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesProductCustomersCreateManyTransactionInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesProductCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput> | ServicesAddonsCustomersCreateWithoutTransactionInput[] | ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput | ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesAddonsCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesAddonsCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesAddonsCustomersCreateManyTransactionInputEnvelope
    set?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    disconnect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    delete?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    update?: ServicesAddonsCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesAddonsCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesAddonsCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesAddonsCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput> | ServicesWhatsappCustomersCreateWithoutTransactionInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput | ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesWhatsappCustomersCreateManyTransactionInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput | VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput | VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutTransactionInput | VoucherUsageUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutTransactionInput
    upsert?: PaymentUpsertWithoutTransactionInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutTransactionInput, PaymentUpdateWithoutTransactionInput>, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput> | TransactionProductCreateWithoutTransactionInput[] | TransactionProductUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionProductCreateOrConnectWithoutTransactionInput | TransactionProductCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionProductUpsertWithWhereUniqueWithoutTransactionInput | TransactionProductUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionProductCreateManyTransactionInputEnvelope
    set?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    disconnect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    delete?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    connect?: TransactionProductWhereUniqueInput | TransactionProductWhereUniqueInput[]
    update?: TransactionProductUpdateWithWhereUniqueWithoutTransactionInput | TransactionProductUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionProductUpdateManyWithWhereWithoutTransactionInput | TransactionProductUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
  }

  export type TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput> | TransactionAddonsCreateWithoutTransactionInput[] | TransactionAddonsUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionAddonsCreateOrConnectWithoutTransactionInput | TransactionAddonsCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionAddonsUpsertWithWhereUniqueWithoutTransactionInput | TransactionAddonsUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionAddonsCreateManyTransactionInputEnvelope
    set?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    disconnect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    delete?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    connect?: TransactionAddonsWhereUniqueInput | TransactionAddonsWhereUniqueInput[]
    update?: TransactionAddonsUpdateWithWhereUniqueWithoutTransactionInput | TransactionAddonsUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionAddonsUpdateManyWithWhereWithoutTransactionInput | TransactionAddonsUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
  }

  export type TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput
    upsert?: TransactionWhatsappServiceUpsertWithoutTransactionInput
    disconnect?: TransactionWhatsappServiceWhereInput | boolean
    delete?: TransactionWhatsappServiceWhereInput | boolean
    connect?: TransactionWhatsappServiceWhereUniqueInput
    update?: XOR<XOR<TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput, TransactionWhatsappServiceUpdateWithoutTransactionInput>, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput> | ServicesProductCustomersCreateWithoutTransactionInput[] | ServicesProductCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesProductCustomersCreateOrConnectWithoutTransactionInput | ServicesProductCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesProductCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesProductCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesProductCustomersCreateManyTransactionInputEnvelope
    set?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    disconnect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    delete?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    connect?: ServicesProductCustomersWhereUniqueInput | ServicesProductCustomersWhereUniqueInput[]
    update?: ServicesProductCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesProductCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesProductCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesProductCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
  }

  export type ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput> | ServicesAddonsCustomersCreateWithoutTransactionInput[] | ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput | ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesAddonsCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesAddonsCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesAddonsCustomersCreateManyTransactionInputEnvelope
    set?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    disconnect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    delete?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    connect?: ServicesAddonsCustomersWhereUniqueInput | ServicesAddonsCustomersWhereUniqueInput[]
    update?: ServicesAddonsCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesAddonsCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesAddonsCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesAddonsCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput> | ServicesWhatsappCustomersCreateWithoutTransactionInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput | ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutTransactionInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: ServicesWhatsappCustomersCreateManyTransactionInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutTransactionInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutTransactionInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput> | VoucherUsageCreateWithoutTransactionInput[] | VoucherUsageUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutTransactionInput | VoucherUsageCreateOrConnectWithoutTransactionInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput | VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: VoucherUsageCreateManyTransactionInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput | VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutTransactionInput | VoucherUsageUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type PackageCreateNestedOneWithoutProductTransactionsInput = {
    create?: XOR<PackageCreateWithoutProductTransactionsInput, PackageUncheckedCreateWithoutProductTransactionsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutProductTransactionsInput
    connect?: PackageWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutProductTransactionsInput = {
    create?: XOR<TransactionCreateWithoutProductTransactionsInput, TransactionUncheckedCreateWithoutProductTransactionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductTransactionsInput
    connect?: TransactionWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PackageUpdateOneWithoutProductTransactionsNestedInput = {
    create?: XOR<PackageCreateWithoutProductTransactionsInput, PackageUncheckedCreateWithoutProductTransactionsInput>
    connectOrCreate?: PackageCreateOrConnectWithoutProductTransactionsInput
    upsert?: PackageUpsertWithoutProductTransactionsInput
    disconnect?: PackageWhereInput | boolean
    delete?: PackageWhereInput | boolean
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutProductTransactionsInput, PackageUpdateWithoutProductTransactionsInput>, PackageUncheckedUpdateWithoutProductTransactionsInput>
  }

  export type TransactionUpdateOneRequiredWithoutProductTransactionsNestedInput = {
    create?: XOR<TransactionCreateWithoutProductTransactionsInput, TransactionUncheckedCreateWithoutProductTransactionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductTransactionsInput
    upsert?: TransactionUpsertWithoutProductTransactionsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutProductTransactionsInput, TransactionUpdateWithoutProductTransactionsInput>, TransactionUncheckedUpdateWithoutProductTransactionsInput>
  }

  export type AddonCreateNestedOneWithoutAddonTransactionsInput = {
    create?: XOR<AddonCreateWithoutAddonTransactionsInput, AddonUncheckedCreateWithoutAddonTransactionsInput>
    connectOrCreate?: AddonCreateOrConnectWithoutAddonTransactionsInput
    connect?: AddonWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutAddonTransactionsInput = {
    create?: XOR<TransactionCreateWithoutAddonTransactionsInput, TransactionUncheckedCreateWithoutAddonTransactionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAddonTransactionsInput
    connect?: TransactionWhereUniqueInput
  }

  export type AddonUpdateOneRequiredWithoutAddonTransactionsNestedInput = {
    create?: XOR<AddonCreateWithoutAddonTransactionsInput, AddonUncheckedCreateWithoutAddonTransactionsInput>
    connectOrCreate?: AddonCreateOrConnectWithoutAddonTransactionsInput
    upsert?: AddonUpsertWithoutAddonTransactionsInput
    connect?: AddonWhereUniqueInput
    update?: XOR<XOR<AddonUpdateToOneWithWhereWithoutAddonTransactionsInput, AddonUpdateWithoutAddonTransactionsInput>, AddonUncheckedUpdateWithoutAddonTransactionsInput>
  }

  export type TransactionUpdateOneRequiredWithoutAddonTransactionsNestedInput = {
    create?: XOR<TransactionCreateWithoutAddonTransactionsInput, TransactionUncheckedCreateWithoutAddonTransactionsInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAddonTransactionsInput
    upsert?: TransactionUpsertWithoutAddonTransactionsInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutAddonTransactionsInput, TransactionUpdateWithoutAddonTransactionsInput>, TransactionUncheckedUpdateWithoutAddonTransactionsInput>
  }

  export type TransactionCreateNestedOneWithoutWhatsappTransactionInput = {
    create?: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappTransactionInput
    connect?: TransactionWhereUniqueInput
  }

  export type WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput
    connect?: WhatsappApiPackageWhereUniqueInput
  }

  export type TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput = {
    create?: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappTransactionInput
    upsert?: TransactionUpsertWithoutWhatsappTransactionInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutWhatsappTransactionInput, TransactionUpdateWithoutWhatsappTransactionInput>, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
  }

  export type WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput
    upsert?: WhatsappApiPackageUpsertWithoutWhatsappTransactionsInput
    connect?: WhatsappApiPackageWhereUniqueInput
    update?: XOR<XOR<WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappTransactionsInput, WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput>, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
  }

  export type TransactionCreateNestedOneWithoutPaymentInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutPaymentInput
    upsert?: TransactionUpsertWithoutPaymentInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutPaymentInput, TransactionUpdateWithoutPaymentInput>, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
  }

  export type ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
  }

  export type TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    upsert?: TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    set?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    disconnect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    delete?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    update?: TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput[]
    updateMany?: TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput[]
    deleteMany?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput = {
    create?: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput> | TransactionWhatsappServiceCreateWithoutWhatsappPackageInput[] | TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput[]
    connectOrCreate?: TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput | TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput[]
    upsert?: TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput[]
    createMany?: TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope
    set?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    disconnect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    delete?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    connect?: TransactionWhatsappServiceWhereUniqueInput | TransactionWhatsappServiceWhereUniqueInput[]
    update?: TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput[]
    updateMany?: TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput | TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput[]
    deleteMany?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput = {
    create?: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput> | ServicesWhatsappCustomersCreateWithoutPackageInput[] | ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput[]
    connectOrCreate?: ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput | ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput[]
    upsert?: ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput[]
    createMany?: ServicesWhatsappCustomersCreateManyPackageInputEnvelope
    set?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    disconnect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    delete?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    connect?: ServicesWhatsappCustomersWhereUniqueInput | ServicesWhatsappCustomersWhereUniqueInput[]
    update?: ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput | ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput[]
    updateMany?: ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput | ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput[]
    deleteMany?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWhatsappCustomersInput = {
    create?: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutWhatsappCustomersInput = {
    create?: XOR<TransactionCreateWithoutWhatsappCustomersInput, TransactionUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappCustomersInput
    connect?: TransactionWhereUniqueInput
  }

  export type WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput
    connect?: WhatsappApiPackageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappCustomersInput
    upsert?: UserUpsertWithoutWhatsappCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappCustomersInput, UserUpdateWithoutWhatsappCustomersInput>, UserUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type TransactionUpdateOneRequiredWithoutWhatsappCustomersNestedInput = {
    create?: XOR<TransactionCreateWithoutWhatsappCustomersInput, TransactionUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutWhatsappCustomersInput
    upsert?: TransactionUpsertWithoutWhatsappCustomersInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutWhatsappCustomersInput, TransactionUpdateWithoutWhatsappCustomersInput>, TransactionUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput = {
    create?: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    connectOrCreate?: WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput
    upsert?: WhatsappApiPackageUpsertWithoutWhatsappCustomersInput
    connect?: WhatsappApiPackageWhereUniqueInput
    update?: XOR<XOR<WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappCustomersInput, WhatsappApiPackageUpdateWithoutWhatsappCustomersInput>, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type UserCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    upsert?: UserUpsertWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSessionsInput, UserUpdateWithoutUserSessionsInput>, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type TransactionCreateNestedManyWithoutVoucherInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherUsageCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TransactionUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherInput | TransactionUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherInput | TransactionUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherInput | TransactionUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUsageUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput> | TransactionCreateWithoutVoucherInput[] | TransactionUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherInput | TransactionCreateOrConnectWithoutVoucherInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutVoucherInput | TransactionUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: TransactionCreateManyVoucherInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutVoucherInput | TransactionUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutVoucherInput | TransactionUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput = {
    create?: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput> | VoucherUsageCreateWithoutVoucherInput[] | VoucherUsageUncheckedCreateWithoutVoucherInput[]
    connectOrCreate?: VoucherUsageCreateOrConnectWithoutVoucherInput | VoucherUsageCreateOrConnectWithoutVoucherInput[]
    upsert?: VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput | VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput[]
    createMany?: VoucherUsageCreateManyVoucherInputEnvelope
    set?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    disconnect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    delete?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    connect?: VoucherUsageWhereUniqueInput | VoucherUsageWhereUniqueInput[]
    update?: VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput | VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput[]
    updateMany?: VoucherUsageUpdateManyWithWhereWithoutVoucherInput | VoucherUsageUpdateManyWithWhereWithoutVoucherInput[]
    deleteMany?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
  }

  export type TransactionCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsageInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsageInput
    connect?: UserWhereUniqueInput
  }

  export type VoucherCreateNestedOneWithoutVoucherUsageInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsageInput
    connect?: VoucherWhereUniqueInput
  }

  export type TransactionUpdateOneWithoutVoucherUsageNestedInput = {
    create?: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutVoucherUsageInput
    upsert?: TransactionUpsertWithoutVoucherUsageInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutVoucherUsageInput, TransactionUpdateWithoutVoucherUsageInput>, TransactionUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type UserUpdateOneRequiredWithoutVoucherUsageNestedInput = {
    create?: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoucherUsageInput
    upsert?: UserUpsertWithoutVoucherUsageInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoucherUsageInput, UserUpdateWithoutVoucherUsageInput>, UserUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput = {
    create?: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    connectOrCreate?: VoucherCreateOrConnectWithoutVoucherUsageInput
    upsert?: VoucherUpsertWithoutVoucherUsageInput
    connect?: VoucherWhereUniqueInput
    update?: XOR<XOR<VoucherUpdateToOneWithWhereWithoutVoucherUsageInput, VoucherUpdateWithoutVoucherUsageInput>, VoucherUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type UserCreateNestedOneWithoutProductCustomersInput = {
    create?: XOR<UserCreateWithoutProductCustomersInput, UserUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutProductCustomersInput = {
    create?: XOR<TransactionCreateWithoutProductCustomersInput, TransactionUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductCustomersInput
    connect?: TransactionWhereUniqueInput
  }

  export type PackageCreateNestedOneWithoutProductCustomersInput = {
    create?: XOR<PackageCreateWithoutProductCustomersInput, PackageUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: PackageCreateOrConnectWithoutProductCustomersInput
    connect?: PackageWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutProductCustomersNestedInput = {
    create?: XOR<UserCreateWithoutProductCustomersInput, UserUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductCustomersInput
    upsert?: UserUpsertWithoutProductCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductCustomersInput, UserUpdateWithoutProductCustomersInput>, UserUncheckedUpdateWithoutProductCustomersInput>
  }

  export type TransactionUpdateOneRequiredWithoutProductCustomersNestedInput = {
    create?: XOR<TransactionCreateWithoutProductCustomersInput, TransactionUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutProductCustomersInput
    upsert?: TransactionUpsertWithoutProductCustomersInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutProductCustomersInput, TransactionUpdateWithoutProductCustomersInput>, TransactionUncheckedUpdateWithoutProductCustomersInput>
  }

  export type PackageUpdateOneWithoutProductCustomersNestedInput = {
    create?: XOR<PackageCreateWithoutProductCustomersInput, PackageUncheckedCreateWithoutProductCustomersInput>
    connectOrCreate?: PackageCreateOrConnectWithoutProductCustomersInput
    upsert?: PackageUpsertWithoutProductCustomersInput
    disconnect?: PackageWhereInput | boolean
    delete?: PackageWhereInput | boolean
    connect?: PackageWhereUniqueInput
    update?: XOR<XOR<PackageUpdateToOneWithWhereWithoutProductCustomersInput, PackageUpdateWithoutProductCustomersInput>, PackageUncheckedUpdateWithoutProductCustomersInput>
  }

  export type UserCreateNestedOneWithoutAddonCustomersInput = {
    create?: XOR<UserCreateWithoutAddonCustomersInput, UserUncheckedCreateWithoutAddonCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddonCustomersInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutAddonCustomersInput = {
    create?: XOR<TransactionCreateWithoutAddonCustomersInput, TransactionUncheckedCreateWithoutAddonCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAddonCustomersInput
    connect?: TransactionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddonCustomersNestedInput = {
    create?: XOR<UserCreateWithoutAddonCustomersInput, UserUncheckedCreateWithoutAddonCustomersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddonCustomersInput
    upsert?: UserUpsertWithoutAddonCustomersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddonCustomersInput, UserUpdateWithoutAddonCustomersInput>, UserUncheckedUpdateWithoutAddonCustomersInput>
  }

  export type TransactionUpdateOneRequiredWithoutAddonCustomersNestedInput = {
    create?: XOR<TransactionCreateWithoutAddonCustomersInput, TransactionUncheckedCreateWithoutAddonCustomersInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutAddonCustomersInput
    upsert?: TransactionUpsertWithoutAddonCustomersInput
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutAddonCustomersInput, TransactionUpdateWithoutAddonCustomersInput>, TransactionUncheckedUpdateWithoutAddonCustomersInput>
  }

  export type UserCreateNestedOneWithoutWhatsappMessageStatsInput = {
    create?: XOR<UserCreateWithoutWhatsappMessageStatsInput, UserUncheckedCreateWithoutWhatsappMessageStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappMessageStatsInput
    connect?: UserWhereUniqueInput
  }

  export type WhatsAppSessionCreateNestedOneWithoutWhatsappMessageStatsInput = {
    create?: XOR<WhatsAppSessionCreateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsappMessageStatsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutWhatsappMessageStatsInput
    connect?: WhatsAppSessionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput = {
    create?: XOR<UserCreateWithoutWhatsappMessageStatsInput, UserUncheckedCreateWithoutWhatsappMessageStatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhatsappMessageStatsInput
    upsert?: UserUpsertWithoutWhatsappMessageStatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhatsappMessageStatsInput, UserUpdateWithoutWhatsappMessageStatsInput>, UserUncheckedUpdateWithoutWhatsappMessageStatsInput>
  }

  export type WhatsAppSessionUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput = {
    create?: XOR<WhatsAppSessionCreateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsappMessageStatsInput>
    connectOrCreate?: WhatsAppSessionCreateOrConnectWithoutWhatsappMessageStatsInput
    upsert?: WhatsAppSessionUpsertWithoutWhatsappMessageStatsInput
    connect?: WhatsAppSessionWhereUniqueInput
    update?: XOR<XOR<WhatsAppSessionUpdateToOneWithWhereWithoutWhatsappMessageStatsInput, WhatsAppSessionUpdateWithoutWhatsappMessageStatsInput>, WhatsAppSessionUncheckedUpdateWithoutWhatsappMessageStatsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsageCreateWithoutUserInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutUserInput = {
    id?: string
    voucherId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageCreateManyUserInputEnvelope = {
    data: VoucherUsageCreateManyUserInput | VoucherUsageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppSessionCreateWithoutUserInput = {
    id?: string
    sessionId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutSessionInput
  }

  export type WhatsAppSessionCreateOrConnectWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppSessionCreateManyUserInputEnvelope = {
    data: WhatsAppSessionCreateManyUserInput | WhatsAppSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ServicesProductCustomersCreateWithoutCustomerInput = {
    id?: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutProductCustomersInput
    package?: PackageCreateNestedOneWithoutProductCustomersInput
  }

  export type ServicesProductCustomersUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesProductCustomersCreateOrConnectWithoutCustomerInput = {
    where: ServicesProductCustomersWhereUniqueInput
    create: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesProductCustomersCreateManyCustomerInputEnvelope = {
    data: ServicesProductCustomersCreateManyCustomerInput | ServicesProductCustomersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ServicesAddonsCustomersCreateWithoutCustomerInput = {
    id?: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutAddonCustomersInput
  }

  export type ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersCreateOrConnectWithoutCustomerInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    create: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesAddonsCustomersCreateManyCustomerInputEnvelope = {
    data: ServicesAddonsCustomersCreateManyCustomerInput | ServicesAddonsCustomersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ServicesWhatsappCustomersCreateWithoutCustomerInput = {
    id?: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: TransactionCreateNestedOneWithoutWhatsappCustomersInput
    package: WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput = {
    id?: string
    transactionId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateOrConnectWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    create: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersCreateManyCustomerInputEnvelope = {
    data: ServicesWhatsappCustomersCreateManyCustomerInput | ServicesWhatsappCustomersCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppMessageStatsCreateWithoutUserInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    session: WhatsAppSessionCreateNestedOneWithoutWhatsappMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsCreateOrConnectWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    create: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppMessageStatsCreateManyUserInputEnvelope = {
    data: WhatsAppMessageStatsCreateManyUserInput | WhatsAppMessageStatsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringFilter<"Transaction"> | string
    transactionDate?: DateTimeFilter<"Transaction"> | Date | string
    status?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    type?: StringFilter<"Transaction"> | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    discountAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    originalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    voucherId?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    currency?: StringFilter<"Transaction"> | string
    finalAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    expiresAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    lastUsed?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    id?: StringFilter<"UserSession"> | string
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
    create: XOR<VoucherUsageCreateWithoutUserInput, VoucherUsageUncheckedCreateWithoutUserInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutUserInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutUserInput, VoucherUsageUncheckedUpdateWithoutUserInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutUserInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutUserInput>
  }

  export type VoucherUsageScalarWhereInput = {
    AND?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    OR?: VoucherUsageScalarWhereInput[]
    NOT?: VoucherUsageScalarWhereInput | VoucherUsageScalarWhereInput[]
    id?: StringFilter<"VoucherUsage"> | string
    voucherId?: StringFilter<"VoucherUsage"> | string
    userId?: StringFilter<"VoucherUsage"> | string
    transactionId?: StringNullableFilter<"VoucherUsage"> | string | null
    usedAt?: DateTimeFilter<"VoucherUsage"> | Date | string
    discountAmount?: DecimalFilter<"VoucherUsage"> | Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    update: XOR<WhatsAppSessionUpdateWithoutUserInput, WhatsAppSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppSessionCreateWithoutUserInput, WhatsAppSessionUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppSessionWhereUniqueInput
    data: XOR<WhatsAppSessionUpdateWithoutUserInput, WhatsAppSessionUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppSessionUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppSessionScalarWhereInput
    data: XOR<WhatsAppSessionUpdateManyMutationInput, WhatsAppSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppSessionScalarWhereInput = {
    AND?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    OR?: WhatsAppSessionScalarWhereInput[]
    NOT?: WhatsAppSessionScalarWhereInput | WhatsAppSessionScalarWhereInput[]
    id?: StringFilter<"WhatsAppSession"> | string
    sessionId?: StringFilter<"WhatsAppSession"> | string
    userId?: StringFilter<"WhatsAppSession"> | string
    status?: StringFilter<"WhatsAppSession"> | string
    qr?: StringNullableFilter<"WhatsAppSession"> | string | null
    isNotification?: BoolFilter<"WhatsAppSession"> | boolean
    createdAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppSession"> | Date | string
    aiConfig?: StringNullableFilter<"WhatsAppSession"> | string | null
    message?: StringNullableFilter<"WhatsAppSession"> | string | null
    sessionName?: StringNullableFilter<"WhatsAppSession"> | string | null
    isTerminated?: BoolFilter<"WhatsAppSession"> | boolean
  }

  export type ServicesProductCustomersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServicesProductCustomersWhereUniqueInput
    update: XOR<ServicesProductCustomersUpdateWithoutCustomerInput, ServicesProductCustomersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServicesProductCustomersCreateWithoutCustomerInput, ServicesProductCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesProductCustomersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServicesProductCustomersWhereUniqueInput
    data: XOR<ServicesProductCustomersUpdateWithoutCustomerInput, ServicesProductCustomersUncheckedUpdateWithoutCustomerInput>
  }

  export type ServicesProductCustomersUpdateManyWithWhereWithoutCustomerInput = {
    where: ServicesProductCustomersScalarWhereInput
    data: XOR<ServicesProductCustomersUpdateManyMutationInput, ServicesProductCustomersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServicesProductCustomersScalarWhereInput = {
    AND?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
    OR?: ServicesProductCustomersScalarWhereInput[]
    NOT?: ServicesProductCustomersScalarWhereInput | ServicesProductCustomersScalarWhereInput[]
    id?: StringFilter<"ServicesProductCustomers"> | string
    transactionId?: StringFilter<"ServicesProductCustomers"> | string
    customerId?: StringFilter<"ServicesProductCustomers"> | string
    packageId?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    quantity?: IntFilter<"ServicesProductCustomers"> | number
    websiteUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    driveUrl?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    textDescription?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainName?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    domainExpiredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    fileAssets?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    status?: StringFilter<"ServicesProductCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesProductCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesProductCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesProductCustomers"> | Date | string
  }

  export type ServicesAddonsCustomersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    update: XOR<ServicesAddonsCustomersUpdateWithoutCustomerInput, ServicesAddonsCustomersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServicesAddonsCustomersCreateWithoutCustomerInput, ServicesAddonsCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesAddonsCustomersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    data: XOR<ServicesAddonsCustomersUpdateWithoutCustomerInput, ServicesAddonsCustomersUncheckedUpdateWithoutCustomerInput>
  }

  export type ServicesAddonsCustomersUpdateManyWithWhereWithoutCustomerInput = {
    where: ServicesAddonsCustomersScalarWhereInput
    data: XOR<ServicesAddonsCustomersUpdateManyMutationInput, ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServicesAddonsCustomersScalarWhereInput = {
    AND?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
    OR?: ServicesAddonsCustomersScalarWhereInput[]
    NOT?: ServicesAddonsCustomersScalarWhereInput | ServicesAddonsCustomersScalarWhereInput[]
    id?: StringFilter<"ServicesAddonsCustomers"> | string
    transactionId?: StringFilter<"ServicesAddonsCustomers"> | string
    customerId?: StringFilter<"ServicesAddonsCustomers"> | string
    addonDetails?: StringFilter<"ServicesAddonsCustomers"> | string
    driveUrl?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    fileAssets?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    status?: StringFilter<"ServicesAddonsCustomers"> | string
    deliveredAt?: DateTimeNullableFilter<"ServicesAddonsCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesAddonsCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesAddonsCustomers"> | Date | string
  }

  export type ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    update: XOR<ServicesWhatsappCustomersUpdateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServicesWhatsappCustomersCreateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedCreateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    data: XOR<ServicesWhatsappCustomersUpdateWithoutCustomerInput, ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersUpdateManyWithWhereWithoutCustomerInput = {
    where: ServicesWhatsappCustomersScalarWhereInput
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServicesWhatsappCustomersScalarWhereInput = {
    AND?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
    OR?: ServicesWhatsappCustomersScalarWhereInput[]
    NOT?: ServicesWhatsappCustomersScalarWhereInput | ServicesWhatsappCustomersScalarWhereInput[]
    id?: StringFilter<"ServicesWhatsappCustomers"> | string
    transactionId?: StringFilter<"ServicesWhatsappCustomers"> | string
    customerId?: StringFilter<"ServicesWhatsappCustomers"> | string
    packageId?: StringFilter<"ServicesWhatsappCustomers"> | string
    sessionId?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    qrCode?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    status?: StringFilter<"ServicesWhatsappCustomers"> | string
    expiredAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    activatedAt?: DateTimeNullableFilter<"ServicesWhatsappCustomers"> | Date | string | null
    notes?: StringNullableFilter<"ServicesWhatsappCustomers"> | string | null
    createdAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
    updatedAt?: DateTimeFilter<"ServicesWhatsappCustomers"> | Date | string
  }

  export type WhatsAppMessageStatsUpsertWithWhereUniqueWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    update: XOR<WhatsAppMessageStatsUpdateWithoutUserInput, WhatsAppMessageStatsUncheckedUpdateWithoutUserInput>
    create: XOR<WhatsAppMessageStatsCreateWithoutUserInput, WhatsAppMessageStatsUncheckedCreateWithoutUserInput>
  }

  export type WhatsAppMessageStatsUpdateWithWhereUniqueWithoutUserInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    data: XOR<WhatsAppMessageStatsUpdateWithoutUserInput, WhatsAppMessageStatsUncheckedUpdateWithoutUserInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithWhereWithoutUserInput = {
    where: WhatsAppMessageStatsScalarWhereInput
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyWithoutUserInput>
  }

  export type WhatsAppMessageStatsScalarWhereInput = {
    AND?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
    OR?: WhatsAppMessageStatsScalarWhereInput[]
    NOT?: WhatsAppMessageStatsScalarWhereInput | WhatsAppMessageStatsScalarWhereInput[]
    id?: StringFilter<"WhatsAppMessageStats"> | string
    userId?: StringFilter<"WhatsAppMessageStats"> | string
    sessionId?: StringFilter<"WhatsAppMessageStats"> | string
    totalMessagesSent?: IntFilter<"WhatsAppMessageStats"> | number
    totalMessagesFailed?: IntFilter<"WhatsAppMessageStats"> | number
    lastMessageSentAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    lastMessageFailedAt?: DateTimeNullableFilter<"WhatsAppMessageStats"> | Date | string | null
    createdAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppMessageStats"> | Date | string
  }

  export type PackageCreateWithoutFeaturesInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    category: CategoryCreateNestedOneWithoutPackagesInput
    subcategory: SubcategoryCreateNestedOneWithoutPackagesInput
    productTransactions?: TransactionProductCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutFeaturesInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    subcategoryId: string
    popular?: boolean | null
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutFeaturesInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutFeaturesInput, PackageUncheckedCreateWithoutFeaturesInput>
  }

  export type PackageUpsertWithoutFeaturesInput = {
    update: XOR<PackageUpdateWithoutFeaturesInput, PackageUncheckedUpdateWithoutFeaturesInput>
    create: XOR<PackageCreateWithoutFeaturesInput, PackageUncheckedCreateWithoutFeaturesInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutFeaturesInput, PackageUncheckedUpdateWithoutFeaturesInput>
  }

  export type PackageUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: CategoryUpdateOneRequiredWithoutPackagesNestedInput
    subcategory?: SubcategoryUpdateOneRequiredWithoutPackagesNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageCreateWithoutSubcategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    features?: FeatureCreateNestedManyWithoutPackageInput
    category: CategoryCreateNestedOneWithoutPackagesInput
    productTransactions?: TransactionProductCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutSubcategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    popular?: boolean | null
    features?: FeatureUncheckedCreateNestedManyWithoutPackageInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutSubcategoryInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput>
  }

  export type PackageCreateManySubcategoryInputEnvelope = {
    data: PackageCreateManySubcategoryInput | PackageCreateManySubcategoryInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutSubcategoriesInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonCreateNestedManyWithoutCategoryInput
    packages?: PackageCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutSubcategoriesInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonUncheckedCreateNestedManyWithoutCategoryInput
    packages?: PackageUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutSubcategoriesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
  }

  export type PackageUpsertWithWhereUniqueWithoutSubcategoryInput = {
    where: PackageWhereUniqueInput
    update: XOR<PackageUpdateWithoutSubcategoryInput, PackageUncheckedUpdateWithoutSubcategoryInput>
    create: XOR<PackageCreateWithoutSubcategoryInput, PackageUncheckedCreateWithoutSubcategoryInput>
  }

  export type PackageUpdateWithWhereUniqueWithoutSubcategoryInput = {
    where: PackageWhereUniqueInput
    data: XOR<PackageUpdateWithoutSubcategoryInput, PackageUncheckedUpdateWithoutSubcategoryInput>
  }

  export type PackageUpdateManyWithWhereWithoutSubcategoryInput = {
    where: PackageScalarWhereInput
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyWithoutSubcategoryInput>
  }

  export type PackageScalarWhereInput = {
    AND?: PackageScalarWhereInput | PackageScalarWhereInput[]
    OR?: PackageScalarWhereInput[]
    NOT?: PackageScalarWhereInput | PackageScalarWhereInput[]
    id?: StringFilter<"Package"> | string
    name_en?: StringFilter<"Package"> | string
    name_id?: StringFilter<"Package"> | string
    description_en?: StringFilter<"Package"> | string
    description_id?: StringFilter<"Package"> | string
    price_idr?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Package"> | Decimal | DecimalJsLike | number | string
    image?: StringFilter<"Package"> | string
    categoryId?: StringFilter<"Package"> | string
    subcategoryId?: StringFilter<"Package"> | string
    popular?: BoolNullableFilter<"Package"> | boolean | null
  }

  export type CategoryUpsertWithoutSubcategoriesInput = {
    update: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
    create: XOR<CategoryCreateWithoutSubcategoriesInput, CategoryUncheckedCreateWithoutSubcategoriesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutSubcategoriesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutSubcategoriesInput, CategoryUncheckedUpdateWithoutSubcategoriesInput>
  }

  export type CategoryUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUpdateManyWithoutCategoryNestedInput
    packages?: PackageUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutSubcategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUncheckedUpdateManyWithoutCategoryNestedInput
    packages?: PackageUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type AddonCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutAddonInput
  }

  export type AddonUncheckedCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutAddonInput
  }

  export type AddonCreateOrConnectWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    create: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput>
  }

  export type AddonCreateManyCategoryInputEnvelope = {
    data: AddonCreateManyCategoryInput | AddonCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PackageCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    features?: FeatureCreateNestedManyWithoutPackageInput
    subcategory: SubcategoryCreateNestedOneWithoutPackagesInput
    productTransactions?: TransactionProductCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    subcategoryId: string
    popular?: boolean | null
    features?: FeatureUncheckedCreateNestedManyWithoutPackageInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutCategoryInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput>
  }

  export type PackageCreateManyCategoryInputEnvelope = {
    data: PackageCreateManyCategoryInput | PackageCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SubcategoryCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    packages?: PackageCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryUncheckedCreateWithoutCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    packages?: PackageUncheckedCreateNestedManyWithoutSubcategoryInput
  }

  export type SubcategoryCreateOrConnectWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryCreateManyCategoryInputEnvelope = {
    data: SubcategoryCreateManyCategoryInput | SubcategoryCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type AddonUpsertWithWhereUniqueWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    update: XOR<AddonUpdateWithoutCategoryInput, AddonUncheckedUpdateWithoutCategoryInput>
    create: XOR<AddonCreateWithoutCategoryInput, AddonUncheckedCreateWithoutCategoryInput>
  }

  export type AddonUpdateWithWhereUniqueWithoutCategoryInput = {
    where: AddonWhereUniqueInput
    data: XOR<AddonUpdateWithoutCategoryInput, AddonUncheckedUpdateWithoutCategoryInput>
  }

  export type AddonUpdateManyWithWhereWithoutCategoryInput = {
    where: AddonScalarWhereInput
    data: XOR<AddonUpdateManyMutationInput, AddonUncheckedUpdateManyWithoutCategoryInput>
  }

  export type AddonScalarWhereInput = {
    AND?: AddonScalarWhereInput | AddonScalarWhereInput[]
    OR?: AddonScalarWhereInput[]
    NOT?: AddonScalarWhereInput | AddonScalarWhereInput[]
    id?: StringFilter<"Addon"> | string
    name_en?: StringFilter<"Addon"> | string
    name_id?: StringFilter<"Addon"> | string
    description_en?: StringNullableFilter<"Addon"> | string | null
    description_id?: StringNullableFilter<"Addon"> | string | null
    price_idr?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFilter<"Addon"> | Decimal | DecimalJsLike | number | string
    image?: StringNullableFilter<"Addon"> | string | null
    categoryId?: StringFilter<"Addon"> | string
  }

  export type PackageUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PackageWhereUniqueInput
    update: XOR<PackageUpdateWithoutCategoryInput, PackageUncheckedUpdateWithoutCategoryInput>
    create: XOR<PackageCreateWithoutCategoryInput, PackageUncheckedCreateWithoutCategoryInput>
  }

  export type PackageUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PackageWhereUniqueInput
    data: XOR<PackageUpdateWithoutCategoryInput, PackageUncheckedUpdateWithoutCategoryInput>
  }

  export type PackageUpdateManyWithWhereWithoutCategoryInput = {
    where: PackageScalarWhereInput
    data: XOR<PackageUpdateManyMutationInput, PackageUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryUpsertWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    update: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
    create: XOR<SubcategoryCreateWithoutCategoryInput, SubcategoryUncheckedCreateWithoutCategoryInput>
  }

  export type SubcategoryUpdateWithWhereUniqueWithoutCategoryInput = {
    where: SubcategoryWhereUniqueInput
    data: XOR<SubcategoryUpdateWithoutCategoryInput, SubcategoryUncheckedUpdateWithoutCategoryInput>
  }

  export type SubcategoryUpdateManyWithWhereWithoutCategoryInput = {
    where: SubcategoryScalarWhereInput
    data: XOR<SubcategoryUpdateManyMutationInput, SubcategoryUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SubcategoryScalarWhereInput = {
    AND?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    OR?: SubcategoryScalarWhereInput[]
    NOT?: SubcategoryScalarWhereInput | SubcategoryScalarWhereInput[]
    id?: StringFilter<"Subcategory"> | string
    name_en?: StringFilter<"Subcategory"> | string
    name_id?: StringFilter<"Subcategory"> | string
    categoryId?: StringFilter<"Subcategory"> | string
  }

  export type CategoryCreateWithoutAddonsInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    packages?: PackageCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutAddonsInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    packages?: PackageUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutAddonsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutAddonsInput, CategoryUncheckedCreateWithoutAddonsInput>
  }

  export type TransactionAddonsCreateWithoutAddonInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    transaction: TransactionCreateNestedOneWithoutAddonTransactionsInput
  }

  export type TransactionAddonsUncheckedCreateWithoutAddonInput = {
    id?: string
    transactionId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionAddonsCreateOrConnectWithoutAddonInput = {
    where: TransactionAddonsWhereUniqueInput
    create: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput>
  }

  export type TransactionAddonsCreateManyAddonInputEnvelope = {
    data: TransactionAddonsCreateManyAddonInput | TransactionAddonsCreateManyAddonInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutAddonsInput = {
    update: XOR<CategoryUpdateWithoutAddonsInput, CategoryUncheckedUpdateWithoutAddonsInput>
    create: XOR<CategoryCreateWithoutAddonsInput, CategoryUncheckedCreateWithoutAddonsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutAddonsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutAddonsInput, CategoryUncheckedUpdateWithoutAddonsInput>
  }

  export type CategoryUpdateWithoutAddonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    packages?: PackageUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutAddonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    packages?: PackageUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TransactionAddonsUpsertWithWhereUniqueWithoutAddonInput = {
    where: TransactionAddonsWhereUniqueInput
    update: XOR<TransactionAddonsUpdateWithoutAddonInput, TransactionAddonsUncheckedUpdateWithoutAddonInput>
    create: XOR<TransactionAddonsCreateWithoutAddonInput, TransactionAddonsUncheckedCreateWithoutAddonInput>
  }

  export type TransactionAddonsUpdateWithWhereUniqueWithoutAddonInput = {
    where: TransactionAddonsWhereUniqueInput
    data: XOR<TransactionAddonsUpdateWithoutAddonInput, TransactionAddonsUncheckedUpdateWithoutAddonInput>
  }

  export type TransactionAddonsUpdateManyWithWhereWithoutAddonInput = {
    where: TransactionAddonsScalarWhereInput
    data: XOR<TransactionAddonsUpdateManyMutationInput, TransactionAddonsUncheckedUpdateManyWithoutAddonInput>
  }

  export type TransactionAddonsScalarWhereInput = {
    AND?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
    OR?: TransactionAddonsScalarWhereInput[]
    NOT?: TransactionAddonsScalarWhereInput | TransactionAddonsScalarWhereInput[]
    id?: StringFilter<"TransactionAddons"> | string
    transactionId?: StringFilter<"TransactionAddons"> | string
    addonId?: StringFilter<"TransactionAddons"> | string
    quantity?: IntFilter<"TransactionAddons"> | number
    status?: StringFilter<"TransactionAddons"> | string
    startDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionAddons"> | Date | string | null
  }

  export type FeatureCreateWithoutPackageInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
  }

  export type FeatureUncheckedCreateWithoutPackageInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
  }

  export type FeatureCreateOrConnectWithoutPackageInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput>
  }

  export type FeatureCreateManyPackageInputEnvelope = {
    data: FeatureCreateManyPackageInput | FeatureCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type CategoryCreateWithoutPackagesInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutPackagesInput = {
    id?: string
    name_en: string
    name_id: string
    icon: string
    addons?: AddonUncheckedCreateNestedManyWithoutCategoryInput
    subcategories?: SubcategoryUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutPackagesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPackagesInput, CategoryUncheckedCreateWithoutPackagesInput>
  }

  export type SubcategoryCreateWithoutPackagesInput = {
    id?: string
    name_en: string
    name_id: string
    category: CategoryCreateNestedOneWithoutSubcategoriesInput
  }

  export type SubcategoryUncheckedCreateWithoutPackagesInput = {
    id?: string
    name_en: string
    name_id: string
    categoryId: string
  }

  export type SubcategoryCreateOrConnectWithoutPackagesInput = {
    where: SubcategoryWhereUniqueInput
    create: XOR<SubcategoryCreateWithoutPackagesInput, SubcategoryUncheckedCreateWithoutPackagesInput>
  }

  export type TransactionProductCreateWithoutPackageInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
    transaction: TransactionCreateNestedOneWithoutProductTransactionsInput
  }

  export type TransactionProductUncheckedCreateWithoutPackageInput = {
    id?: string
    transactionId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type TransactionProductCreateOrConnectWithoutPackageInput = {
    where: TransactionProductWhereUniqueInput
    create: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput>
  }

  export type TransactionProductCreateManyPackageInputEnvelope = {
    data: TransactionProductCreateManyPackageInput | TransactionProductCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type ServicesProductCustomersCreateWithoutPackageInput = {
    id?: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProductCustomersInput
    transaction: TransactionCreateNestedOneWithoutProductCustomersInput
  }

  export type ServicesProductCustomersUncheckedCreateWithoutPackageInput = {
    id?: string
    transactionId: string
    customerId: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesProductCustomersCreateOrConnectWithoutPackageInput = {
    where: ServicesProductCustomersWhereUniqueInput
    create: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesProductCustomersCreateManyPackageInputEnvelope = {
    data: ServicesProductCustomersCreateManyPackageInput | ServicesProductCustomersCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type FeatureUpsertWithWhereUniqueWithoutPackageInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutPackageInput, FeatureUncheckedUpdateWithoutPackageInput>
    create: XOR<FeatureCreateWithoutPackageInput, FeatureUncheckedCreateWithoutPackageInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutPackageInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutPackageInput, FeatureUncheckedUpdateWithoutPackageInput>
  }

  export type FeatureUpdateManyWithWhereWithoutPackageInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutPackageInput>
  }

  export type FeatureScalarWhereInput = {
    AND?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    OR?: FeatureScalarWhereInput[]
    NOT?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    id?: StringFilter<"Feature"> | string
    name_en?: StringFilter<"Feature"> | string
    name_id?: StringFilter<"Feature"> | string
    included?: BoolFilter<"Feature"> | boolean
    packageId?: StringFilter<"Feature"> | string
  }

  export type CategoryUpsertWithoutPackagesInput = {
    update: XOR<CategoryUpdateWithoutPackagesInput, CategoryUncheckedUpdateWithoutPackagesInput>
    create: XOR<CategoryCreateWithoutPackagesInput, CategoryUncheckedCreateWithoutPackagesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPackagesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPackagesInput, CategoryUncheckedUpdateWithoutPackagesInput>
  }

  export type CategoryUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    addons?: AddonUncheckedUpdateManyWithoutCategoryNestedInput
    subcategories?: SubcategoryUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type SubcategoryUpsertWithoutPackagesInput = {
    update: XOR<SubcategoryUpdateWithoutPackagesInput, SubcategoryUncheckedUpdateWithoutPackagesInput>
    create: XOR<SubcategoryCreateWithoutPackagesInput, SubcategoryUncheckedCreateWithoutPackagesInput>
    where?: SubcategoryWhereInput
  }

  export type SubcategoryUpdateToOneWithWhereWithoutPackagesInput = {
    where?: SubcategoryWhereInput
    data: XOR<SubcategoryUpdateWithoutPackagesInput, SubcategoryUncheckedUpdateWithoutPackagesInput>
  }

  export type SubcategoryUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutSubcategoriesNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutPackagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionProductUpsertWithWhereUniqueWithoutPackageInput = {
    where: TransactionProductWhereUniqueInput
    update: XOR<TransactionProductUpdateWithoutPackageInput, TransactionProductUncheckedUpdateWithoutPackageInput>
    create: XOR<TransactionProductCreateWithoutPackageInput, TransactionProductUncheckedCreateWithoutPackageInput>
  }

  export type TransactionProductUpdateWithWhereUniqueWithoutPackageInput = {
    where: TransactionProductWhereUniqueInput
    data: XOR<TransactionProductUpdateWithoutPackageInput, TransactionProductUncheckedUpdateWithoutPackageInput>
  }

  export type TransactionProductUpdateManyWithWhereWithoutPackageInput = {
    where: TransactionProductScalarWhereInput
    data: XOR<TransactionProductUpdateManyMutationInput, TransactionProductUncheckedUpdateManyWithoutPackageInput>
  }

  export type TransactionProductScalarWhereInput = {
    AND?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
    OR?: TransactionProductScalarWhereInput[]
    NOT?: TransactionProductScalarWhereInput | TransactionProductScalarWhereInput[]
    id?: StringFilter<"TransactionProduct"> | string
    transactionId?: StringFilter<"TransactionProduct"> | string
    packageId?: StringNullableFilter<"TransactionProduct"> | string | null
    quantity?: IntFilter<"TransactionProduct"> | number
    status?: StringFilter<"TransactionProduct"> | string
    startDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionProduct"> | Date | string | null
    referenceLink?: StringNullableFilter<"TransactionProduct"> | string | null
  }

  export type ServicesProductCustomersUpsertWithWhereUniqueWithoutPackageInput = {
    where: ServicesProductCustomersWhereUniqueInput
    update: XOR<ServicesProductCustomersUpdateWithoutPackageInput, ServicesProductCustomersUncheckedUpdateWithoutPackageInput>
    create: XOR<ServicesProductCustomersCreateWithoutPackageInput, ServicesProductCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesProductCustomersUpdateWithWhereUniqueWithoutPackageInput = {
    where: ServicesProductCustomersWhereUniqueInput
    data: XOR<ServicesProductCustomersUpdateWithoutPackageInput, ServicesProductCustomersUncheckedUpdateWithoutPackageInput>
  }

  export type ServicesProductCustomersUpdateManyWithWhereWithoutPackageInput = {
    where: ServicesProductCustomersScalarWhereInput
    data: XOR<ServicesProductCustomersUpdateManyMutationInput, ServicesProductCustomersUncheckedUpdateManyWithoutPackageInput>
  }

  export type UserCreateWithoutWhatsAppSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsAppSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsAppSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
  }

  export type WhatsAppMessageStatsCreateWithoutSessionInput = {
    id?: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhatsappMessageStatsInput
  }

  export type WhatsAppMessageStatsUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsCreateOrConnectWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    create: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsCreateManySessionInputEnvelope = {
    data: WhatsAppMessageStatsCreateManySessionInput | WhatsAppMessageStatsCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutWhatsAppSessionsInput = {
    update: XOR<UserUpdateWithoutWhatsAppSessionsInput, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
    create: XOR<UserCreateWithoutWhatsAppSessionsInput, UserUncheckedCreateWithoutWhatsAppSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsAppSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsAppSessionsInput, UserUncheckedUpdateWithoutWhatsAppSessionsInput>
  }

  export type UserUpdateWithoutWhatsAppSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsAppSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WhatsAppMessageStatsUpsertWithWhereUniqueWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    update: XOR<WhatsAppMessageStatsUpdateWithoutSessionInput, WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput>
    create: XOR<WhatsAppMessageStatsCreateWithoutSessionInput, WhatsAppMessageStatsUncheckedCreateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsUpdateWithWhereUniqueWithoutSessionInput = {
    where: WhatsAppMessageStatsWhereUniqueInput
    data: XOR<WhatsAppMessageStatsUpdateWithoutSessionInput, WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput>
  }

  export type WhatsAppMessageStatsUpdateManyWithWhereWithoutSessionInput = {
    where: WhatsAppMessageStatsScalarWhereInput
    data: XOR<WhatsAppMessageStatsUpdateManyMutationInput, WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionInput>
  }

  export type PaymentCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
  }

  export type PaymentUncheckedCreateWithoutTransactionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    status?: string
    paymentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expiresAt?: Date | string | null
    externalId?: string | null
    paymentUrl?: string | null
    serviceFee?: Decimal | DecimalJsLike | number | string | null
    adminNotes?: string | null
    adminAction?: string | null
    adminUserId?: string | null
    actionDate?: Date | string | null
  }

  export type PaymentCreateOrConnectWithoutTransactionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type VoucherCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voucherUsage?: VoucherUsageCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutTransactionsInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionProductCreateWithoutTransactionInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
    package?: PackageCreateNestedOneWithoutProductTransactionsInput
  }

  export type TransactionProductUncheckedCreateWithoutTransactionInput = {
    id?: string
    packageId?: string | null
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type TransactionProductCreateOrConnectWithoutTransactionInput = {
    where: TransactionProductWhereUniqueInput
    create: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionProductCreateManyTransactionInputEnvelope = {
    data: TransactionProductCreateManyTransactionInput | TransactionProductCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionAddonsCreateWithoutTransactionInput = {
    id?: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    addon: AddonCreateNestedOneWithoutAddonTransactionsInput
  }

  export type TransactionAddonsUncheckedCreateWithoutTransactionInput = {
    id?: string
    addonId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionAddonsCreateOrConnectWithoutTransactionInput = {
    where: TransactionAddonsWhereUniqueInput
    create: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionAddonsCreateManyTransactionInputEnvelope = {
    data: TransactionAddonsCreateManyTransactionInput | TransactionAddonsCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionWhatsappServiceCreateWithoutTransactionInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    whatsappPackage: WhatsappApiPackageCreateNestedOneWithoutWhatsappTransactionsInput
  }

  export type TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput = {
    id?: string
    whatsappPackageId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceCreateOrConnectWithoutTransactionInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    create: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesProductCustomersCreateWithoutTransactionInput = {
    id?: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutProductCustomersInput
    package?: PackageCreateNestedOneWithoutProductCustomersInput
  }

  export type ServicesProductCustomersUncheckedCreateWithoutTransactionInput = {
    id?: string
    customerId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesProductCustomersCreateOrConnectWithoutTransactionInput = {
    where: ServicesProductCustomersWhereUniqueInput
    create: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesProductCustomersCreateManyTransactionInputEnvelope = {
    data: ServicesProductCustomersCreateManyTransactionInput | ServicesProductCustomersCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type ServicesAddonsCustomersCreateWithoutTransactionInput = {
    id?: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutAddonCustomersInput
  }

  export type ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput = {
    id?: string
    customerId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersCreateOrConnectWithoutTransactionInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    create: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesAddonsCustomersCreateManyTransactionInputEnvelope = {
    data: ServicesAddonsCustomersCreateManyTransactionInput | ServicesAddonsCustomersCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type ServicesWhatsappCustomersCreateWithoutTransactionInput = {
    id?: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutWhatsappCustomersInput
    package: WhatsappApiPackageCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput = {
    id?: string
    customerId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateOrConnectWithoutTransactionInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    create: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesWhatsappCustomersCreateManyTransactionInputEnvelope = {
    data: ServicesWhatsappCustomersCreateManyTransactionInput | ServicesWhatsappCustomersCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsageCreateWithoutTransactionInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    user: UserCreateNestedOneWithoutVoucherUsageInput
    voucher: VoucherCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutTransactionInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput>
  }

  export type VoucherUsageCreateManyTransactionInputEnvelope = {
    data: VoucherUsageCreateManyTransactionInput | VoucherUsageCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentUpsertWithoutTransactionInput = {
    update: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
    create: XOR<PaymentCreateWithoutTransactionInput, PaymentUncheckedCreateWithoutTransactionInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutTransactionInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutTransactionInput, PaymentUncheckedUpdateWithoutTransactionInput>
  }

  export type PaymentUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    serviceFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    adminAction?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    actionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherUpsertWithoutTransactionsInput = {
    update: XOR<VoucherUpdateWithoutTransactionsInput, VoucherUncheckedUpdateWithoutTransactionsInput>
    create: XOR<VoucherCreateWithoutTransactionsInput, VoucherUncheckedCreateWithoutTransactionsInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutTransactionsInput, VoucherUncheckedUpdateWithoutTransactionsInput>
  }

  export type VoucherUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherUsage?: VoucherUsageUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type TransactionProductUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionProductWhereUniqueInput
    update: XOR<TransactionProductUpdateWithoutTransactionInput, TransactionProductUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionProductCreateWithoutTransactionInput, TransactionProductUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionProductUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionProductWhereUniqueInput
    data: XOR<TransactionProductUpdateWithoutTransactionInput, TransactionProductUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionProductUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionProductScalarWhereInput
    data: XOR<TransactionProductUpdateManyMutationInput, TransactionProductUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionAddonsUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionAddonsWhereUniqueInput
    update: XOR<TransactionAddonsUpdateWithoutTransactionInput, TransactionAddonsUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionAddonsCreateWithoutTransactionInput, TransactionAddonsUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionAddonsUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionAddonsWhereUniqueInput
    data: XOR<TransactionAddonsUpdateWithoutTransactionInput, TransactionAddonsUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionAddonsUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionAddonsScalarWhereInput
    data: XOR<TransactionAddonsUpdateManyMutationInput, TransactionAddonsUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionWhatsappServiceUpsertWithoutTransactionInput = {
    update: XOR<TransactionWhatsappServiceUpdateWithoutTransactionInput, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionWhatsappServiceCreateWithoutTransactionInput, TransactionWhatsappServiceUncheckedCreateWithoutTransactionInput>
    where?: TransactionWhatsappServiceWhereInput
  }

  export type TransactionWhatsappServiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: TransactionWhatsappServiceWhereInput
    data: XOR<TransactionWhatsappServiceUpdateWithoutTransactionInput, TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionWhatsappServiceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    whatsappPackage?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappTransactionsNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    whatsappPackageId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServicesProductCustomersUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ServicesProductCustomersWhereUniqueInput
    update: XOR<ServicesProductCustomersUpdateWithoutTransactionInput, ServicesProductCustomersUncheckedUpdateWithoutTransactionInput>
    create: XOR<ServicesProductCustomersCreateWithoutTransactionInput, ServicesProductCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesProductCustomersUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ServicesProductCustomersWhereUniqueInput
    data: XOR<ServicesProductCustomersUpdateWithoutTransactionInput, ServicesProductCustomersUncheckedUpdateWithoutTransactionInput>
  }

  export type ServicesProductCustomersUpdateManyWithWhereWithoutTransactionInput = {
    where: ServicesProductCustomersScalarWhereInput
    data: XOR<ServicesProductCustomersUpdateManyMutationInput, ServicesProductCustomersUncheckedUpdateManyWithoutTransactionInput>
  }

  export type ServicesAddonsCustomersUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    update: XOR<ServicesAddonsCustomersUpdateWithoutTransactionInput, ServicesAddonsCustomersUncheckedUpdateWithoutTransactionInput>
    create: XOR<ServicesAddonsCustomersCreateWithoutTransactionInput, ServicesAddonsCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesAddonsCustomersUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ServicesAddonsCustomersWhereUniqueInput
    data: XOR<ServicesAddonsCustomersUpdateWithoutTransactionInput, ServicesAddonsCustomersUncheckedUpdateWithoutTransactionInput>
  }

  export type ServicesAddonsCustomersUpdateManyWithWhereWithoutTransactionInput = {
    where: ServicesAddonsCustomersScalarWhereInput
    data: XOR<ServicesAddonsCustomersUpdateManyMutationInput, ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionInput>
  }

  export type ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutTransactionInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    update: XOR<ServicesWhatsappCustomersUpdateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedUpdateWithoutTransactionInput>
    create: XOR<ServicesWhatsappCustomersCreateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedCreateWithoutTransactionInput>
  }

  export type ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutTransactionInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    data: XOR<ServicesWhatsappCustomersUpdateWithoutTransactionInput, ServicesWhatsappCustomersUncheckedUpdateWithoutTransactionInput>
  }

  export type ServicesWhatsappCustomersUpdateManyWithWhereWithoutTransactionInput = {
    where: ServicesWhatsappCustomersScalarWhereInput
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionInput>
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutTransactionInput, VoucherUsageUncheckedUpdateWithoutTransactionInput>
    create: XOR<VoucherUsageCreateWithoutTransactionInput, VoucherUsageUncheckedCreateWithoutTransactionInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutTransactionInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutTransactionInput, VoucherUsageUncheckedUpdateWithoutTransactionInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutTransactionInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutTransactionInput>
  }

  export type PackageCreateWithoutProductTransactionsInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    features?: FeatureCreateNestedManyWithoutPackageInput
    category: CategoryCreateNestedOneWithoutPackagesInput
    subcategory: SubcategoryCreateNestedOneWithoutPackagesInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutProductTransactionsInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    subcategoryId: string
    popular?: boolean | null
    features?: FeatureUncheckedCreateNestedManyWithoutPackageInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutProductTransactionsInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutProductTransactionsInput, PackageUncheckedCreateWithoutProductTransactionsInput>
  }

  export type TransactionCreateWithoutProductTransactionsInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutProductTransactionsInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutProductTransactionsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProductTransactionsInput, TransactionUncheckedCreateWithoutProductTransactionsInput>
  }

  export type PackageUpsertWithoutProductTransactionsInput = {
    update: XOR<PackageUpdateWithoutProductTransactionsInput, PackageUncheckedUpdateWithoutProductTransactionsInput>
    create: XOR<PackageCreateWithoutProductTransactionsInput, PackageUncheckedCreateWithoutProductTransactionsInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutProductTransactionsInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutProductTransactionsInput, PackageUncheckedUpdateWithoutProductTransactionsInput>
  }

  export type PackageUpdateWithoutProductTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUpdateManyWithoutPackageNestedInput
    category?: CategoryUpdateOneRequiredWithoutPackagesNestedInput
    subcategory?: SubcategoryUpdateOneRequiredWithoutPackagesNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutProductTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUncheckedUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type TransactionUpsertWithoutProductTransactionsInput = {
    update: XOR<TransactionUpdateWithoutProductTransactionsInput, TransactionUncheckedUpdateWithoutProductTransactionsInput>
    create: XOR<TransactionCreateWithoutProductTransactionsInput, TransactionUncheckedCreateWithoutProductTransactionsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutProductTransactionsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutProductTransactionsInput, TransactionUncheckedUpdateWithoutProductTransactionsInput>
  }

  export type TransactionUpdateWithoutProductTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProductTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type AddonCreateWithoutAddonTransactionsInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    category: CategoryCreateNestedOneWithoutAddonsInput
  }

  export type AddonUncheckedCreateWithoutAddonTransactionsInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
    categoryId: string
  }

  export type AddonCreateOrConnectWithoutAddonTransactionsInput = {
    where: AddonWhereUniqueInput
    create: XOR<AddonCreateWithoutAddonTransactionsInput, AddonUncheckedCreateWithoutAddonTransactionsInput>
  }

  export type TransactionCreateWithoutAddonTransactionsInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAddonTransactionsInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAddonTransactionsInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAddonTransactionsInput, TransactionUncheckedCreateWithoutAddonTransactionsInput>
  }

  export type AddonUpsertWithoutAddonTransactionsInput = {
    update: XOR<AddonUpdateWithoutAddonTransactionsInput, AddonUncheckedUpdateWithoutAddonTransactionsInput>
    create: XOR<AddonCreateWithoutAddonTransactionsInput, AddonUncheckedCreateWithoutAddonTransactionsInput>
    where?: AddonWhereInput
  }

  export type AddonUpdateToOneWithWhereWithoutAddonTransactionsInput = {
    where?: AddonWhereInput
    data: XOR<AddonUpdateWithoutAddonTransactionsInput, AddonUncheckedUpdateWithoutAddonTransactionsInput>
  }

  export type AddonUpdateWithoutAddonTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: CategoryUpdateOneRequiredWithoutAddonsNestedInput
  }

  export type AddonUncheckedUpdateWithoutAddonTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionUpsertWithoutAddonTransactionsInput = {
    update: XOR<TransactionUpdateWithoutAddonTransactionsInput, TransactionUncheckedUpdateWithoutAddonTransactionsInput>
    create: XOR<TransactionCreateWithoutAddonTransactionsInput, TransactionUncheckedCreateWithoutAddonTransactionsInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutAddonTransactionsInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutAddonTransactionsInput, TransactionUncheckedUpdateWithoutAddonTransactionsInput>
  }

  export type TransactionUpdateWithoutAddonTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAddonTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionCreateWithoutWhatsappTransactionInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutWhatsappTransactionInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutWhatsappTransactionInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
  }

  export type WhatsappApiPackageCreateWithoutWhatsappTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutPackageInput
  }

  export type WhatsappApiPackageCreateOrConnectWithoutWhatsappTransactionsInput = {
    where: WhatsappApiPackageWhereUniqueInput
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
  }

  export type TransactionUpsertWithoutWhatsappTransactionInput = {
    update: XOR<TransactionUpdateWithoutWhatsappTransactionInput, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
    create: XOR<TransactionCreateWithoutWhatsappTransactionInput, TransactionUncheckedCreateWithoutWhatsappTransactionInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutWhatsappTransactionInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutWhatsappTransactionInput, TransactionUncheckedUpdateWithoutWhatsappTransactionInput>
  }

  export type TransactionUpdateWithoutWhatsappTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWhatsappTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type WhatsappApiPackageUpsertWithoutWhatsappTransactionsInput = {
    update: XOR<WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappTransactionsInput>
    where?: WhatsappApiPackageWhereInput
  }

  export type WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappTransactionsInput = {
    where?: WhatsappApiPackageWhereInput
    data: XOR<WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput>
  }

  export type WhatsappApiPackageUpdateWithoutWhatsappTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateWithoutWhatsappTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type TransactionCreateWithoutPaymentInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPaymentInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
  }

  export type TransactionUpsertWithoutPaymentInput = {
    update: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
    create: XOR<TransactionCreateWithoutPaymentInput, TransactionUncheckedCreateWithoutPaymentInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutPaymentInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutPaymentInput, TransactionUncheckedUpdateWithoutPaymentInput>
  }

  export type TransactionUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionWhatsappServiceCreateWithoutWhatsappPackageInput = {
    id?: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    transaction: TransactionCreateNestedOneWithoutWhatsappTransactionInput
  }

  export type TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput = {
    id?: string
    transactionId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionWhatsappServiceCreateOrConnectWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    create: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceCreateManyWhatsappPackageInputEnvelope = {
    data: TransactionWhatsappServiceCreateManyWhatsappPackageInput | TransactionWhatsappServiceCreateManyWhatsappPackageInput[]
    skipDuplicates?: boolean
  }

  export type ServicesWhatsappCustomersCreateWithoutPackageInput = {
    id?: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutWhatsappCustomersInput
    transaction: TransactionCreateNestedOneWithoutWhatsappCustomersInput
  }

  export type ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput = {
    id?: string
    transactionId: string
    customerId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateOrConnectWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    create: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersCreateManyPackageInputEnvelope = {
    data: ServicesWhatsappCustomersCreateManyPackageInput | ServicesWhatsappCustomersCreateManyPackageInput[]
    skipDuplicates?: boolean
  }

  export type TransactionWhatsappServiceUpsertWithWhereUniqueWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    update: XOR<TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput>
    create: XOR<TransactionWhatsappServiceCreateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedCreateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceUpdateWithWhereUniqueWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceWhereUniqueInput
    data: XOR<TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput, TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceUpdateManyWithWhereWithoutWhatsappPackageInput = {
    where: TransactionWhatsappServiceScalarWhereInput
    data: XOR<TransactionWhatsappServiceUpdateManyMutationInput, TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageInput>
  }

  export type TransactionWhatsappServiceScalarWhereInput = {
    AND?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
    OR?: TransactionWhatsappServiceScalarWhereInput[]
    NOT?: TransactionWhatsappServiceScalarWhereInput | TransactionWhatsappServiceScalarWhereInput[]
    id?: StringFilter<"TransactionWhatsappService"> | string
    transactionId?: StringFilter<"TransactionWhatsappService"> | string
    whatsappPackageId?: StringFilter<"TransactionWhatsappService"> | string
    duration?: StringFilter<"TransactionWhatsappService"> | string
    status?: StringFilter<"TransactionWhatsappService"> | string
    startDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
    endDate?: DateTimeNullableFilter<"TransactionWhatsappService"> | Date | string | null
  }

  export type ServicesWhatsappCustomersUpsertWithWhereUniqueWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    update: XOR<ServicesWhatsappCustomersUpdateWithoutPackageInput, ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput>
    create: XOR<ServicesWhatsappCustomersCreateWithoutPackageInput, ServicesWhatsappCustomersUncheckedCreateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersUpdateWithWhereUniqueWithoutPackageInput = {
    where: ServicesWhatsappCustomersWhereUniqueInput
    data: XOR<ServicesWhatsappCustomersUpdateWithoutPackageInput, ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput>
  }

  export type ServicesWhatsappCustomersUpdateManyWithWhereWithoutPackageInput = {
    where: ServicesWhatsappCustomersScalarWhereInput
    data: XOR<ServicesWhatsappCustomersUpdateManyMutationInput, ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageInput>
  }

  export type UserCreateWithoutWhatsappCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhatsappCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhatsappCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
  }

  export type TransactionCreateWithoutWhatsappCustomersInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutWhatsappCustomersInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutWhatsappCustomersInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutWhatsappCustomersInput, TransactionUncheckedCreateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageCreateWithoutWhatsappCustomersInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput = {
    id?: string
    name: string
    description?: string | null
    priceMonth: number
    priceYear: number
    maxSession: number
    createdAt?: Date | string
    updatedAt?: Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedCreateNestedManyWithoutWhatsappPackageInput
  }

  export type WhatsappApiPackageCreateOrConnectWithoutWhatsappCustomersInput = {
    where: WhatsappApiPackageWhereUniqueInput
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
  }

  export type UserUpsertWithoutWhatsappCustomersInput = {
    update: XOR<UserUpdateWithoutWhatsappCustomersInput, UserUncheckedUpdateWithoutWhatsappCustomersInput>
    create: XOR<UserCreateWithoutWhatsappCustomersInput, UserUncheckedCreateWithoutWhatsappCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappCustomersInput, UserUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type UserUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithoutWhatsappCustomersInput = {
    update: XOR<TransactionUpdateWithoutWhatsappCustomersInput, TransactionUncheckedUpdateWithoutWhatsappCustomersInput>
    create: XOR<TransactionCreateWithoutWhatsappCustomersInput, TransactionUncheckedCreateWithoutWhatsappCustomersInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutWhatsappCustomersInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutWhatsappCustomersInput, TransactionUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type TransactionUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type WhatsappApiPackageUpsertWithoutWhatsappCustomersInput = {
    update: XOR<WhatsappApiPackageUpdateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
    create: XOR<WhatsappApiPackageCreateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedCreateWithoutWhatsappCustomersInput>
    where?: WhatsappApiPackageWhereInput
  }

  export type WhatsappApiPackageUpdateToOneWithWhereWithoutWhatsappCustomersInput = {
    where?: WhatsappApiPackageWhereInput
    data: XOR<WhatsappApiPackageUpdateWithoutWhatsappCustomersInput, WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput>
  }

  export type WhatsappApiPackageUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type WhatsappApiPackageUncheckedUpdateWithoutWhatsappCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priceMonth?: IntFieldUpdateOperationsInput | number
    priceYear?: IntFieldUpdateOperationsInput | number
    maxSession?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    whatsappTransactions?: TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageNestedInput
  }

  export type UserCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserUpsertWithoutUserSessionsInput = {
    update: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type UserUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionCreateWithoutVoucherInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVoucherInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput>
  }

  export type TransactionCreateManyVoucherInputEnvelope = {
    data: TransactionCreateManyVoucherInput | TransactionCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type VoucherUsageCreateWithoutVoucherInput = {
    id?: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
    transaction?: TransactionCreateNestedOneWithoutVoucherUsageInput
    user: UserCreateNestedOneWithoutVoucherUsageInput
  }

  export type VoucherUsageUncheckedCreateWithoutVoucherInput = {
    id?: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageCreateOrConnectWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageCreateManyVoucherInputEnvelope = {
    data: VoucherUsageCreateManyVoucherInput | VoucherUsageCreateManyVoucherInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutVoucherInput, TransactionUncheckedUpdateWithoutVoucherInput>
    create: XOR<TransactionCreateWithoutVoucherInput, TransactionUncheckedCreateWithoutVoucherInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutVoucherInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutVoucherInput, TransactionUncheckedUpdateWithoutVoucherInput>
  }

  export type TransactionUpdateManyWithWhereWithoutVoucherInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutVoucherInput>
  }

  export type VoucherUsageUpsertWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    update: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
    create: XOR<VoucherUsageCreateWithoutVoucherInput, VoucherUsageUncheckedCreateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateWithWhereUniqueWithoutVoucherInput = {
    where: VoucherUsageWhereUniqueInput
    data: XOR<VoucherUsageUpdateWithoutVoucherInput, VoucherUsageUncheckedUpdateWithoutVoucherInput>
  }

  export type VoucherUsageUpdateManyWithWhereWithoutVoucherInput = {
    where: VoucherUsageScalarWhereInput
    data: XOR<VoucherUsageUpdateManyMutationInput, VoucherUsageUncheckedUpdateManyWithoutVoucherInput>
  }

  export type TransactionCreateWithoutVoucherUsageInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutVoucherUsageInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
  }

  export type UserCreateWithoutVoucherUsageInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoucherUsageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
  }

  export type VoucherCreateWithoutVoucherUsageInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutVoucherInput
  }

  export type VoucherUncheckedCreateWithoutVoucherUsageInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    type: string
    discountType: string
    value: Decimal | DecimalJsLike | number | string
    minAmount?: Decimal | DecimalJsLike | number | string | null
    maxDiscount?: Decimal | DecimalJsLike | number | string | null
    maxUses?: number | null
    usedCount?: number
    allowMultipleUsePerUser?: boolean
    isActive?: boolean
    startDate?: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutVoucherInput
  }

  export type VoucherCreateOrConnectWithoutVoucherUsageInput = {
    where: VoucherWhereUniqueInput
    create: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
  }

  export type TransactionUpsertWithoutVoucherUsageInput = {
    update: XOR<TransactionUpdateWithoutVoucherUsageInput, TransactionUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<TransactionCreateWithoutVoucherUsageInput, TransactionUncheckedCreateWithoutVoucherUsageInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutVoucherUsageInput, TransactionUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type TransactionUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserUpsertWithoutVoucherUsageInput = {
    update: XOR<UserUpdateWithoutVoucherUsageInput, UserUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<UserCreateWithoutVoucherUsageInput, UserUncheckedCreateWithoutVoucherUsageInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoucherUsageInput, UserUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type UserUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VoucherUpsertWithoutVoucherUsageInput = {
    update: XOR<VoucherUpdateWithoutVoucherUsageInput, VoucherUncheckedUpdateWithoutVoucherUsageInput>
    create: XOR<VoucherCreateWithoutVoucherUsageInput, VoucherUncheckedCreateWithoutVoucherUsageInput>
    where?: VoucherWhereInput
  }

  export type VoucherUpdateToOneWithWhereWithoutVoucherUsageInput = {
    where?: VoucherWhereInput
    data: XOR<VoucherUpdateWithoutVoucherUsageInput, VoucherUncheckedUpdateWithoutVoucherUsageInput>
  }

  export type VoucherUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutVoucherNestedInput
  }

  export type VoucherUncheckedUpdateWithoutVoucherUsageInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    discountType?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    minAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxUses?: NullableIntFieldUpdateOperationsInput | number | null
    usedCount?: IntFieldUpdateOperationsInput | number
    allowMultipleUsePerUser?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutVoucherNestedInput
  }

  export type UserCreateWithoutProductCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductCustomersInput, UserUncheckedCreateWithoutProductCustomersInput>
  }

  export type TransactionCreateWithoutProductCustomersInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutProductCustomersInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutProductCustomersInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutProductCustomersInput, TransactionUncheckedCreateWithoutProductCustomersInput>
  }

  export type PackageCreateWithoutProductCustomersInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    popular?: boolean | null
    features?: FeatureCreateNestedManyWithoutPackageInput
    category: CategoryCreateNestedOneWithoutPackagesInput
    subcategory: SubcategoryCreateNestedOneWithoutPackagesInput
    productTransactions?: TransactionProductCreateNestedManyWithoutPackageInput
  }

  export type PackageUncheckedCreateWithoutProductCustomersInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    subcategoryId: string
    popular?: boolean | null
    features?: FeatureUncheckedCreateNestedManyWithoutPackageInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutPackageInput
  }

  export type PackageCreateOrConnectWithoutProductCustomersInput = {
    where: PackageWhereUniqueInput
    create: XOR<PackageCreateWithoutProductCustomersInput, PackageUncheckedCreateWithoutProductCustomersInput>
  }

  export type UserUpsertWithoutProductCustomersInput = {
    update: XOR<UserUpdateWithoutProductCustomersInput, UserUncheckedUpdateWithoutProductCustomersInput>
    create: XOR<UserCreateWithoutProductCustomersInput, UserUncheckedCreateWithoutProductCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductCustomersInput, UserUncheckedUpdateWithoutProductCustomersInput>
  }

  export type UserUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithoutProductCustomersInput = {
    update: XOR<TransactionUpdateWithoutProductCustomersInput, TransactionUncheckedUpdateWithoutProductCustomersInput>
    create: XOR<TransactionCreateWithoutProductCustomersInput, TransactionUncheckedCreateWithoutProductCustomersInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutProductCustomersInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutProductCustomersInput, TransactionUncheckedUpdateWithoutProductCustomersInput>
  }

  export type TransactionUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PackageUpsertWithoutProductCustomersInput = {
    update: XOR<PackageUpdateWithoutProductCustomersInput, PackageUncheckedUpdateWithoutProductCustomersInput>
    create: XOR<PackageCreateWithoutProductCustomersInput, PackageUncheckedCreateWithoutProductCustomersInput>
    where?: PackageWhereInput
  }

  export type PackageUpdateToOneWithWhereWithoutProductCustomersInput = {
    where?: PackageWhereInput
    data: XOR<PackageUpdateWithoutProductCustomersInput, PackageUncheckedUpdateWithoutProductCustomersInput>
  }

  export type PackageUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUpdateManyWithoutPackageNestedInput
    category?: CategoryUpdateOneRequiredWithoutPackagesNestedInput
    subcategory?: SubcategoryUpdateOneRequiredWithoutPackagesNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutProductCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUncheckedUpdateManyWithoutPackageNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type UserCreateWithoutAddonCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddonCustomersInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddonCustomersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddonCustomersInput, UserUncheckedCreateWithoutAddonCustomersInput>
  }

  export type TransactionCreateWithoutAddonCustomersInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentCreateNestedOneWithoutTransactionInput
    user: UserCreateNestedOneWithoutTransactionsInput
    voucher?: VoucherCreateNestedOneWithoutTransactionsInput
    productTransactions?: TransactionProductCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAddonCustomersInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
    payment?: PaymentUncheckedCreateNestedOneWithoutTransactionInput
    productTransactions?: TransactionProductUncheckedCreateNestedManyWithoutTransactionInput
    addonTransactions?: TransactionAddonsUncheckedCreateNestedManyWithoutTransactionInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedCreateNestedOneWithoutTransactionInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutTransactionInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutTransactionInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAddonCustomersInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAddonCustomersInput, TransactionUncheckedCreateWithoutAddonCustomersInput>
  }

  export type UserUpsertWithoutAddonCustomersInput = {
    update: XOR<UserUpdateWithoutAddonCustomersInput, UserUncheckedUpdateWithoutAddonCustomersInput>
    create: XOR<UserCreateWithoutAddonCustomersInput, UserUncheckedCreateWithoutAddonCustomersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddonCustomersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddonCustomersInput, UserUncheckedUpdateWithoutAddonCustomersInput>
  }

  export type UserUpdateWithoutAddonCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddonCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TransactionUpsertWithoutAddonCustomersInput = {
    update: XOR<TransactionUpdateWithoutAddonCustomersInput, TransactionUncheckedUpdateWithoutAddonCustomersInput>
    create: XOR<TransactionCreateWithoutAddonCustomersInput, TransactionUncheckedCreateWithoutAddonCustomersInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutAddonCustomersInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutAddonCustomersInput, TransactionUncheckedUpdateWithoutAddonCustomersInput>
  }

  export type TransactionUpdateWithoutAddonCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAddonCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type UserCreateWithoutWhatsappMessageStatsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersCreateNestedManyWithoutCustomerInput
  }

  export type UserUncheckedCreateWithoutWhatsappMessageStatsInput = {
    id?: string
    name?: string | null
    email?: string | null
    phone?: string | null
    password?: string | null
    otp?: string | null
    otpExpires?: Date | string | null
    otpVerificationDeadline?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    image?: string | null
    emailVerificationToken?: string | null
    emailVerificationTokenExpires?: Date | string | null
    role?: string
    apiKey?: string | null
    updatedAt?: Date | string
    emailOtp?: string | null
    emailOtpExpires?: Date | string | null
    resetPasswordOtp?: string | null
    resetPasswordOtpExpires?: Date | string | null
    resetPasswordLastRequestAt?: Date | string | null
    ssoOtp?: string | null
    ssoOtpExpires?: Date | string | null
    ssoLastRequestAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    voucherUsage?: VoucherUsageUncheckedCreateNestedManyWithoutUserInput
    whatsAppSessions?: WhatsAppSessionUncheckedCreateNestedManyWithoutUserInput
    productCustomers?: ServicesProductCustomersUncheckedCreateNestedManyWithoutCustomerInput
    addonCustomers?: ServicesAddonsCustomersUncheckedCreateNestedManyWithoutCustomerInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type UserCreateOrConnectWithoutWhatsappMessageStatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhatsappMessageStatsInput, UserUncheckedCreateWithoutWhatsappMessageStatsInput>
  }

  export type WhatsAppSessionCreateWithoutWhatsappMessageStatsInput = {
    id?: string
    sessionId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
    user: UserCreateNestedOneWithoutWhatsAppSessionsInput
  }

  export type WhatsAppSessionUncheckedCreateWithoutWhatsappMessageStatsInput = {
    id?: string
    sessionId: string
    userId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
  }

  export type WhatsAppSessionCreateOrConnectWithoutWhatsappMessageStatsInput = {
    where: WhatsAppSessionWhereUniqueInput
    create: XOR<WhatsAppSessionCreateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsappMessageStatsInput>
  }

  export type UserUpsertWithoutWhatsappMessageStatsInput = {
    update: XOR<UserUpdateWithoutWhatsappMessageStatsInput, UserUncheckedUpdateWithoutWhatsappMessageStatsInput>
    create: XOR<UserCreateWithoutWhatsappMessageStatsInput, UserUncheckedCreateWithoutWhatsappMessageStatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhatsappMessageStatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhatsappMessageStatsInput, UserUncheckedUpdateWithoutWhatsappMessageStatsInput>
  }

  export type UserUpdateWithoutWhatsappMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutCustomerNestedInput
  }

  export type UserUncheckedUpdateWithoutWhatsappMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    otp?: NullableStringFieldUpdateOperationsInput | string | null
    otpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    otpVerificationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerificationTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
    apiKey?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailOtp?: NullableStringFieldUpdateOperationsInput | string | null
    emailOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordOtp?: NullableStringFieldUpdateOperationsInput | string | null
    resetPasswordOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetPasswordLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoOtp?: NullableStringFieldUpdateOperationsInput | string | null
    ssoOtpExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ssoLastRequestAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutUserNestedInput
    whatsAppSessions?: WhatsAppSessionUncheckedUpdateManyWithoutUserNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type WhatsAppSessionUpsertWithoutWhatsappMessageStatsInput = {
    update: XOR<WhatsAppSessionUpdateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedUpdateWithoutWhatsappMessageStatsInput>
    create: XOR<WhatsAppSessionCreateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedCreateWithoutWhatsappMessageStatsInput>
    where?: WhatsAppSessionWhereInput
  }

  export type WhatsAppSessionUpdateToOneWithWhereWithoutWhatsappMessageStatsInput = {
    where?: WhatsAppSessionWhereInput
    data: XOR<WhatsAppSessionUpdateWithoutWhatsappMessageStatsInput, WhatsAppSessionUncheckedUpdateWithoutWhatsappMessageStatsInput>
  }

  export type WhatsAppSessionUpdateWithoutWhatsappMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutWhatsAppSessionsNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutWhatsappMessageStatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    voucherId?: string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type UserSessionCreateManyUserInput = {
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    lastUsed?: Date | string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type VoucherUsageCreateManyUserInput = {
    id?: string
    voucherId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppSessionCreateManyUserInput = {
    id?: string
    sessionId: string
    status: string
    qr?: string | null
    isNotification?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    aiConfig?: string | null
    message?: string | null
    sessionName?: string | null
    isTerminated?: boolean
  }

  export type ServicesProductCustomersCreateManyCustomerInput = {
    id?: string
    transactionId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersCreateManyCustomerInput = {
    id?: string
    transactionId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateManyCustomerInput = {
    id?: string
    transactionId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsCreateManyUserInput = {
    id?: string
    sessionId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    voucher?: VoucherUpdateOneWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    voucherId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastUsed?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VoucherUsageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WhatsAppSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
    whatsappMessageStats?: WhatsAppMessageStatsUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
    whatsappMessageStats?: WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type WhatsAppSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    qr?: NullableStringFieldUpdateOperationsInput | string | null
    isNotification?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    aiConfig?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    sessionName?: NullableStringFieldUpdateOperationsInput | string | null
    isTerminated?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicesProductCustomersUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutProductCustomersNestedInput
    package?: PackageUpdateOneWithoutProductCustomersNestedInput
  }

  export type ServicesProductCustomersUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutAddonCustomersNestedInput
  }

  export type ServicesAddonsCustomersUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    package?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: WhatsAppSessionUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackageCreateManySubcategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    categoryId: string
    popular?: boolean | null
  }

  export type PackageUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUpdateManyWithoutPackageNestedInput
    category?: CategoryUpdateOneRequiredWithoutPackagesNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUncheckedUpdateManyWithoutPackageNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateManyWithoutSubcategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AddonCreateManyCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en?: string | null
    description_id?: string | null
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image?: string | null
  }

  export type PackageCreateManyCategoryInput = {
    id?: string
    name_en: string
    name_id: string
    description_en: string
    description_id: string
    price_idr: Decimal | DecimalJsLike | number | string
    price_usd: Decimal | DecimalJsLike | number | string
    image: string
    subcategoryId: string
    popular?: boolean | null
  }

  export type SubcategoryCreateManyCategoryInput = {
    id?: string
    name_en: string
    name_id: string
  }

  export type AddonUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    addonTransactions?: TransactionAddonsUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutAddonNestedInput
  }

  export type AddonUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: NullableStringFieldUpdateOperationsInput | string | null
    description_id?: NullableStringFieldUpdateOperationsInput | string | null
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PackageUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUpdateManyWithoutPackageNestedInput
    subcategory?: SubcategoryUpdateOneRequiredWithoutPackagesNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
    features?: FeatureUncheckedUpdateManyWithoutPackageNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutPackageNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutPackageNestedInput
  }

  export type PackageUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    description_en?: StringFieldUpdateOperationsInput | string
    description_id?: StringFieldUpdateOperationsInput | string
    price_idr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    price_usd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    image?: StringFieldUpdateOperationsInput | string
    subcategoryId?: StringFieldUpdateOperationsInput | string
    popular?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type SubcategoryUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    packages?: PackageUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    packages?: PackageUncheckedUpdateManyWithoutSubcategoryNestedInput
  }

  export type SubcategoryUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionAddonsCreateManyAddonInput = {
    id?: string
    transactionId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type TransactionAddonsUpdateWithoutAddonInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneRequiredWithoutAddonTransactionsNestedInput
  }

  export type TransactionAddonsUncheckedUpdateWithoutAddonInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionAddonsUncheckedUpdateManyWithoutAddonInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeatureCreateManyPackageInput = {
    id?: string
    name_en: string
    name_id: string
    included: boolean
  }

  export type TransactionProductCreateManyPackageInput = {
    id?: string
    transactionId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type ServicesProductCustomersCreateManyPackageInput = {
    id?: string
    transactionId: string
    customerId: string
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FeatureUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name_en?: StringFieldUpdateOperationsInput | string
    name_id?: StringFieldUpdateOperationsInput | string
    included?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionProductUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
    transaction?: TransactionUpdateOneRequiredWithoutProductTransactionsNestedInput
  }

  export type TransactionProductUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionProductUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServicesProductCustomersUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProductCustomersNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutProductCustomersNestedInput
  }

  export type ServicesProductCustomersUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsCreateManySessionInput = {
    id?: string
    userId: string
    totalMessagesSent?: number
    totalMessagesFailed?: number
    lastMessageSentAt?: Date | string | null
    lastMessageFailedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppMessageStatsUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhatsappMessageStatsNestedInput
  }

  export type WhatsAppMessageStatsUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppMessageStatsUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMessagesSent?: IntFieldUpdateOperationsInput | number
    totalMessagesFailed?: IntFieldUpdateOperationsInput | number
    lastMessageSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessageFailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionProductCreateManyTransactionInput = {
    id?: string
    packageId?: string | null
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    referenceLink?: string | null
  }

  export type TransactionAddonsCreateManyTransactionInput = {
    id?: string
    addonId: string
    quantity?: number
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type ServicesProductCustomersCreateManyTransactionInput = {
    id?: string
    customerId: string
    packageId?: string | null
    quantity?: number
    websiteUrl?: string | null
    driveUrl?: string | null
    textDescription?: string | null
    domainName?: string | null
    domainExpiredAt?: Date | string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesAddonsCustomersCreateManyTransactionInput = {
    id?: string
    customerId: string
    addonDetails: string
    driveUrl?: string | null
    fileAssets?: string | null
    status?: string
    deliveredAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicesWhatsappCustomersCreateManyTransactionInput = {
    id?: string
    customerId: string
    packageId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VoucherUsageCreateManyTransactionInput = {
    id?: string
    voucherId: string
    userId: string
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type TransactionProductUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
    package?: PackageUpdateOneWithoutProductTransactionsNestedInput
  }

  export type TransactionProductUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionProductUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionAddonsUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    addon?: AddonUpdateOneRequiredWithoutAddonTransactionsNestedInput
  }

  export type TransactionAddonsUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionAddonsUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServicesProductCustomersUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutProductCustomersNestedInput
    package?: PackageUpdateOneWithoutProductCustomersNestedInput
  }

  export type ServicesProductCustomersUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesProductCustomersUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    textDescription?: NullableStringFieldUpdateOperationsInput | string | null
    domainName?: NullableStringFieldUpdateOperationsInput | string | null
    domainExpiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutAddonCustomersNestedInput
  }

  export type ServicesAddonsCustomersUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    addonDetails?: StringFieldUpdateOperationsInput | string
    driveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileAssets?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    package?: WhatsappApiPackageUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    packageId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoucherUsageUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
    voucher?: VoucherUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    voucherId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TransactionWhatsappServiceCreateManyWhatsappPackageInput = {
    id?: string
    transactionId: string
    duration: string
    status?: string
    startDate?: Date | string | null
    endDate?: Date | string | null
  }

  export type ServicesWhatsappCustomersCreateManyPackageInput = {
    id?: string
    transactionId: string
    customerId: string
    sessionId?: string | null
    qrCode?: string | null
    status?: string
    expiredAt: Date | string
    activatedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionWhatsappServiceUpdateWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappTransactionNestedInput
  }

  export type TransactionWhatsappServiceUncheckedUpdateWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionWhatsappServiceUncheckedUpdateManyWithoutWhatsappPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServicesWhatsappCustomersUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutWhatsappCustomersNestedInput
    transaction?: TransactionUpdateOneRequiredWithoutWhatsappCustomersNestedInput
  }

  export type ServicesWhatsappCustomersUncheckedUpdateWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicesWhatsappCustomersUncheckedUpdateManyWithoutPackageInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    expiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyVoucherInput = {
    id?: string
    userId: string
    transactionDate?: Date | string
    status?: string
    amount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    type: string
    updatedAt?: Date | string
    discountAmount?: Decimal | DecimalJsLike | number | string | null
    originalAmount?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    currency?: string
    finalAmount?: Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: Decimal | DecimalJsLike | number | string | null
    expiresAt?: Date | string | null
  }

  export type VoucherUsageCreateManyVoucherInput = {
    id?: string
    userId: string
    transactionId?: string | null
    usedAt?: Date | string
    discountAmount: Decimal | DecimalJsLike | number | string
  }

  export type TransactionUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUpdateOneWithoutTransactionNestedInput
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    productTransactions?: TransactionProductUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment?: PaymentUncheckedUpdateOneWithoutTransactionNestedInput
    productTransactions?: TransactionProductUncheckedUpdateManyWithoutTransactionNestedInput
    addonTransactions?: TransactionAddonsUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappTransaction?: TransactionWhatsappServiceUncheckedUpdateOneWithoutTransactionNestedInput
    productCustomers?: ServicesProductCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    addonCustomers?: ServicesAddonsCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    whatsappCustomers?: ServicesWhatsappCustomersUncheckedUpdateManyWithoutTransactionNestedInput
    voucherUsage?: VoucherUsageUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    originalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    finalAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    serviceFeeAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalAfterDiscount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VoucherUsageUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    transaction?: TransactionUpdateOneWithoutVoucherUsageNestedInput
    user?: UserUpdateOneRequiredWithoutVoucherUsageNestedInput
  }

  export type VoucherUsageUncheckedUpdateWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type VoucherUsageUncheckedUpdateManyWithoutVoucherInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}